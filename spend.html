<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spend</title>
    <!-- Google Fonts - PEBL Brand Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400&display=swap" rel="stylesheet">

    <!-- External Libraries for Gmail & PDF Processing -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        .nav-banner { position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); padding: 15px 40px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 30px; margin-bottom: 0; z-index: 100; }
        .nav-banner .page-title { color: white; font-size: 28px; font-weight: 700; margin: 0; font-family: 'Roboto', sans-serif; letter-spacing: 0.5px; }
        .nav-banner h1 { color: white; font-size: 28px; font-weight: 700; margin: 0; font-family: 'Roboto', sans-serif; letter-spacing: 0.5px; }
        .nav-buttons { display: flex; gap: 8px; }
        .nav-btn { background-color: rgba(255, 255, 255, 0.15); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; display: inline-block; font-family: 'Roboto', sans-serif; }
        .nav-btn:hover { background-color: rgba(255, 255, 255, 0.25); border-color: rgba(255, 255, 255, 0.5); }
        .nav-btn.active { background-color: rgba(255, 255, 255, 0.9); color: #2B7A78; border-color: rgba(255, 255, 255, 0.9); }
        .content-container { padding: 20px; max-width: 1200px; margin: 0 auto; padding-top: 90px; }

        body {
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #DEF2F1 0%, #ffffff 100%);
            min-height: 100vh;
        }

        /* Upload Section */
        .upload-section {
            background-color: #f5f5f5;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px dashed #3AAFA9;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .upload-section.drag-over {
            background-color: #e8eaf6;
            border-color: #2B7A78;
            border-width: 3px;
            transform: scale(1.02);
        }
        .upload-section p {
            margin: 10px 0 0 0;
            color: #666;
            font-size: 14px;
        }
        .upload-label {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Table Container */
        .table-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-x: auto;
            overflow-y: hidden;
        }
        #transactionsTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        #transactionsTable thead {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
        }
        #transactionsTable th {
            padding: 8px 6px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #transactionsTable tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s ease;
        }
        #transactionsTable tbody tr:hover {
            background-color: #f8f9ff;
        }
        #transactionsTable td {
            padding: 6px;
            vertical-align: middle;
        }
        #transactionsTable td.notes-cell {
            max-width: 200px;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 11px;
            color: #555;
        }
        .empty-state td {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }
        .description-cell {
            max-width: 450px;
            font-size: 11px;
        }
        .original-description {
            color: #999;
            font-size: 10px;
            font-style: italic;
        }
        .manual-description {
            color: #333;
            font-weight: 500;
            margin-bottom: 3px;
            font-size: 11px;
        }
        .manual-description::before {
            content: "üìù ";
        }
        .amount-spent {
            color: #d32f2f;
            font-weight: 600;
        }
        .amount-received {
            color: #2e7d32;
            font-weight: 600;
        }
        .fromto-cell {
            min-width: 120px;
            max-width: 200px;
            font-size: 11px;
            color: #64748b;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            white-space: nowrap;
        }
        .action-btn {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .action-btn:hover {
            background-color: #3AAFA9;
            border-color: #3AAFA9;
        }
        .action-btn:hover svg {
            stroke: white;
        }
        .action-btn svg {
            display: block;
            stroke: #555;
            transition: stroke 0.2s ease;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.active {
            display: flex;
        }
        /* When modal is positioned near a button, disable flex centering */
        .modal-overlay.active.positioned {
            display: block;
            align-items: unset;
            justify-content: unset;
        }
        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            color: #333;
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
        }
        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        .form-input:focus {
            outline: none;
            border-color: #3AAFA9;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-btn {
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        .modal-btn-primary {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
        }
        .modal-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .modal-btn-secondary {
            background-color: #f5f5f5;
            color: #555;
            border: 1px solid #ddd;
        }
        .modal-btn-secondary:hover {
            background-color: #e0e0e0;
        }
        .modal-btn-danger {
            background-color: #dc3545;
            color: white;
            border: none;
        }
        .modal-btn-danger:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        .current-value {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }
        .category-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: white;
        }
        .category-option:hover {
            border-color: #3AAFA9;
            background-color: #f8f9ff;
        }
        .category-option.selected {
            border-color: #3AAFA9;
            background-color: #e8eaf6;
        }
        .category-option.keyboard-selected {
            border-color: #f59e0b !important;
            background-color: #fef3c7 !important;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
        }
        .category-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        tbody tr.row-selected {
            background-color: #dbeafe !important;
            border-left: 4px solid #3b82f6 !important;
        }
        tbody tr:focus {
            outline: none;
        }
        .keyboard-shortcut-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .keyboard-shortcut-hint.visible {
            opacity: 1;
        }
        .category-budget {
            font-size: 12px;
            color: #666;
        }
        .budget-warning {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .assigned-category {
            display: inline-block;
            background-color: #e8eaf6;
            color: #3AAFA9;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
            vertical-align: top;
            line-height: 1.3;
        }

        /* Voice Recording Styles - Row Action Buttons */
        .action-btn {
            background-color: transparent;
            border: none;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
            border-radius: 4px;
        }
        .action-btn:hover {
            transform: scale(1.2);
        }
        .action-btn.edit-btn {
            color: #3AAFA9;
        }
        .action-btn.edit-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.mic-btn {
            color: #3AAFA9;
        }
        .action-btn.mic-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.mic-btn.recording {
            color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        .action-btn.mic-btn.processing {
            color: #f59e0b;
        }
        .action-btn.delete-btn {
            color: #dc2626;
        }
        .action-btn.delete-btn:hover {
            background-color: #fee2e2;
        }
        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: #17252A;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            max-width: 400px;
            font-family: 'Roboto', sans-serif;
            font-size: 13px;
            line-height: 1.4;
        }
        .toast.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        .toast.positioned {
            animation: fadeIn 0.2s ease;
        }
        .toast.success {
            background-color: #059669;
        }
        .toast.error {
            background-color: #dc2626;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Transcription Modal */
        .transcription-modal {
            display: none;
            position: fixed;
            z-index: 1500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .transcription-modal.show {
            display: flex;
        }
        .transcription-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        .transcription-content h3 {
            color: #17252A;
            margin-bottom: 15px;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
        }
        .transcription-content textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid #DEF2F1;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            margin-bottom: 20px;
            resize: vertical;
        }
        .transcription-content textarea:focus {
            outline: none;
            border-color: #3AAFA9;
        }
        .transcription-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .transcription-buttons button {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            transition: all 0.2s;
        }
        .transcription-buttons .cancel-btn {
            background-color: #e2e8f0;
            color: #334155;
        }
        .transcription-buttons .cancel-btn:hover {
            background-color: #cbd5e1;
        }
        .transcription-buttons .process-btn {
            background-color: #3AAFA9;
            color: white;
        }
        .transcription-buttons .process-btn:hover {
            background-color: #2B7A78;
        }

        /* Invoice Search & Gmail Integration Styles */
        .action-btn.invoice-btn {
            color: #3AAFA9;
            position: relative;
        }
        .action-btn.invoice-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.invoice-btn.searching {
            color: #f59e0b;
            animation: pulse 1.5s infinite;
        }
        .action-btn.invoice-btn.invoice-attached::after {
            content: "üìé";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
        }
        .gmail-account-badge {
            display: inline-block;
            background: #e8f5e9;
            padding: 6px 12px;
            border-radius: 4px;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            border: 1px solid #4caf50;
        }
        .invoice-result-card {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid #3AAFA9;
        }
        .invoice-result-card:hover {
            background: #f0f0f0;
        }
        .pdf-attachment-btn {
            margin: 5px 5px 0 0;
            font-size: 13px;
            padding: 8px 15px;
        }
        /* Custom scrollbar for results container */
        #searchResultsContainer {
            scrollbar-width: thin;
            scrollbar-color: #3AAFA9 #f1f5f9;
        }
        #searchResultsContainer::-webkit-scrollbar {
            width: 6px;
        }
        #searchResultsContainer::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        #searchResultsContainer::-webkit-scrollbar-thumb {
            background: #3AAFA9;
            border-radius: 3px;
        }
        #searchResultsContainer::-webkit-scrollbar-thumb:hover {
            background: #2B7A78;
        }
    </style>

    <!-- Automatic Cloud Backup System -->
    <script src="supabase-client.js"></script>
    <script src="auto-sync-manager.js"></script>
    <script src="sync-status-indicator.js"></script>
</head>
<body>
    <!-- Navigation Banner -->
    <div class="nav-banner">
        <h1>PEBLGen</h1>
        <div class="nav-buttons">
            <a href="grants.html" class="nav-btn">Grants</a>
            <a href="spend.html" class="nav-btn active">Spend</a>
            <a href="gantt.html" class="nav-btn">Gantt</a>
            <a href="timesheet.html" class="nav-btn">Timesheet</a>
            <a href="index.html" class="nav-btn">Sketcher</a>
            <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="nav-btn" style="background-color: rgba(255, 255, 255, 0.15); margin-left: auto;" title="Scroll to top">‚Üë Top</button>
        </div>
    </div>

    <div class="content-container">

    <!-- Filters Card -->
    <div class="table-container" style="margin-bottom: 20px;">
        <div style="padding: 15px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                <span style="font-size: 20px;">üîç</span>
                <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: #333;">Filters</h4>
                <button onclick="jumpToTopUnassigned()" style="margin-left: auto; padding: 4px 10px; font-size: 11px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">To Top Unassigned</button>
                <button onclick="clearFilters()" style="padding: 4px 10px; font-size: 11px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #555; margin-bottom: 4px;">Project Budget</label>
                    <select id="filterProject" onchange="handleProjectFilterChange()" style="width: 100%; padding: 6px 10px; font-size: 12px; border: 1px solid #d1d5db; border-radius: 4px; background: white;">
                        <option value="">All Projects</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #555; margin-bottom: 4px;">Category</label>
                    <select id="filterCategory" onchange="applyFilters()" style="width: 100%; padding: 6px 10px; font-size: 12px; border: 1px solid #d1d5db; border-radius: 4px; background: white;" disabled>
                        <option value="">All Categories</option>
                    </select>
                </div>
            </div>
            <div id="filterStatus" style="margin-top: 10px; font-size: 11px; color: #666; font-style: italic;">
                <!-- Status message -->
            </div>
        </div>
    </div>

    <!-- Compact Control Panel -->
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">

        <!-- API Config Card -->
        <div class="table-container" style="margin: 0;">
            <div style="padding: 15px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 20px;">üîë</span>
                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: #333;">API Config</h4>
                </div>
                <div id="apiKeyStatus" style="font-size: 12px; color: #666; margin-bottom: 10px; min-height: 18px;">
                    <!-- Populated dynamically -->
                </div>
                <div style="display: flex; gap: 5px;">
                    <button onclick="updateOpenAIKey()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 6px 12px; font-size: 12px; flex: 1;">
                        Set Key
                    </button>
                    <button onclick="clearOpenAIKey()" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 6px 12px; font-size: 12px;">
                        Clear
                    </button>
                </div>
            </div>
        </div>

        <!-- Gmail Integration Card -->
        <div class="table-container" style="margin: 0;">
            <div style="padding: 15px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 20px;">üìß</span>
                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: #333;">Gmail</h4>
                </div>
                <div id="gmailConnectionStatus" style="font-size: 12px; color: #666; margin-bottom: 10px; min-height: 18px;">
                    Not connected
                </div>
                <div id="gmailAccountsList" style="margin-bottom: 10px; max-height: 120px; overflow-y: auto;">
                    <!-- Populated dynamically -->
                </div>
                <button id="gmailConnectBtn" onclick="signInToGmail()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 6px 12px; font-size: 12px; width: 100%;">
                    Connect
                </button>
            </div>
        </div>

        <!-- Project Budgets Card -->
        <div class="table-container" style="margin: 0;">
            <div style="padding: 15px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 20px;">üìä</span>
                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: #333;">Project Budgets</h4>
                </div>
                <div id="loadedBudgetsInfo" style="font-size: 12px; color: #666; margin-bottom: 10px; min-height: 18px;">
                    Loading...
                </div>
                <button onclick="loadProjectsFromDB()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 6px 12px; font-size: 12px; width: 100%;">
                    Refresh
                </button>
            </div>
        </div>

        <!-- Bank Feed Data Card -->
        <div class="table-container" id="bankFeedDropZone" style="margin: 0; transition: all 0.2s; overflow: visible;">
            <div style="padding: 15px; position: relative;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <span style="font-size: 20px;">üìÅ</span>
                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: #333; flex: 1;">Bank Feed</h4>

                    <!-- Table Settings Button -->
                    <button onclick="toggleTableSettings()" id="tableSettingsBtn" style="background: white; border: 1px solid #d1d5db; border-radius: 6px; padding: 4px 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" title="Table Display Settings">
                        ‚öôÔ∏è
                    </button>
                </div>

                <!-- Settings Dropdown Menu -->
                <div id="tableSettingsMenu" style="display: none; position: absolute; top: 50px; right: 15px; background: white; border: 1px solid #d1d5db; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 280px; padding: 12px; z-index: 1000;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #374151; border-bottom: 1px solid #e5e7eb; padding-bottom: 8px;">Table Display Settings</div>

                    <!-- Spent Section -->
                    <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #f3f4f6;">
                        <div style="font-size: 11px; font-weight: 600; color: #059669; margin-bottom: 4px;">üí≥ Spent (Expenses)</div>

                        <label style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; cursor: pointer; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showSpentColumnToggle" onchange="toggleSpentColumn()" style="cursor: pointer;" checked>
                            <div>
                                <div style="font-size: 12px; font-weight: 500; color: #1f2937;">Show Spent Columns</div>
                                <div style="font-size: 10px; color: #6b7280;">Display spent amount columns</div>
                            </div>
                        </label>
                    </div>

                    <!-- Received Section -->
                    <div>
                        <div style="font-size: 11px; font-weight: 600; color: #3b82f6; margin-bottom: 4px;">üí∞ Received (Income)</div>

                        <label style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; cursor: pointer; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showReceivedColumnToggle" onchange="toggleReceivedColumn()" style="cursor: pointer;">
                            <div>
                                <div style="font-size: 12px; font-weight: 500; color: #1f2937;">Show Received Column</div>
                                <div style="font-size: 10px; color: #6b7280;">Display received amount column</div>
                            </div>
                        </label>
                    </div>
                </div>

                <div id="csvSummaryContent" style="font-size: 12px; color: #666; margin-bottom: 8px; min-height: 18px;">
                    No files loaded ‚Ä¢ Drop CSV files here
                </div>
                <button onclick="openCSVManager()" style="font-size: 11px; padding: 3px 8px; margin-bottom: 8px; background: #3AAFA9; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    Manage Files
                </button>
                <div style="font-size: 11px; color: #888; margin-bottom: 10px; line-height: 1.4;">
                    <div><span id="totalTransactions">0</span> transactions</div>
                    <div>Spent: ¬£<span id="totalSpent">0.00</span> | Received: ¬£<span id="totalReceived">0.00</span></div>
                </div>
                <div style="display: flex; gap: 5px; flex-direction: column;">
                    <div style="display: flex; gap: 5px;">
                        <label for="csvFileInput" class="modal-btn modal-btn-primary" style="margin: 0; padding: 6px 12px; font-size: 12px; flex: 1; cursor: pointer; text-align: center;">
                            Load CSV
                        </label>
                        <button onclick="clearAllTransactions(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 6px 12px; font-size: 12px;">
                            Clear View
                        </button>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="fixDuplicates(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 6px 12px; font-size: 11px; flex: 1; background: #f59e0b; color: white;" title="Remove duplicate transactions from database">
                            üîß Fix Duplicates
                        </button>
                        <button onclick="clearAndRefreshDatabase(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 6px 12px; font-size: 11px; flex: 1; background: #dc2626; color: white;" title="Clear CSV files only (preserves project budgets)">
                            üîÑ Reset CSVs
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Hidden file input -->
    <input type="file" id="csvFileInput" accept=".csv" multiple style="display: none;">

    <!-- Transactions Table -->
    <div class="table-container">
        <table id="transactionsTable">
            <thead>
                <tr>
                    <th>Bank</th>
                    <th>Date</th>
                    <th>Description</th>
                    <th>Detail</th>
                    <th>From/To</th>
                    <th>Spent</th>
                    <th>Spent (ex. VAT)</th>
                    <th>Received</th>
                    <th>Notes</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="tableBody">
                <tr class="empty-state">
                    <td colspan="10">No transactions loaded. Please upload a CSV file.</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- Edit Description Modal -->
    <div class="modal-overlay" id="editDescriptionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Transaction Description</h3>
                <button class="modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Transaction Date</label>
                    <div class="current-value" id="modalDate"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Current Description</label>
                    <div class="current-value" id="modalCurrentDescription"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Manual Description / Notes</label>
                    <textarea
                        class="form-input form-textarea"
                        id="modalManualDescription"
                        placeholder="Enter custom description or notes for this expense..."
                    ></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Voice Notes</label>
                    <textarea
                        class="form-input form-textarea"
                        id="modalVoiceNotes"
                        placeholder="Voice notes for this transaction..."
                        style="min-height: 60px;"
                    ></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Amount</label>
                    <div class="current-value" id="modalAmount"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveManualDescription()">Save</button>
            </div>
        </div>
    </div>

    <!-- Assign Budget Category Modal -->
    <div class="modal-overlay" id="assignCategoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Assign to Budget Category</h3>
                <button class="modal-close" onclick="closeAssignModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="assignModalContent"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeAssignModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveAssignment()">Assign</button>
            </div>
        </div>
    </div>

    <!-- Transcription Modal -->
    <div id="transcriptionModal" class="transcription-modal">
        <div class="transcription-content">
            <h3>Review Voice Note</h3>
            <p style="color: #64748b; font-size: 14px; margin-bottom: 10px;">Edit the text if needed, then click "Save" to add this note to the transaction:</p>
            <textarea id="transcriptionText" placeholder="Your speech will appear here..."></textarea>
            <div class="transcription-buttons">
                <button class="cancel-btn" onclick="closeTranscriptionModal()">Cancel</button>
                <button class="process-btn" onclick="processTranscription()">Save Note</button>
            </div>
        </div>
    </div>

    <!-- Text Popup Modal (for long descriptions/details) -->
    <div id="textPopupModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="modal-title" id="textPopupTitle">Full Text</h3>
                <button class="modal-close" onclick="closeTextPopup()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="textPopupContent" style="font-size: 13px; line-height: 1.6; color: #1e293b; word-wrap: break-word; white-space: pre-wrap;"></p>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeTextPopup()">Close</button>
            </div>
        </div>
    </div>

    <!-- Invoice Search Modal -->
    <div id="invoiceSearchModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">üìß Invoice Search Results</h3>
                <button class="modal-close" onclick="closeInvoiceSearchModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="invoiceSearchStatus" style="padding: 15px; background: #f5f5f5; border-radius: 6px; margin-bottom: 15px;">
                    <strong>Transaction:</strong> <span id="searchTransactionInfo"></span>
                </div>

                <div id="invoiceSearchResults" style="max-height: 500px; overflow-y: auto;">
                    <!-- Populated dynamically -->
                </div>

                <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">
                    <strong>üí° Tip:</strong> No results? You can manually upload an invoice PDF using the button below.
                    <input type="file" id="manualInvoiceUpload" accept=".pdf" style="display: none;" onchange="handleManualInvoiceUpload()">
                    <button onclick="document.getElementById('manualInvoiceUpload').click()" class="modal-btn modal-btn-secondary" style="margin-top: 10px; width: 100%;">
                        üìé Upload PDF Manually
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeInvoiceSearchModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- CSV File Manager Modal -->
    <div id="csvManagerModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 style="margin: 0;">üìÅ Manage CSV Files</h3>
                <button class="modal-close-btn" onclick="closeCSVManager()">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="csvFileList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Populated by JavaScript -->
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 12px; color: #856404;">
                    ‚ö†Ô∏è <strong>Note:</strong> Delete old CSV files here and re-upload them to load ALL transactions including spent items.
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-danger" onclick="deleteAllCSVFiles()" style="margin-right: auto;">Delete All</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeCSVManager()">Close</button>
            </div>
        </div>
    </div>

    <!-- Intelligent Invoice Search Modal -->
    <div id="intelligentSearchModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üîç</span>
                    <span id="searchModalTitle">Finding Invoice...</span>
                </h3>
                <button onclick="closeIntelligentSearchModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Transaction summary -->
                <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div><strong>Date:</strong> <span id="searchTxDate"></span></div>
                        <div><strong>Amount:</strong> <span id="searchTxAmount"></span></div>
                        <div style="grid-column: 1 / -1;"><strong>Description:</strong> <span id="searchTxDesc"></span></div>
                        <div style="grid-column: 1 / -1; display: none;" id="searchTxFromToContainer">
                            <strong>From/To:</strong> <span id="searchTxFromTo"></span>
                        </div>
                        <div style="grid-column: 1 / -1; display: none;" id="searchTxNotesContainer">
                            <strong>User Notes:</strong> <span id="searchTxNotes" style="font-style: italic; color: #6366f1;"></span>
                        </div>
                    </div>
                </div>

                <!-- Search activity log (collapsible) -->
                <div id="searchLogHeader" onclick="toggleSearchLog()"
                     style="background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); color: white; padding: 12px 15px; border-radius: 6px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; transition: all 0.3s; user-select: none;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="searchLogIcon" style="font-size: 12px; transition: transform 0.3s;">‚ñ∂</span>
                        <span style="font-weight: 600; font-size: 14px;">Search Activity Log</span>
                        <span id="searchLogSummary" style="font-size: 12px; opacity: 0.9;">(Click to expand)</span>
                    </div>
                    <span id="searchLogStatus" style="font-size: 20px;">‚è≥</span>
                </div>
                <div id="searchLogContainer"
                     style="display: none; background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 250px; overflow-y: auto; margin-bottom: 15px; transition: all 0.3s;">
                    <!-- Logs will be inserted here -->
                </div>

                <!-- Progress indicator -->
                <div id="searchProgressBar" style="display: none; margin-bottom: 20px;">
                    <div style="background: #e2e8f0; height: 6px; border-radius: 3px; overflow: hidden;">
                        <div id="searchProgressFill" style="background: linear-gradient(90deg, #3b82f6, #8b5cf6); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: #64748b;" id="searchProgressText">Searching...</div>
                </div>

                <!-- Results container -->
                <div id="searchResultsContainer" style="display: none; max-height: 450px; overflow-y: auto; padding-right: 4px;">
                    <!-- Results will be inserted here -->
                </div>

                <!-- Action buttons -->
                <div id="searchActionButtons" style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeIntelligentSearchModal()" class="btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- PDF Preview Modal -->
    <div id="pdfPreviewModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 95vw; max-height: 90vh; width: 1000px;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üìÑ</span>
                    <span id="pdfPreviewTitle">Invoice Preview</span>
                </h3>
                <button onclick="closePDFPreview()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 0; max-height: 80vh; overflow-y: auto;">
                <!-- PDF Viewer -->
                <div id="pdfViewerContainer" style="width: 100%; height: 40vh; background: #f3f4f6; display: flex; align-items: center; justify-content: center;">
                    <iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>
                </div>

                <!-- Validation Results (shown after analysis) -->
                <div id="validationResultsContainer" style="display: none; padding: 15px; background: #ffffff; border-top: 2px solid #e5e7eb; border-bottom: 2px solid #e5e7eb;">
                    <h4 style="margin: 0 0 10px 0; color: #1e293b; display: flex; align-items: center; gap: 6px; font-size: 14px;">
                        <span id="validationIcon" style="font-size: 16px;">üîç</span>
                        <span id="validationTitle">AI Validation Results</span>
                    </h4>

                    <!-- Validation grid -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <!-- Company validation -->
                        <div id="companyValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">COMPANY</div>
                                <div id="companyStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="companyExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="companyFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="companyReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>

                        <!-- Amount validation -->
                        <div id="amountValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">AMOUNT</div>
                                <div id="amountStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="amountExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="amountFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="amountReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>

                        <!-- Date validation -->
                        <div id="dateValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">DATE</div>
                                <div id="dateStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="dateExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="dateFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="dateReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Attachment Buttons -->
                <div style="padding: 15px; background: #f8fafc; border-top: 2px solid #e5e7eb;">
                    <div style="display: flex; gap: 10px;">
                        <button onclick="confirmAttachInvoice()" class="btn-primary" id="attachInvoiceBtn" style="flex: 1; padding: 10px; font-size: 14px; font-weight: 600;">
                            ‚úÖ Attach Invoice
                        </button>
                        <button onclick="closePDFPreview()" class="btn-secondary" style="flex: 1; padding: 10px; font-size: 14px;">
                            ‚ùå Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // API KEY MANAGEMENT (Secure - Not Exposed)
        // ========================================
        // OpenAI API Key is stored in localStorage, not hardcoded
        let API_KEY = localStorage.getItem('openai_api_key');

        // Function to get or prompt for API key
        function getOpenAIKey() {
            if (!API_KEY || API_KEY === '') {
                API_KEY = prompt('Please enter your OpenAI API Key:\n\n(Get one from: https://platform.openai.com/api-keys)\n\nYour key will be stored locally in your browser.');
                if (API_KEY && API_KEY.trim() !== '') {
                    localStorage.setItem('openai_api_key', API_KEY.trim());
                    showToast('‚úÖ OpenAI API Key saved', 'success');
                    return API_KEY.trim();
                } else {
                    return null;
                }
            }
            return API_KEY;
        }

        // Function to update API key
        function updateOpenAIKey() {
            const newKey = prompt('Enter your new OpenAI API Key:', API_KEY || '');
            if (newKey && newKey.trim() !== '') {
                API_KEY = newKey.trim();
                localStorage.setItem('openai_api_key', API_KEY);
                updateAPIKeyStatus();
                showToast('‚úÖ OpenAI API Key updated', 'success');
            }
        }

        // Function to clear API key
        function clearOpenAIKey() {
            if (confirm('Are you sure you want to remove your stored OpenAI API Key?')) {
                localStorage.removeItem('openai_api_key');
                API_KEY = null;
                updateAPIKeyStatus();
                showToast('‚úÖ OpenAI API Key removed', 'success');
            }
        }

        // Update API key status display
        function updateAPIKeyStatus() {
            const statusDiv = document.getElementById('apiKeyStatus');
            if (API_KEY && API_KEY.length > 0) {
                const maskedKey = API_KEY.substring(0, 7) + '...' + API_KEY.substring(API_KEY.length - 4);
                statusDiv.innerHTML = `<span style="color: #059669;">‚úÖ Key configured (${maskedKey})</span>`;
            } else {
                statusDiv.innerHTML = '<span style="color: #dc2626;">‚ùå No key configured</span>';
            }
        }

        // ========================================
        // GMAIL API CONFIGURATION
        // ========================================
        const GOOGLE_CLIENT_ID = '335938881771-o8q7kbrmk4militaeolsamfcreohn094.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyAJGE3KTxDhFXKAkXRj1SIDoSnqGOohPSE';
        const GMAIL_SCOPES = 'https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/userinfo.email';

        // Gmail authentication state
        let tokenClient = null;
        let gmailAccounts = []; // Array of { email, accessToken, selected }
        let gapiInited = false;
        let gisInited = false;

        // Load saved Gmail accounts from localStorage on page load
        function loadGmailAccountsFromStorage() {
            try {
                const stored = localStorage.getItem('gmailAccounts');
                if (stored) {
                    const accounts = JSON.parse(stored);
                    const now = Date.now();
                    let restoredCount = 0;
                    let expiredCount = 0;

                    // Restore accounts and check if tokens are still valid
                    gmailAccounts = accounts.map(acc => {
                        // Check if token is still valid (not expired)
                        if (acc.accessToken && acc.tokenExpiresAt && acc.tokenExpiresAt > now) {
                            restoredCount++;
                            return {
                                email: acc.email,
                                accessToken: acc.accessToken,
                                tokenExpiresAt: acc.tokenExpiresAt,
                                selected: acc.selected
                            };
                        } else {
                            // Token expired or doesn't exist
                            if (acc.tokenExpiresAt) expiredCount++;
                            return {
                                email: acc.email,
                                accessToken: null,
                                tokenExpiresAt: null,
                                selected: acc.selected
                            };
                        }
                    });

                    console.log(`üìß [GMAIL] Restored ${gmailAccounts.length} Gmail account(s) from storage`);
                    console.log(`   ‚úÖ ${restoredCount} with valid tokens`);
                    if (expiredCount > 0) {
                        console.log(`   ‚è∞ ${expiredCount} with expired tokens (need re-authentication)`);
                    }
                }
            } catch (error) {
                console.error('Error loading Gmail accounts from storage:', error);
            }
        }

        // Save Gmail account emails, tokens (with expiry), and selection state to localStorage
        function saveGmailAccountsToStorage() {
            try {
                const accountsToSave = gmailAccounts.map(acc => ({
                    email: acc.email,
                    selected: acc.selected,
                    accessToken: acc.accessToken,         // Save token
                    tokenExpiresAt: acc.tokenExpiresAt    // Save expiry timestamp
                }));
                localStorage.setItem('gmailAccounts', JSON.stringify(accountsToSave));
                console.log('üíæ Saved Gmail accounts to storage (with tokens)');
            } catch (error) {
                console.error('Error saving Gmail accounts to storage:', error);
            }
        }

        // PDF.js configuration
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc =
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        let allTransactions = [];
        let currentEditingIndex = null;
        let selectedCategory = null; // Currently selected category for assignment
        let currentAssignments = []; // For split allocations: [{projectId, category, itemKey, itemName, percentage, quarter}]
        let remainingAllocation = 100; // Percentage remaining to allocate

        // Multi-step assignment state
        let assignmentStep = 1; // 1=Project, 2=Category, 3=Item
        let selectedProject = null;
        let selectedCategoryName = null;

        // Keyboard navigation state
        let selectedRowIndex = null;
        let keyboardBuffer = '';
        let keyboardBufferTimeout = null;
        let modalKeyboardIndex = -1;

        // Table display settings
        let showSpentColumn = true; // Show spent column by default
        let showReceivedColumn = false; // Hide received column by default

        // Load settings from localStorage
        function loadDisplaySettings() {
            const savedSettings = localStorage.getItem('spendTableSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    showSpentColumn = settings.showSpentColumn ?? true;
                    showReceivedColumn = settings.showReceivedColumn ?? false;
                    console.log('üìã [SETTINGS] Loaded saved settings from localStorage:', settings);
                } catch (e) {
                    console.error('‚ùå [SETTINGS] Failed to load settings:', e);
                }
            } else {
                console.log('üìã [SETTINGS] No saved settings found, using defaults');
            }

            console.log(`üìã [SETTINGS] Active column settings: showSpentColumn=${showSpentColumn}, showReceivedColumn=${showReceivedColumn}`);

            // Sync checkbox states with loaded settings
            syncCheckboxStates();

            applyColumnVisibility();
        }

        // Sync checkbox states with current settings (called on load and when needed)
        function syncCheckboxStates() {
            const spentColToggle = document.getElementById('showSpentColumnToggle');
            const receivedColToggle = document.getElementById('showReceivedColumnToggle');

            if (spentColToggle) spentColToggle.checked = showSpentColumn;
            if (receivedColToggle) receivedColToggle.checked = showReceivedColumn;

            console.log('üîÑ [SETTINGS] Synced checkbox states with settings');
        }

        // Helper function to reset table settings to default (only called from console if needed)
        window.resetTableSettings = function() {
            console.log('üîÑ [SETTINGS] Resetting table settings to default...');
            localStorage.removeItem('spendTableSettings');
            showSpentColumn = true;
            showReceivedColumn = false;
            document.getElementById('showSpentColumnToggle').checked = true;
            document.getElementById('showReceivedColumnToggle').checked = false;
            saveDisplaySettings();
            applyColumnVisibility();
            console.log('‚úÖ [SETTINGS] Reset complete! Spent column visible, Received column hidden.');
            showToast('‚úÖ Settings reset to defaults', 'success');
        }

        // Save settings to localStorage
        function saveDisplaySettings() {
            const settings = {
                showSpentColumn,
                showReceivedColumn
            };
            localStorage.setItem('spendTableSettings', JSON.stringify(settings));
            console.log('üíæ [SETTINGS] Saved display settings:', settings);
        }

        // Apply column visibility based on settings
        function applyColumnVisibility() {
            const headers = document.querySelectorAll('th');
            const spentCells = document.querySelectorAll('.amount-spent');
            const receivedCells = document.querySelectorAll('.amount-received');

            // Find and toggle the "Spent" and "Spent (Ex. VAT)" column headers
            headers.forEach(header => {
                const headerText = header.textContent.trim();
                if (headerText === 'SPENT' || headerText === 'SPENT (EX. VAT)') {
                    header.style.display = showSpentColumn ? '' : 'none';
                } else if (headerText === 'RECEIVED') {
                    header.style.display = showReceivedColumn ? '' : 'none';
                }
            });

            // Toggle all spent column cells
            spentCells.forEach(cell => {
                cell.style.display = showSpentColumn ? '' : 'none';
            });

            // Toggle all received column cells
            receivedCells.forEach(cell => {
                cell.style.display = showReceivedColumn ? '' : 'none';
            });
        }

        // Toggle table settings menu visibility
        function toggleTableSettings() {
            const menu = document.getElementById('tableSettingsMenu');
            const isVisible = menu.style.display !== 'none';

            if (isVisible) {
                menu.style.display = 'none';
            } else {
                // Update checkbox states to match current settings
                document.getElementById('showSpentColumnToggle').checked = showSpentColumn;
                document.getElementById('showReceivedColumnToggle').checked = showReceivedColumn;

                menu.style.display = 'block';
            }
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('tableSettingsMenu');
            const btn = document.getElementById('tableSettingsBtn');

            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // Toggle spent column visibility
        function toggleSpentColumn() {
            showSpentColumn = document.getElementById('showSpentColumnToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle spent column:', showSpentColumn);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();
            applyColumnVisibility();

            const message = showSpentColumn ?
                '‚úÖ Showing spent column' :
                'üîí Hiding spent column';
            showToast(message, 'success', toastPosition);
        }

        // Toggle received column visibility
        function toggleReceivedColumn() {
            showReceivedColumn = document.getElementById('showReceivedColumnToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle received column:', showReceivedColumn);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();
            applyColumnVisibility();

            const message = showReceivedColumn ?
                '‚úÖ Showing received column' :
                'üîí Hiding received column';
            showToast(message, 'success', toastPosition);
        }

        // ========================================
        // QUARTER CALCULATION HELPERS
        // ========================================

        /**
         * Calculate which quarter a transaction falls into based on project start date
         * @param {string} transactionDate - Date string from transaction (e.g., "15/03/2024")
         * @param {object} project - Project object with projectStartMonth, projectStartYear, projectDurationMonths
         * @returns {number} Quarter number (1-4) or null if cannot calculate
         */
        function calculateTransactionQuarter(transactionDate, project) {
            console.log('üìÖ [QUARTER CALC] Calculating quarter for transaction:', transactionDate);
            console.log('üìÖ [QUARTER CALC] Project structure:', {
                name: project.projectName,
                hasFinanceSummary: !!project.financeSummary,
                topLevelStartMonth: project.projectStartMonth,
                topLevelStartYear: project.projectStartYear,
                nestedStartMonth: project.financeSummary?.projectStartMonth,
                nestedStartYear: project.financeSummary?.projectStartYear
            });

            // Check for start dates in both locations (for backward compatibility)
            const startMonth = project.projectStartMonth || project.financeSummary?.projectStartMonth;
            const startYear = project.projectStartYear || project.financeSummary?.projectStartYear;

            if (!startMonth || !startYear) {
                console.error(`‚ö†Ô∏è [QUARTER CALC] Project "${project.projectName}" is missing start date!`, {
                    projectName: project.projectName,
                    projectId: project.projectId,
                    startMonth,
                    startYear,
                    hasFinanceSummary: !!project.financeSummary
                });
                console.error(`‚ùå [QUARTER CALC] Solution: Open grants.html ‚Üí Load project "${project.projectName}" ‚Üí Set "Project Start Date" in the Finance Summary section`);

                // Show user-friendly toast notification
                alert(`‚ö†Ô∏è Project Start Date Missing\n\nProject "${project.projectName}" doesn't have a start date set.\n\nTo assign transactions to quarters:\n1. Open grants.html\n2. Load project "${project.projectName}"\n3. Set the "Project Start Date" in the Finance Summary section\n4. Save the project\n5. Return to spend.html and refresh`);

                return null;
            }

            // Parse transaction date (handle DD/MM/YYYY, DD/MM/YY, etc.)
            const dateParts = transactionDate.split('/');
            if (dateParts.length !== 3) {
                console.warn('‚ö†Ô∏è [QUARTER CALC] Invalid date format:', transactionDate);
                return null;
            }

            const transDay = parseInt(dateParts[0]);
            const transMonth = parseInt(dateParts[1]);
            let transYear = parseInt(dateParts[2]);

            // Handle 2-digit years
            if (transYear < 100) {
                transYear += 2000;
            }

            console.log(`üìÖ [QUARTER CALC] Parsed transaction date: ${transDay}/${transMonth}/${transYear}`);

            // Calculate project start date
            const projectStart = new Date(startYear, startMonth - 1, 1);
            const transactionDateObj = new Date(transYear, transMonth - 1, transDay);

            console.log(`üìÖ [QUARTER CALC] Project start: ${projectStart.toISOString()}`);
            console.log(`üìÖ [QUARTER CALC] Transaction: ${transactionDateObj.toISOString()}`);

            // Calculate months since project start
            const monthsSinceStart = (transYear - startYear) * 12 + (transMonth - startMonth);

            console.log(`üìÖ [QUARTER CALC] Months since project start: ${monthsSinceStart}`);

            // Determine quarter (1-4)
            if (monthsSinceStart < 0) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const projectStartDisplay = `${monthNames[startMonth - 1]} ${startYear}`;
                const transactionDisplay = `${transDay}/${transMonth}/${transYear}`;

                console.warn(`‚ö†Ô∏è [QUARTER CALC] Transaction date (${transactionDisplay}) is before project start (${projectStartDisplay})!`);

                alert(`‚ö†Ô∏è Transaction Date Issue\n\nTransaction date: ${transactionDisplay}\nProject "${project.projectName}" starts: ${projectStartDisplay}\n\nThis transaction is ${Math.abs(monthsSinceStart)} month(s) before the project start date.\n\nTo fix this:\n1. Open grants.html\n2. Load project "${project.projectName}"\n3. Adjust the "Project Start Date" in Finance Summary\n4. Save and return to spend.html\n\nOR assign this transaction to a different project.`);

                return null;
            }

            if (monthsSinceStart >= 0 && monthsSinceStart < 3) return 1;
            if (monthsSinceStart >= 3 && monthsSinceStart < 6) return 2;
            if (monthsSinceStart >= 6 && monthsSinceStart < 9) return 3;
            if (monthsSinceStart >= 9 && monthsSinceStart < 12) return 4;

            console.warn('‚ö†Ô∏è [QUARTER CALC] Transaction beyond 12 months, defaulting to Q4');
            return 4; // Default to Q4 if beyond 12 months
        }

        /**
         * Get quarter name for display
         */
        function getQuarterName(quarter) {
            return quarter ? `Q${quarter}` : 'Unknown';
        }

        // Voice recording variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        const MAX_RECORDING_TIME = 30000; // 30 seconds
        let recordingTimeout;
        let currentRecordingRowIndex = null; // Track which row is being recorded
        let microphoneStream = null; // Keep stream alive to avoid repeated permission requests

        // IndexedDB variables
        let db;
        const DB_NAME = 'PEBLGrantsBudgets';
        const DB_VERSION = 6; // Updated to match grants.html
        const STORE_NAME = 'projects';
        const CSV_STORE_NAME = 'csvFiles';
        const INVOICES_STORE_NAME = 'invoices';
        let allProjects = [];
        let currentProject = null; // Currently selected project
        let savedCSVFiles = []; // List of saved CSV files

        // Invoice search variables
        let currentInvoiceSearchIndex = null;

        // IndexedDB initialization
        async function initIndexedDB() {
            console.log(`üîÑ [INDEXEDDB] Initializing database: ${DB_NAME}, version: ${DB_VERSION}`);

            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('‚ùå [INDEXEDDB] Error opening database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    console.log(`‚úÖ [INDEXEDDB] Database opened successfully (version ${db.version})`);
                    console.log(`üìã [INDEXEDDB] Available object stores:`, Array.from(db.objectStoreNames));
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    console.log(`üîß [INDEXEDDB] Upgrading database from version ${event.oldVersion} to ${event.newVersion}`);
                    db = event.target.result;

                    // Create projects object store if it doesn't exist
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating projects object store: ${STORE_NAME}`);
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'projectId', autoIncrement: true });
                        objectStore.createIndex('projectName', 'projectName', { unique: false });
                        objectStore.createIndex('projectNumber', 'projectNumber', { unique: false });
                        objectStore.createIndex('lastModified', 'lastModified', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created projects object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] Projects object store already exists`);
                    }

                    // Create CSV files object store if it doesn't exist
                    if (!db.objectStoreNames.contains(CSV_STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating CSV files object store: ${CSV_STORE_NAME}`);
                        const csvStore = db.createObjectStore(CSV_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        csvStore.createIndex('fileName', 'fileName', { unique: false });
                        csvStore.createIndex('uploadDate', 'uploadDate', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created CSV files object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] CSV files object store already exists`);
                    }

                    // Create invoices object store if it doesn't exist
                    if (!db.objectStoreNames.contains(INVOICES_STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating invoices object store: ${INVOICES_STORE_NAME}`);
                        const invoiceStore = db.createObjectStore(INVOICES_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        invoiceStore.createIndex('transactionIndex', 'transactionIndex', { unique: false });
                        invoiceStore.createIndex('filename', 'filename', { unique: false });
                        invoiceStore.createIndex('uploadDate', 'uploadDate', { unique: false });
                        invoiceStore.createIndex('messageId', 'gmailMessageId', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created invoices object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] Invoices object store already exists`);
                    }
                };
            });
        }

        async function loadProjectsFromDB() {
            console.log('üîÑ [BUDGET LOAD] Starting loadProjectsFromDB...');

            if (!db) {
                console.log('üîÑ [BUDGET LOAD] Database not initialized, initializing...');
                await initIndexedDB();
            }

            try {
                console.log('üîÑ [BUDGET LOAD] Opening transaction to projects store...');
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    allProjects = request.result || [];
                    console.log('‚úÖ [BUDGET LOAD] Successfully loaded projects from DB');
                    console.log(`üìä [BUDGET LOAD] Number of projects: ${allProjects.length}`);

                    if (allProjects.length > 0) {
                        console.log('üìã [BUDGET LOAD] Project details:');
                        allProjects.forEach((project, index) => {
                            console.log(`   Project ${index + 1}:`, {
                                projectId: project.projectId,
                                projectName: project.projectName,
                                projectNumber: project.projectNumber,
                                fundingBody: project.fundingBody,
                                hasLabour: !!project.labour,
                                hasOverheads: !!project.overheads,
                                hasMaterials: !!project.materials,
                                hasCapitalUsage: !!project.capitalUsage,
                                hasSubcontracting: !!project.subcontracting,
                                hasTravel: !!project.travel,
                                hasOtherCosts: !!project.otherCosts,
                                hasWelshGovData: !!project.welshGovData,
                                hasFinanceSummary: !!project.financeSummary,
                                lastModified: project.lastModified
                            });

                            // Log finance summary details
                            if (project.financeSummary) {
                                console.log(`      Finance Summary (FULL):`, project.financeSummary);
                                console.log(`      Finance Summary (Parsed):`, {
                                    startMonth: project.financeSummary.projectStartMonth,
                                    startYear: project.financeSummary.projectStartYear,
                                    duration: project.financeSummary.projectDurationMonths,
                                    durationString: project.financeSummary.projectDuration,
                                    totalCosts: project.financeSummary.totalCosts
                                });
                            }

                            // Log category details
                            if (project.labour) {
                                console.log(`      Labour: ${project.labour.staff?.length || 0} staff, total ¬£${project.labour.totalCost || 0}`);
                            }
                            if (project.overheads) {
                                console.log(`      Overheads: total ¬£${project.overheads.totalCost || 0}`);
                            }
                            if (project.materials) {
                                console.log(`      Materials: ${project.materials.items?.length || 0} items, total ¬£${project.materials.totalCost || 0}`);
                            }
                            if (project.capitalUsage) {
                                console.log(`      Capital Usage: ${project.capitalUsage.items?.length || 0} items, total ¬£${project.capitalUsage.totalCost || 0}`);
                            }
                            if (project.subcontracting) {
                                console.log(`      Subcontracting: ${project.subcontracting.contractors?.length || 0} contractors, total ¬£${project.subcontracting.totalCost || 0}`);
                            }
                            if (project.travel) {
                                console.log(`      Travel: ${project.travel.trips?.length || 0} trips, total ¬£${project.travel.totalCost || 0}`);
                            }
                            if (project.otherCosts) {
                                console.log(`      Other Costs: ${project.otherCosts.items?.length || 0} items, total ¬£${project.otherCosts.totalCost || 0}`);
                            }

                            // Special logging for Welsh Gov projects
                            if (project.welshGovData) {
                                console.log(`      ‚ö†Ô∏è WELSH GOV DATA DETECTED - This project uses welshGovData structure`);
                                console.log(`      Welsh Gov Sections:`, Object.keys(project.welshGovData.sections || {}));
                            }

                            // If no categories detected, log full project structure for debugging
                            if (!project.labour && !project.materials && !project.capitalUsage &&
                                !project.subcontracting && !project.travel && !project.otherCosts && !project.welshGovData) {
                                console.warn(`      ‚ö†Ô∏è NO CATEGORIES DETECTED - Full project structure:`, project);
                            }
                        });
                    } else {
                        console.log('‚ö†Ô∏è [BUDGET LOAD] No projects found in database');
                    }

                    console.log('üîÑ [BUDGET LOAD] Calling updateBudgetInfo()...');
                    updateBudgetInfo();
                };

                request.onerror = () => {
                    console.error('‚ùå [BUDGET LOAD] Failed to load projects:', request.error);
                    document.getElementById('loadedBudgetsInfo').innerHTML =
                        '‚ùå Failed to load projects from database.';
                };
            } catch (error) {
                console.error('‚ùå [BUDGET LOAD] Error loading projects:', error);
                document.getElementById('loadedBudgetsInfo').innerHTML =
                    '‚ùå Error accessing database.';
            }
        }

        // Auto-load and activate ALL projects (no selection needed)
        let activeProjects = [];

        async function loadSavedCSVFiles() {
            console.log('üìÇ [LOAD CSV FILES] Starting loadSavedCSVFiles...');
            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    savedCSVFiles = request.result || [];
                    console.log('‚úÖ [LOAD CSV FILES] Loaded saved CSV files from IndexedDB:', savedCSVFiles.length, 'files');

                    savedCSVFiles.forEach((file, idx) => {
                        console.log(`üìÑ [LOAD CSV FILES] File ${idx + 1}:`, {
                            id: file.id,
                            fileName: file.fileName,
                            bank: file.bank,
                            transactionCount: file.transactionCount,
                            uploadDate: file.uploadDate,
                            hasTransactions: !!file.transactions,
                            firstTransaction: file.transactions?.[0]
                        });
                    });

                    // Update CSV summary to show saved files
                    updateCSVSummary();

                    // Auto-load all saved CSV files
                    if (savedCSVFiles.length > 0) {
                        console.log('üîÑ [LOAD CSV FILES] Triggering autoLoadSavedCSVs...');
                        autoLoadSavedCSVs();
                    } else {
                        console.log('‚ÑπÔ∏è [LOAD CSV FILES] No saved CSV files found');
                    }
                };

                request.onerror = () => {
                    console.error('‚ùå [LOAD CSV FILES] Failed to load CSV files:', request.error);
                };
            } catch (error) {
                console.error('‚ùå [LOAD CSV FILES] Error loading CSV files:', error);
            }
        }

        // Auto-load all saved CSV files from IndexedDB
        let isAutoLoadingCSVs = false; // Flag to prevent multiple simultaneous loads
        async function autoLoadSavedCSVs() {
            // Prevent multiple simultaneous loads
            if (isAutoLoadingCSVs) {
                console.warn('‚ö†Ô∏è [AUTO-LOAD CSV] Already loading CSVs, skipping duplicate call');
                return;
            }

            isAutoLoadingCSVs = true;
            console.log('üîÑ [AUTO-LOAD CSV] Starting autoLoadSavedCSVs...');
            console.log(`üìÇ [AUTO-LOAD CSV] savedCSVFiles.length: ${savedCSVFiles.length}`);
            console.log(`üìä [AUTO-LOAD CSV] allTransactions.length BEFORE clear: ${allTransactions.length}`);

            // Clear existing transactions before loading (prevent duplicates on multiple calls)
            allTransactions = [];
            console.log(`üßπ [AUTO-LOAD CSV] Cleared allTransactions array`);

            let totalLoaded = 0;

            for (const csvFile of savedCSVFiles) {
                console.log(`üìÑ [AUTO-LOAD CSV] Processing CSV file:`, {
                    fileName: csvFile.fileName,
                    bank: csvFile.bank,
                    transactionCount: csvFile.transactionCount,
                    actualTransactionsLength: csvFile.transactions?.length,
                    uploadDate: csvFile.uploadDate
                });

                // Merge transactions from all saved CSV files
                const transactions = csvFile.transactions || [];
                console.log(`üí≥ [AUTO-LOAD CSV] Actual transactions array length: ${transactions.length}`);
                console.log(`üí≥ [AUTO-LOAD CSV] Stored transactionCount: ${csvFile.transactionCount}`);
                console.log(`‚ö†Ô∏è [AUTO-LOAD CSV] MISMATCH DETECTED: ${transactions.length} vs ${csvFile.transactionCount}` + (transactions.length !== csvFile.transactionCount ? ' ‚ùå' : ' ‚úÖ'));
                console.log(`üí≥ [AUTO-LOAD CSV] First transaction in this file:`, transactions[0]);
                console.log(`üí≥ [AUTO-LOAD CSV] Last transaction in this file:`, transactions[transactions.length - 1]);
                console.log(`üí≥ [AUTO-LOAD CSV] Transaction sample:`, transactions.slice(0, 3));

                allTransactions = allTransactions.concat(transactions);
                totalLoaded += transactions.length;
            }

            console.log(`‚úÖ [AUTO-LOAD CSV] Total loaded: ${totalLoaded} transactions`);
            console.log(`üìä [AUTO-LOAD CSV] allTransactions.length: ${allTransactions.length}`);
            console.log(`üîç [AUTO-LOAD CSV] First 3 transactions in allTransactions:`, allTransactions.slice(0, 3));

            // Log spent vs received breakdown
            const spentCount = allTransactions.filter(t => t.spent && t.spent.trim()).length;
            const receivedCount = allTransactions.filter(t => t.received && t.received.trim()).length;
            console.log(`üí∞ [AUTO-LOAD CSV] Breakdown: ${spentCount} spent, ${receivedCount} received`);

            if (totalLoaded > 0) {
                renderTransactions();
                updateSummary();

                // Show helpful message about what's being displayed
                const displayedCount = document.getElementById('tableBody').querySelectorAll('tr:not(.empty-state)').length;

                console.log(`üìä [AUTO-LOAD CSV] Display: ${displayedCount} visible of ${totalLoaded} loaded`);

                if (spentCount > 0) {
                    showToast(`‚úÖ Loaded ${spentCount} spent transaction${spentCount !== 1 ? 's' : ''} for budget allocation`, 'success');
                } else if (receivedCount > 0) {
                    showToast(`‚ö†Ô∏è Loaded ${receivedCount} received transaction${receivedCount !== 1 ? 's' : ''} (no spent transactions found)`, 'info');
                } else {
                    showToast(`‚úÖ Loaded ${totalLoaded} transaction${totalLoaded !== 1 ? 's' : ''}`, 'success');
                }
            } else {
                console.log('‚ÑπÔ∏è [AUTO-LOAD CSV] No transactions to load');
            }

            isAutoLoadingCSVs = false;
            console.log('‚úÖ [AUTO-LOAD CSV] Auto-load complete, flag reset');
        }

        async function saveCSVFileToDB(fileName, transactions, bankIdentifier) {
            if (!db) {
                await initIndexedDB();
            }

            try {
                // Check if file with same name already exists
                const existing = savedCSVFiles.find(f => f.fileName === fileName);
                if (existing) {
                    console.log('CSV file already saved:', fileName);
                    return existing.id;
                }

                const csvFileData = {
                    fileName: fileName,
                    uploadDate: new Date().toISOString(),
                    transactions: transactions,
                    transactionCount: transactions.length,
                    bank: bankIdentifier
                };

                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.add(csvFileData);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        console.log('CSV file saved with ID:', request.result);
                        loadSavedCSVFiles(); // Refresh the list
                        resolve(request.result);
                    };

                    request.onerror = () => {
                        console.error('Failed to save CSV file:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('Error saving CSV file:', error);
                return null;
            }
        }

        async function loadCSVFromDB(csvId) {
            if (!csvId) {
                // If no CSV selected, clear the transactions
                allTransactions = [];
                renderTransactions();
                updateSummary();
                document.getElementById('loadedFiles').innerHTML = '';
                return;
            }

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.get(parseInt(csvId));

                request.onsuccess = () => {
                    if (request.result) {
                        const csvData = request.result;
                        allTransactions = csvData.transactions;
                        renderTransactions();
                        updateSummary();

                        // Update loaded files display
                        const uploadDate = new Date(csvData.uploadDate).toLocaleString();
                        document.getElementById('loadedFiles').innerHTML =
                            `<p style="margin-top: 10px; color: #666;">
                                Currently loaded: <strong>${csvData.fileName}</strong>
                                (${csvData.transactionCount} transactions, uploaded ${uploadDate})
                            </p>`;

                        console.log('Loaded CSV from database:', csvData.fileName);
                    }
                };

                request.onerror = () => {
                    console.error('Failed to load CSV from database:', request.error);
                    alert('Failed to load CSV file from database.');
                };
            } catch (error) {
                console.error('Error loading CSV from database:', error);
            }
        }

        async function deleteCSVFromDB(csvId) {
            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.delete(parseInt(csvId));

                request.onsuccess = () => {
                    console.log('CSV file deleted:', csvId);
                    loadSavedCSVFiles(); // Refresh the list
                    showToast('‚úÖ CSV file deleted successfully!', 'success');
                };

                request.onerror = () => {
                    console.error('Failed to delete CSV file:', request.error);
                    showToast('‚ùå Failed to delete CSV file', 'error');
                };
            } catch (error) {
                console.error('Error deleting CSV file:', error);
            }
        }

        function openCSVManager() {
            console.log('üìÇ [CSV MANAGER] Opening CSV manager...');
            const modal = document.getElementById('csvManagerModal');
            const listDiv = document.getElementById('csvFileList');

            if (savedCSVFiles.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No CSV files saved</p>';
            } else {
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                savedCSVFiles.forEach(file => {
                    const uploadDate = new Date(file.uploadDate).toLocaleString();
                    const bankIcon = file.bank === 'R' ? 'üü£' : file.bank === 'M' ? 'üîµ' : '‚ö™';
                    html += `
                        <div style="display: flex; align-items: center; padding: 10px; background: #f8f9fa; border-radius: 5px; gap: 10px;">
                            <span style="font-size: 20px;">${bankIcon}</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 13px;">${file.fileName}</div>
                                <div style="font-size: 11px; color: #666;">
                                    ${file.transactionCount} transactions ‚Ä¢ Uploaded ${uploadDate}
                                </div>
                            </div>
                            <button onclick="deleteCSVFile(${file.id})"
                                    style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">
                                Delete
                            </button>
                        </div>
                    `;
                });
                html += '</div>';
                listDiv.innerHTML = html;
            }

            modal.style.display = 'flex';
        }

        function closeCSVManager() {
            document.getElementById('csvManagerModal').style.display = 'none';
        }

        async function deleteCSVFile(fileId) {
            if (!confirm('Delete this CSV file? You can re-upload it later.')) {
                return;
            }

            console.log(`üóëÔ∏è [CSV MANAGER] Deleting file ID: ${fileId}`);
            await deleteCSVFromDB(fileId);

            // Reload the page data
            allTransactions = [];
            await loadSavedCSVFiles();
            renderTransactions();
            updateSummary();

            // Refresh the manager view
            openCSVManager();
            showToast('‚úÖ CSV file deleted', 'success');
        }

        async function deleteAllCSVFiles() {
            if (!confirm('‚ö†Ô∏è Delete ALL CSV files? This cannot be undone.\n\nYou will need to re-upload your CSV files.')) {
                return;
            }

            console.log('üóëÔ∏è [CSV MANAGER] Deleting all CSV files...');

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.clear();

                request.onsuccess = async () => {
                    console.log('‚úÖ [CSV MANAGER] All CSV files deleted');
                    allTransactions = [];
                    savedCSVFiles = [];
                    await loadSavedCSVFiles();
                    renderTransactions();
                    updateSummary();
                    updateCSVSummary();
                    closeCSVManager();
                    showToast('‚úÖ All CSV files deleted', 'success');
                };

                request.onerror = () => {
                    console.error('‚ùå [CSV MANAGER] Failed to delete all files:', request.error);
                    showToast('‚ùå Failed to delete files', 'error');
                };
            } catch (error) {
                console.error('‚ùå [CSV MANAGER] Error:', error);
                showToast('‚ùå Error deleting files', 'error');
            }
        }

        function updateCSVSummary() {
            const contentDiv = document.getElementById('csvSummaryContent');

            // Show saved CSV files from IndexedDB (compact format)
            if (savedCSVFiles.length > 0) {
                const totalTrans = savedCSVFiles.reduce((sum, f) => sum + f.transactionCount, 0);
                contentDiv.innerHTML = `${savedCSVFiles.length} file${savedCSVFiles.length > 1 ? 's' : ''} (${totalTrans} trans.)`;
                return;
            }

            // If no saved files, show current loaded data summary
            if (allTransactions.length === 0) {
                contentDiv.innerHTML = 'No files loaded ‚Ä¢ Drop CSV files here';
                return;
            }

            // Group transactions by bank (compact format)
            const revolutTransactions = allTransactions.filter(t => t.bank === 'R');
            const metroTransactions = allTransactions.filter(t => t.bank === 'M');

            let summary = [];
            if (revolutTransactions.length > 0) summary.push(`R: ${revolutTransactions.length}`);
            if (metroTransactions.length > 0) summary.push(`M: ${metroTransactions.length}`);

            contentDiv.innerHTML = summary.length > 0 ? summary.join(', ') + ' trans.' : `${allTransactions.length} trans.`;
        }

        function clearAllTransactions(event) {
            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            if (confirm('Are you sure you want to clear all loaded transactions? This will not delete saved CSV files from the database.')) {
                allTransactions = [];
                renderTransactions();
                updateSummary();
                updateCSVSummary();
                document.getElementById('loadedFiles').innerHTML = '';
                showToast('‚úÖ All transactions cleared from view', 'success', toastPosition);
            }
        }

        /**
         * Fix duplicate transactions in IndexedDB
         */
        async function fixDuplicates(event) {
            console.log('üîß [FIX DUPLICATES] User clicked Fix DB button');

            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            // Show confirmation dialog
            const confirmed = confirm(
                '‚ö†Ô∏è Fix Database - Remove Duplicate Transactions\n\n' +
                'This will scan all saved CSV files and remove EXACT duplicate transactions.\n\n' +
                'A duplicate is identified when ALL of these match:\n' +
                '  ‚Ä¢ Date\n' +
                '  ‚Ä¢ Description\n' +
                '  ‚Ä¢ Spent amount\n' +
                '  ‚Ä¢ Received amount\n' +
                '  ‚Ä¢ From/To\n\n' +
                'Only exact duplicates will be removed. Your unique transactions will be preserved.\n\n' +
                'Do you want to continue?'
            );

            if (!confirmed) {
                console.log('üîß [FIX DUPLICATES] User cancelled operation');
                return;
            }

            console.log('üîß [FIX DUPLICATES] Starting duplicate fix...');

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const getAllRequest = objectStore.getAll();

                getAllRequest.onsuccess = async () => {
                    const allCSVFiles = getAllRequest.result || [];
                    console.log(`üìÇ [FIX DUPLICATES] Found ${allCSVFiles.length} CSV files`);

                    let totalBefore = 0;
                    let totalAfter = 0;
                    let totalSpentBefore = 0;
                    let totalReceivedBefore = 0;
                    let totalSpentAfter = 0;
                    let totalReceivedAfter = 0;

                    for (const csvFile of allCSVFiles) {
                        const before = csvFile.transactions?.length || 0;
                        totalBefore += before;

                        console.log(`üìÑ [FIX DUPLICATES] Processing: ${csvFile.fileName} (${before} transactions)`);

                        // Count before deduplication
                        const spentBeforeCount = csvFile.transactions.filter(t => t.spent && t.spent.trim()).length;
                        const receivedBeforeCount = csvFile.transactions.filter(t => t.received && t.received.trim()).length;
                        totalSpentBefore += spentBeforeCount;
                        totalReceivedBefore += receivedBeforeCount;

                        console.log(`   üìä BEFORE: ${spentBeforeCount} spent, ${receivedBeforeCount} received`);
                        console.log(`   üîç Sample transactions BEFORE:`, csvFile.transactions.slice(0, 3));

                        // Deduplicate transactions using date + description + amount as unique key
                        const uniqueTransactions = [];
                        const seen = new Set();
                        let duplicatesRemoved = 0;

                        for (const trans of csvFile.transactions || []) {
                            // Create unique key using ALL important fields to identify EXACT duplicates only
                            const key = `${trans.date}|${trans.description}|${trans.spent}|${trans.received}|${trans.fromTo}`;

                            if (!seen.has(key)) {
                                seen.add(key);
                                uniqueTransactions.push(trans);
                            } else {
                                duplicatesRemoved++;
                                console.log(`   üóëÔ∏è Removing EXACT duplicate:`, {
                                    date: trans.date,
                                    description: trans.description.substring(0, 30) + '...',
                                    spent: trans.spent,
                                    received: trans.received,
                                    fromTo: trans.fromTo,
                                    uniqueKey: key
                                });
                            }
                        }

                        console.log(`   ‚ÑπÔ∏è [FIX DUPLICATES] Deduplication complete for ${csvFile.fileName}`);
                        console.log(`   üìä Unique transactions found: ${uniqueTransactions.length}`);
                        console.log(`   üóëÔ∏è Exact duplicates removed: ${duplicatesRemoved}`);

                        const after = uniqueTransactions.length;
                        totalAfter += after;
                        const removed = before - after;

                        // Log spent vs received breakdown after deduplication
                        const spentCount = uniqueTransactions.filter(t => t.spent && t.spent.trim()).length;
                        const receivedCount = uniqueTransactions.filter(t => t.received && t.received.trim()).length;
                        totalSpentAfter += spentCount;
                        totalReceivedAfter += receivedCount;

                        console.log(`‚úÖ [FIX DUPLICATES] ${csvFile.fileName}: ${before} ‚Üí ${after} (removed ${removed} duplicates)`);
                        console.log(`   üìä BEFORE: ${spentBeforeCount} spent, ${receivedBeforeCount} received`);
                        console.log(`   üìä AFTER:  ${spentCount} spent, ${receivedCount} received`);
                        console.log(`   üîç Sample transactions AFTER:`, uniqueTransactions.slice(0, 3));

                        // Safety check: Verify no data type was completely wiped out
                        if (spentBeforeCount > 0 && spentCount === 0) {
                            console.error(`   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING: All ${spentBeforeCount} SPENT transactions were removed! Skipping save for this file.`);
                            continue; // Skip saving this file
                        }
                        if (receivedBeforeCount > 0 && receivedCount === 0) {
                            console.error(`   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING: All ${receivedBeforeCount} RECEIVED transactions were removed! Skipping save for this file.`);
                            continue; // Skip saving this file
                        }

                        // Update the CSV file with deduplicated transactions
                        csvFile.transactions = uniqueTransactions;
                        csvFile.transactionCount = after;

                        // Save back to IndexedDB
                        const updateTransaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                        const updateStore = updateTransaction.objectStore(CSV_STORE_NAME);
                        await new Promise((resolve, reject) => {
                            const updateRequest = updateStore.put(csvFile);
                            updateRequest.onsuccess = () => resolve();
                            updateRequest.onerror = () => reject(updateRequest.error);
                        });
                    }

                    console.log(`\nüéâ [FIX DUPLICATES] === SUMMARY ===`);
                    console.log(`üìä [FIX DUPLICATES] Total transactions: ${totalBefore} ‚Üí ${totalAfter} (removed ${totalBefore - totalAfter} exact duplicates)`);
                    console.log(`üí≥ [FIX DUPLICATES] SPENT transactions: ${totalSpentBefore} ‚Üí ${totalSpentAfter} (${totalSpentBefore - totalSpentAfter} removed)`);
                    console.log(`üí∞ [FIX DUPLICATES] RECEIVED transactions: ${totalReceivedBefore} ‚Üí ${totalReceivedAfter} (${totalReceivedBefore - totalReceivedAfter} removed)`);

                    // Verify data integrity
                    const spentLoss = totalSpentBefore > 0 ? ((totalSpentBefore - totalSpentAfter) / totalSpentBefore * 100).toFixed(1) : 0;
                    const receivedLoss = totalReceivedBefore > 0 ? ((totalReceivedBefore - totalReceivedAfter) / totalReceivedBefore * 100).toFixed(1) : 0;

                    console.log(`üìà [FIX DUPLICATES] SPENT loss: ${spentLoss}% | RECEIVED loss: ${receivedLoss}%`);

                    if (totalSpentBefore > 0 && totalSpentAfter === 0) {
                        console.error(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [FIX DUPLICATES] CRITICAL ERROR: ALL SPENT TRANSACTIONS WERE REMOVED! This is likely a bug!`);
                        alert('‚ö†Ô∏è ERROR: All spent transactions were removed during deduplication. The operation was aborted to prevent data loss. Please check the console for details.');
                        return;
                    }

                    if (totalReceivedBefore > 0 && totalReceivedAfter === 0) {
                        console.error(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [FIX DUPLICATES] CRITICAL ERROR: ALL RECEIVED transactions were removed! This is likely a bug!`);
                        alert('‚ö†Ô∏è ERROR: All received transactions were removed during deduplication. The operation was aborted to prevent data loss. Please check the console for details.');
                        return;
                    }

                    const message = `‚úÖ Fixed! Removed ${totalBefore - totalAfter} exact duplicate transactions.\nSpent: ${totalSpentBefore} ‚Üí ${totalSpentAfter} | Received: ${totalReceivedBefore} ‚Üí ${totalReceivedAfter}`;
                    showToast(message, 'success', toastPosition);

                    // Reload the page to show clean data
                    setTimeout(() => location.reload(), 1500);
                };

                getAllRequest.onerror = () => {
                    console.error('‚ùå [FIX DUPLICATES] Failed to load CSV files:', getAllRequest.error);
                    showToast('‚ùå Failed to fix duplicates', 'error', toastPosition);
                };
            } catch (error) {
                console.error('‚ùå [FIX DUPLICATES] Error:', error);
                showToast('‚ùå Error fixing duplicates', 'error', toastPosition);
            }
        }

        /**
         * Clear CSV files and transactions only (preserve project budgets)
         */
        async function clearAndRefreshDatabase(event) {
            console.log('üîÑ [RESET CSV] User clicked Reset DB button');

            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            // Show confirmation dialog
            const confirmed = confirm(
                '‚ö†Ô∏è RESET CSV DATA\n\n' +
                'This will delete:\n' +
                '  ‚Ä¢ All saved CSV files\n' +
                '  ‚Ä¢ All transactions\n' +
                '  ‚Ä¢ All transaction assignments\n\n' +
                '‚úÖ This will PRESERVE:\n' +
                '  ‚Ä¢ Your project budgets\n' +
                '  ‚Ä¢ Your project settings\n' +
                '  ‚Ä¢ Your invoices\n\n' +
                'After reset, you will need to re-upload your CSV files.\n\n' +
                'Continue?'
            );

            if (!confirmed) {
                console.log('üîÑ [RESET CSV] User cancelled operation');
                return;
            }

            console.log('üîÑ [RESET CSV] Starting CSV data reset...');
            showToast('üîÑ Clearing CSV data...', 'info', toastPosition);

            try {
                if (!db) {
                    await initIndexedDB();
                }

                // Clear only the csvFiles object store (preserve projects and invoices)
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const clearRequest = objectStore.clear();

                clearRequest.onsuccess = () => {
                    console.log('‚úÖ [RESET CSV] CSV files cleared successfully');

                    // Clear in-memory transaction data
                    allTransactions = [];
                    savedCSVFiles = [];

                    showToast('‚úÖ CSV data cleared! Reloading...', 'success', toastPosition);

                    // Reload the page after a short delay
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                };

                clearRequest.onerror = (event) => {
                    console.error('‚ùå [RESET CSV] Failed to clear CSV files:', event);
                    showToast('‚ùå Failed to clear CSV data', 'error', toastPosition);
                };

            } catch (error) {
                console.error('‚ùå [RESET CSV] Error:', error);
                showToast('‚ùå Error clearing CSV data', 'error', toastPosition);
            }
        }

        // Initialize on page load
        let isPageInitialized = false;
        document.addEventListener('DOMContentLoaded', async () => {
            if (isPageInitialized) {
                console.warn('‚ö†Ô∏è [PAGE LOAD] Page already initialized, skipping duplicate initialization');
                return;
            }

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üöÄ [PAGE LOAD] DOMContentLoaded event fired');
            console.log('üìÖ [PAGE LOAD] Timestamp:', new Date().toISOString());
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            try {
                console.log('‚öôÔ∏è [PAGE LOAD] Step 1/6: Loading display settings...');
                loadDisplaySettings();

                console.log('üíæ [PAGE LOAD] Step 2/6: Initializing IndexedDB...');
                await initIndexedDB();

                console.log('üìä [PAGE LOAD] Step 3/6: Loading projects from DB...');
                await loadProjectsFromDB();

                console.log('üìÇ [PAGE LOAD] Step 4/6: Loading saved CSV files...');
                await loadSavedCSVFiles();

                console.log('üîë [PAGE LOAD] Step 5/6: Updating API key status...');
                updateAPIKeyStatus(); // Update API key status display

                console.log('üìß [PAGE LOAD] Step 6/6: Loading Gmail accounts...');
                loadGmailAccountsFromStorage(); // Restore saved Gmail accounts
                updateGmailStatus(); // Update UI to show restored accounts

                // Final summary
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('‚úÖ [PAGE LOAD] Page initialization complete!');
                console.log('üìä [PAGE LOAD] Summary:');
                console.log(`   - CSV Files: ${savedCSVFiles.length}`);
                console.log(`   - Total Transactions: ${allTransactions.length}`);
                console.log(`   - Projects Loaded: ${allProjects.length}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Populate project filter dropdown
                populateProjectFilter();

                isPageInitialized = true;
            } catch (error) {
                console.error('‚ùå [PAGE LOAD] Initialization failed:', error);
                showToast('‚ùå Failed to initialize page. Please refresh.', 'error');
            }
        });

        // Drag and drop removed - using compact file input button in Bank Feed card

        // File upload handler
        document.getElementById('csvFileInput').addEventListener('change', async function(e) {
            const files = e.target.files;
            if (files.length === 0) return;

            for (let file of files) {
                await loadAndSaveCSVFile(file);
            }

            renderTransactions();
            updateSummary();
            updateCSVSummary();
            // Reset file input to allow reloading same file
            e.target.value = '';
        });

        // ========================================
        // DRAG AND DROP FOR CSV FILES
        // ========================================

        const dropZone = document.getElementById('bankFeedDropZone');

        // Prevent default drag behaviors on the entire page
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone when dragging over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, function() {
                dropZone.style.background = 'linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%)';
                dropZone.style.border = '2px dashed #3AAFA9';
                dropZone.style.transform = 'scale(1.02)';
            }, false);
        });

        // Remove highlight when leaving drop zone
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, function() {
                dropZone.style.background = '';
                dropZone.style.border = '';
                dropZone.style.transform = '';
            }, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', async function(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length === 0) return;

            // Filter for CSV files only
            const csvFiles = Array.from(files).filter(file =>
                file.name.toLowerCase().endsWith('.csv')
            );

            if (csvFiles.length === 0) {
                showToast('‚ö†Ô∏è Please drop CSV files only', 'error');
                return;
            }

            // Process each CSV file
            for (let file of csvFiles) {
                await loadAndSaveCSVFile(file);
            }

            renderTransactions();
            updateSummary();
            updateCSVSummary();

            showToast(`‚úÖ Loaded ${csvFiles.length} CSV file(s)`, 'success');
        }, false);

        function updateBudgetInfo() {
            console.log('üîÑ [BUDGET INFO] Starting updateBudgetInfo...');
            const infoDiv = document.getElementById('loadedBudgetsInfo');

            console.log(`üìä [BUDGET INFO] allProjects.length: ${allProjects.length}`);

            if (allProjects.length === 0) {
                console.log('‚ö†Ô∏è [BUDGET INFO] No projects to display');
                infoDiv.innerHTML = 'No budgets found';
                return;
            }

            // Automatically activate ALL projects
            activeProjects = allProjects;
            console.log(`‚úÖ [BUDGET INFO] Activated ${activeProjects.length} projects`);

            // Build compact summary
            let totalBudget = 0;
            console.log('üí∞ [BUDGET INFO] Calculating total budget...');

            allProjects.forEach((project, index) => {
                const labour = project.labour?.totalCost || 0;
                const overheads = project.overheads?.totalCost || 0;
                const materials = project.materials?.totalCost || 0;
                const capital = project.capitalUsage?.totalCost || 0;
                const subcontracting = project.subcontracting?.totalCost || 0;
                const travel = project.travel?.totalCost || 0;
                const other = project.otherCosts?.totalCost || 0;

                const projectTotal = labour + overheads + materials + capital + subcontracting + travel + other;

                console.log(`   Project ${index + 1} (${project.projectName || 'Unnamed'}):`, {
                    labour: `¬£${labour}`,
                    overheads: `¬£${overheads}`,
                    materials: `¬£${materials}`,
                    capital: `¬£${capital}`,
                    subcontracting: `¬£${subcontracting}`,
                    travel: `¬£${travel}`,
                    other: `¬£${other}`,
                    projectTotal: `¬£${projectTotal}`
                });

                totalBudget += projectTotal;
            });

            console.log(`üí∞ [BUDGET INFO] Total budget across all projects: ¬£${totalBudget.toLocaleString()}`);

            const displayText = `${allProjects.length} project${allProjects.length > 1 ? 's' : ''} (¬£${totalBudget.toLocaleString()})`;
            console.log(`‚úÖ [BUDGET INFO] Setting display text: "${displayText}"`);
            infoDiv.innerHTML = displayText;

            console.log('‚úÖ [BUDGET INFO] updateBudgetInfo complete');
        }


        async function loadCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const transactions = parseCSV(content);
                    allTransactions.push(...transactions);
                    resolve();
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function loadAndSaveCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const content = e.target.result;

                    // Detect bank from filename
                    const bankIdentifier = detectBank(file.name);

                    const transactions = parseCSV(content, bankIdentifier);

                    // APPEND transactions instead of replacing
                    allTransactions.push(...transactions);

                    // Save to IndexedDB
                    await saveCSVFileToDB(file.name, transactions, bankIdentifier);

                    resolve();
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function detectBank(fileName) {
            const nameLower = fileName.toLowerCase();
            if (nameLower.includes('revolut')) {
                return 'R';
            } else if (nameLower.includes('metro')) {
                return 'M';
            }
            return '?'; // Unknown bank
        }

        function parseCSV(csvText, bankIdentifier = '?') {
            console.log('üìù [PARSE CSV] Starting CSV parsing...');
            console.log(`üìè [PARSE CSV] CSV text length: ${csvText.length} characters`);
            console.log(`üè¶ [PARSE CSV] Bank identifier: "${bankIdentifier}"`);

            const lines = csvText.split('\n');
            console.log(`üìÑ [PARSE CSV] Total lines: ${lines.length}`);
            console.log(`üìÑ [PARSE CSV] Header line: "${lines[0]}"`);

            const transactions = [];

            // Parse header row to identify column indices
            const headerLine = lines[0].trim();
            const headerFields = parseCSVLine(headerLine);
            console.log(`üìã [PARSE CSV] Header fields:`, headerFields);

            // Detect column indices based on header names
            const columnMap = {
                date: -1,
                description: -1,
                spent: -1,
                received: -1,
                fromTo: -1,
                transactionPosted: -1
            };

            headerFields.forEach((header, index) => {
                const lowerHeader = header.toLowerCase().trim();

                // Date column
                if (lowerHeader.includes('date') && columnMap.date === -1) {
                    columnMap.date = index;
                }
                // Description column
                else if ((lowerHeader.includes('description') || lowerHeader.includes('details') ||
                         lowerHeader.includes('narrative')) && columnMap.description === -1) {
                    columnMap.description = index;
                }
                // Spent/Debit/Money Out column
                else if ((lowerHeader.includes('spent') || lowerHeader.includes('debit') ||
                         lowerHeader.includes('money out') || lowerHeader.includes('paid out') ||
                         lowerHeader.includes('withdrawal')) && columnMap.spent === -1) {
                    columnMap.spent = index;
                }
                // Received/Credit/Money In column
                else if ((lowerHeader.includes('received') || lowerHeader.includes('credit') ||
                         lowerHeader.includes('money in') || lowerHeader.includes('paid in') ||
                         lowerHeader.includes('deposit')) && columnMap.received === -1) {
                    columnMap.received = index;
                }
                // From/To column
                else if ((lowerHeader.includes('from') || lowerHeader.includes('to') ||
                         lowerHeader.includes('payee')) && columnMap.fromTo === -1) {
                    columnMap.fromTo = index;
                }
                // Transaction Posted column
                else if (lowerHeader.includes('posted') && columnMap.transactionPosted === -1) {
                    columnMap.transactionPosted = index;
                }
            });

            console.log(`üó∫Ô∏è [PARSE CSV] Column mapping:`, columnMap);
            console.log(`   üìÖ Date: column ${columnMap.date}`);
            console.log(`   üìù Description: column ${columnMap.description}`);
            console.log(`   üí∏ Spent: column ${columnMap.spent}`);
            console.log(`   üí∞ Received: column ${columnMap.received}`);
            console.log(`   üë§ From/To: column ${columnMap.fromTo}`);

            // If column detection failed, fall back to default indices
            if (columnMap.date === -1) columnMap.date = 0;
            if (columnMap.description === -1) columnMap.description = 1;
            if (columnMap.spent === -1) columnMap.spent = 2;
            if (columnMap.received === -1) columnMap.received = 3;
            if (columnMap.fromTo === -1) columnMap.fromTo = 4;
            if (columnMap.transactionPosted === -1) columnMap.transactionPosted = 5;

            for (let i = 1; i < lines.length; i++) { // Skip header row
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);

                if (fields.length >= 4) {
                    const transaction = {
                        bank: bankIdentifier,
                        date: fields[columnMap.date] || '',
                        description: fields[columnMap.description] || '',
                        spent: fields[columnMap.spent] || '',
                        received: fields[columnMap.received] || '',
                        fromTo: fields[columnMap.fromTo] || '',
                        transactionPosted: fields[columnMap.transactionPosted] || ''
                    };
                    transactions.push(transaction);

                    // Log first 3 transactions for debugging
                    if (i <= 3) {
                        console.log(`üí≥ [PARSE CSV] Transaction ${i}:`, transaction);
                    }
                }
            }

            console.log(`‚úÖ [PARSE CSV] Parsed ${transactions.length} transactions`);

            // Log spent vs received breakdown
            const spentCount = transactions.filter(t => t.spent && t.spent.trim()).length;
            const receivedCount = transactions.filter(t => t.received && t.received.trim()).length;
            console.log(`üí∞ [PARSE CSV] Breakdown: ${spentCount} spent, ${receivedCount} received`);

            // Log first few spent and received transactions for verification
            const sampleSpent = transactions.filter(t => t.spent && t.spent.trim()).slice(0, 3);
            const sampleReceived = transactions.filter(t => t.received && t.received.trim()).slice(0, 3);
            if (sampleSpent.length > 0) {
                console.log(`üì§ [PARSE CSV] Sample SPENT transactions:`, sampleSpent);
            }
            if (sampleReceived.length > 0) {
                console.log(`üì• [PARSE CSV] Sample RECEIVED transactions:`, sampleReceived);
            }

            return transactions;
        }

        // Helper function to parse a single CSV line (handles quoted fields)
        function parseCSVLine(line) {
            const fields = [];
            let currentField = '';
            let inQuotes = false;

            for (let j = 0; j < line.length; j++) {
                const char = line[j];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    fields.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            fields.push(currentField); // Add last field

            return fields;
        }

        // ========================================
        // FILTERING FUNCTIONALITY
        // ========================================

        let currentFilterProject = '';
        let currentFilterCategory = '';

        function populateProjectFilter() {
            const filterSelect = document.getElementById('filterProject');
            if (!filterSelect) return;

            // Get unique projects from assignments
            const projects = new Set();
            projects.add('GENERAL_EXPENSES'); // Always include General Expenses

            allTransactions.forEach(trans => {
                if (trans.assignments && trans.assignments.length > 0) {
                    trans.assignments.forEach(assignment => {
                        if (assignment.projectId && assignment.projectName) {
                            projects.add(JSON.stringify({
                                id: assignment.projectId,
                                name: assignment.projectName
                            }));
                        }
                    });
                }
            });

            // Clear and rebuild options
            filterSelect.innerHTML = '<option value="">All Projects</option>';

            // Add General Expenses first
            filterSelect.innerHTML += '<option value="GENERAL_EXPENSES">PEBL General Expenses</option>';

            // Add other projects sorted by name
            const projectArray = Array.from(projects)
                .filter(p => p !== 'GENERAL_EXPENSES')
                .map(p => JSON.parse(p))
                .sort((a, b) => a.name.localeCompare(b.name));

            projectArray.forEach(proj => {
                filterSelect.innerHTML += `<option value="${proj.id}">${escapeHtml(proj.name)}</option>`;
            });
        }

        function handleProjectFilterChange() {
            const filterSelect = document.getElementById('filterProject');
            const categorySelect = document.getElementById('filterCategory');
            const statusDiv = document.getElementById('filterStatus');

            currentFilterProject = filterSelect.value;

            // Reset category filter
            categorySelect.innerHTML = '<option value="">All Categories</option>';
            currentFilterCategory = '';

            if (currentFilterProject) {
                // Enable category filter and populate with categories from selected project
                categorySelect.disabled = false;

                const categories = new Set();
                allTransactions.forEach(trans => {
                    if (trans.assignments && trans.assignments.length > 0) {
                        trans.assignments.forEach(assignment => {
                            if (assignment.projectId == currentFilterProject && assignment.category) {
                                categories.add(assignment.category);
                            }
                        });
                    }
                });

                Array.from(categories).sort().forEach(cat => {
                    categorySelect.innerHTML += `<option value="${escapeHtml(cat)}">${escapeHtml(cat)}</option>`;
                });
            } else {
                categorySelect.disabled = true;
            }

            applyFilters();
        }

        function applyFilters() {
            const categorySelect = document.getElementById('filterCategory');
            const statusDiv = document.getElementById('filterStatus');

            currentFilterCategory = categorySelect.value;

            renderTransactions();

            // Update status message
            let statusMsg = '';
            if (currentFilterProject) {
                const projectSelect = document.getElementById('filterProject');
                const projectName = projectSelect.options[projectSelect.selectedIndex].text;
                statusMsg = `Showing: ${projectName}`;
                if (currentFilterCategory) {
                    statusMsg += ` ‚Üí ${currentFilterCategory}`;
                }
            } else {
                statusMsg = 'Showing: All transactions';
            }
            statusDiv.textContent = statusMsg;
        }

        function clearFilters() {
            currentFilterProject = '';
            currentFilterCategory = '';
            document.getElementById('filterProject').value = '';
            document.getElementById('filterCategory').value = '';
            document.getElementById('filterCategory').disabled = true;
            document.getElementById('filterCategory').innerHTML = '<option value="">All Categories</option>';
            document.getElementById('filterStatus').textContent = 'Showing: All transactions';
            renderTransactions();
        }

        function jumpToTopUnassigned() {
            console.log('üéØ [JUMP] Searching for first unassigned transaction...');

            // Clear filters to show all transactions
            clearFilters();

            // Find the first unassigned transaction
            const firstUnassignedIndex = allTransactions.findIndex(transaction => {
                // Check if transaction has no assignments
                const hasNoAssignments = (!transaction.assignments || transaction.assignments.length === 0) &&
                                        !transaction.assignedItemName;
                return hasNoAssignments;
            });

            if (firstUnassignedIndex === -1) {
                // No unassigned transactions found
                alert('üéâ No unassigned transactions found! All expenses have been assigned.');
                console.log('‚úÖ [JUMP] All transactions are assigned');
                return;
            }

            console.log(`üéØ [JUMP] Found unassigned transaction at index ${firstUnassignedIndex}`);

            // Select the row
            selectedRowIndex = firstUnassignedIndex;
            renderTransactions();

            // Wait for render to complete, then scroll to it
            setTimeout(() => {
                scrollRowIntoView(firstUnassignedIndex);

                // Focus on the row for keyboard shortcuts
                const row = document.querySelector(`tr[data-row-index="${firstUnassignedIndex}"]`);
                if (row) {
                    row.focus();
                    console.log('‚úÖ [JUMP] Row focused and ready for keyboard shortcuts');
                }
            }, 100);
        }

        function renderTransactions() {
            console.log('üé® [RENDER] Starting renderTransactions...');
            console.log(`üìä [RENDER] allTransactions.length: ${allTransactions.length}`);
            if (allTransactions.length > 0) {
                console.log(`üîç [RENDER] First transaction:`, allTransactions[0]);
                console.log(`üîç [RENDER] Transaction keys:`, Object.keys(allTransactions[0]));
                console.log(`üë§ [RENDER] First transaction fromTo:`, allTransactions[0].fromTo);
                console.log(`üîç [RENDER] Sample transactions:`, allTransactions.slice(0, 3));
            }

            const tbody = document.getElementById('tableBody');

            if (allTransactions.length === 0) {
                console.log('‚ö†Ô∏è [RENDER] No transactions to render');
                tbody.innerHTML = '<tr class="empty-state"><td colspan="9">No transactions loaded. Please upload a CSV file.</td></tr>';
                return;
            }

            // Apply filters
            let filteredTransactions = allTransactions;
            if (currentFilterProject || currentFilterCategory) {
                filteredTransactions = allTransactions.filter(transaction => {
                    // Check if transaction has assignments matching the filter
                    if (!transaction.assignments || transaction.assignments.length === 0) {
                        return false; // Don't show unassigned transactions when filtering
                    }

                    return transaction.assignments.some(assignment => {
                        let projectMatch = true;
                        let categoryMatch = true;

                        if (currentFilterProject) {
                            projectMatch = assignment.projectId == currentFilterProject;
                        }

                        if (currentFilterCategory) {
                            categoryMatch = assignment.category === currentFilterCategory;
                        }

                        return projectMatch && categoryMatch;
                    });
                });
            }

            console.log(`‚úÖ [RENDER] Rendering ${filteredTransactions.length} of ${allTransactions.length} transactions...`);
            tbody.innerHTML = filteredTransactions.map((transaction, index) => {
                // Debug first transaction
                if (index === 0) {
                    console.log(`üë§ [RENDER ROW 0] fromTo value: "${transaction.fromTo}"`);
                    console.log(`üë§ [RENDER ROW 0] Has fromTo field: ${transaction.hasOwnProperty('fromTo')}`);
                }

                // Helper function to truncate text with popup
                const truncateWithPopup = (text, maxLength, fieldName, rowIndex) => {
                    if (!text || text.length <= maxLength) {
                        return escapeHtml(text);
                    }
                    const truncated = text.substring(0, maxLength) + '...';
                    return `<span onclick="showTextPopup('${fieldName}', ${rowIndex}); event.stopPropagation();" style="cursor: pointer; text-decoration: underline dotted;" title="Click to view full text">${escapeHtml(truncated)}</span>`;
                };

                // Description column - always show original bank description (unchanged)
                const descriptionText = transaction.description || '';
                const descriptionHtml = `<span style="font-size: 11px; color: #64748b;">${truncateWithPopup(descriptionText, 100, 'description', index)}</span>`;

                // Detail column - show manual description, voice notes, or AI-generated detail
                let detailHtml = '';
                if (transaction.detail) {
                    // AI-generated or manually set detail
                    const detailText = transaction.detail;
                    detailHtml = `<span style="font-size: 11px; color: #1e293b; font-weight: 500;">${truncateWithPopup(detailText, 100, 'detail', index)}</span>`;
                } else if (transaction.manualDescription) {
                    // Legacy field - migrate to detail
                    const detailText = transaction.manualDescription;
                    detailHtml = `<span style="font-size: 11px; color: #1e293b; font-weight: 500;">${truncateWithPopup(detailText, 100, 'detail', index)}</span>`;
                } else {
                    detailHtml = `<span style="font-size: 10px; color: #94a3b8; font-style: italic;">-</span>`;
                }

                // Handle both old single assignment format and new split assignments array - COMPACT VERSION
                let categoryBadges = '';
                if (transaction.assignments && transaction.assignments.length > 0) {
                    // New format: array of assignments - compact single-line badges with √ó button
                    categoryBadges = transaction.assignments.map((assignment, assignmentIndex) => {
                        const percentage = assignment.percentage === 100 ? '' : ` ${assignment.percentage}%`;
                        const quarter = assignment.quarter ? ` Q${assignment.quarter}` : '';
                        const icon = assignment.icon ? `${assignment.icon} ` : '';
                        const isGeneral = assignment.projectId === 'GENERAL_EXPENSES';
                        const badgeStyle = isGeneral ? 'background-color: #fef3c7; border: 1px solid #fbbf24;' : '';
                        const compactInfo = `${icon}${escapeHtml(assignment.itemName)}${percentage} ‚Ä¢ ${escapeHtml(assignment.category)} ‚Ä¢ ${escapeHtml(assignment.projectName || 'Project')}${quarter}`;
                        return `<span class="assigned-category" title="${compactInfo}" style="position: relative; padding: 3px 18px 3px 6px; ${badgeStyle} display: inline-block; margin: 2px 2px 2px 0; white-space: nowrap; max-width: 100%; overflow: hidden; text-overflow: ellipsis;">
                            <span style="font-size: 10px; font-weight: 500; line-height: 1;">${compactInfo}</span>
                            <button onclick="handleUnassign(${index}, ${assignmentIndex}); event.stopPropagation();"
                                    style="position: absolute; top: 2px; right: 2px; background: #dc2626; border: none; border-radius: 2px; width: 14px; height: 14px; cursor: pointer; font-size: 10px; line-height: 1; padding: 0; color: white; transition: all 0.15s; font-weight: bold;"
                                    onmouseover="this.style.background='#b91c1c'; this.style.transform='scale(1.1)';"
                                    onmouseout="this.style.background='#dc2626'; this.style.transform='scale(1)';"
                                    title="Remove assignment">√ó</button>
                        </span>`;
                    }).join('');
                } else if (transaction.assignedItemName) {
                    // Old format: single assignment (backward compatibility) - compact version with √ó button
                    const isGeneral = transaction.assignedProject === 'GENERAL_EXPENSES';
                    const badgeStyle = isGeneral ? 'background-color: #fef3c7; border: 1px solid #fbbf24;' : '';
                    const compactInfo = `${escapeHtml(transaction.assignedItemName)} ‚Ä¢ ${escapeHtml(transaction.assignedCategory)}`;
                    categoryBadges = `<span class="assigned-category" title="${compactInfo}" style="position: relative; padding: 3px 18px 3px 6px; ${badgeStyle} display: inline-block; margin: 2px 2px 2px 0; white-space: nowrap; max-width: 100%; overflow: hidden; text-overflow: ellipsis;">
                        <span style="font-size: 10px; font-weight: 500; line-height: 1;">${compactInfo}</span>
                        <button onclick="handleUnassign(${index}); event.stopPropagation();"
                                style="position: absolute; top: 2px; right: 2px; background: #dc2626; border: none; border-radius: 2px; width: 14px; height: 14px; cursor: pointer; font-size: 10px; line-height: 1; padding: 0; color: white; transition: all 0.15s; font-weight: bold;"
                                onmouseover="this.style.background='#b91c1c'; this.style.transform='scale(1.1)';"
                                onmouseout="this.style.background='#dc2626'; this.style.transform='scale(1)';"
                                title="Remove assignment">√ó</button>
                    </span>`;
                }

                // Notes column - show voice notes if available
                const notesContent = transaction.voiceNotes ? escapeHtml(transaction.voiceNotes) : '';

                // Determine assign button appearance
                const hasAssignments = (transaction.assignments && transaction.assignments.length > 0) || transaction.assignedItemName;
                const assignBtnTitle = hasAssignments ? 'Reassign / Add Split' : 'Assign to Budget';
                const assignBtnIcon = hasAssignments ? '‚û°Ô∏è' : '‚û°Ô∏è';

                // Calculate VAT-exclusive amount (divide by 1.2 for UK 20% VAT)
                const spentAmount = parseAmount(transaction.spent);
                const spentExVAT = spentAmount > 0 ? (spentAmount / 1.2).toFixed(2) : '';

                return `
                <tr class="${selectedRowIndex === index ? 'row-selected' : ''}" onclick="selectRow(${index}, event)" data-row-index="${index}" tabindex="0">
                    <td style="text-align: center; font-weight: 600; color: ${transaction.bank === 'R' ? '#3AAFA9' : '#2B7A78'};">${transaction.bank || '?'}</td>
                    <td>${escapeHtml(transaction.date)}</td>
                    <td class="description-cell">${descriptionHtml}</td>
                    <td class="detail-cell">${detailHtml}</td>
                    <td class="fromto-cell">${escapeHtml(transaction.fromTo || '')}</td>
                    <td class="amount-spent">${escapeHtml(transaction.spent)}</td>
                    <td class="amount-spent" style="color: #059669; font-weight: 500;">${spentExVAT}</td>
                    <td class="amount-received">${escapeHtml(transaction.received)}</td>
                    <td class="notes-cell">${notesContent}</td>
                    <td class="action-buttons">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                            <div style="display: flex; gap: 5px;">
                                <button class="action-btn edit-btn" onclick="handleManualEdit(${index}); event.stopPropagation();" title="Add Expense Detail">‚úèÔ∏è</button>
                                <button class="action-btn mic-btn" id="micBtn${index}" onclick="toggleRowVoiceRecording(${index}); event.stopPropagation();" title="Voice Note">üé§</button>
                                ${transaction.invoiceId ?
                                    `<button class="action-btn pdf-btn" onclick="openAttachedInvoice(${index}); event.stopPropagation();" title="View Attached Invoice: ${escapeHtml(transaction.invoiceFilename || 'invoice.pdf')}" style="background: #22c55e;">üìÑ</button>` :
                                    `<button class="action-btn invoice-btn" id="invoiceBtn${index}" onclick="handleInvoiceFetch(${index}); event.stopPropagation();" title="Find Invoice">üìß</button>`
                                }
                                <button class="action-btn delete-btn ${hasAssignments ? 'has-assignment' : ''}" onclick="handleAssign(${index}); event.stopPropagation();" oncontextmenu="handleUnassign(${index}); return false;" title="${assignBtnTitle}" id="assignBtn${index}">
                                    ${assignBtnIcon}
                                </button>
                            </div>
                            ${categoryBadges ? `<div style="display: flex; flex-wrap: wrap; justify-content: center; max-width: 100%; margin-top: 2px;">${categoryBadges}</div>` : ''}
                        </div>
                    </td>
                </tr>
            `;
            }).join('');

            // Apply column visibility after rendering
            applyColumnVisibility();

            // Debug: Log table headers
            console.log('üîç [RENDER] Checking table headers...');
            const headers = document.querySelectorAll('#transactionsTable th');
            console.log(`üìä [RENDER] Total headers: ${headers.length}`);
            headers.forEach((h, i) => console.log(`   Header ${i}: "${h.textContent.trim()}" (display: ${h.style.display || 'default'})`));
        }

        function updateSummary() {
            document.getElementById('totalTransactions').textContent = allTransactions.length;

            let totalSpent = 0;
            let totalReceived = 0;

            allTransactions.forEach(t => {
                const spent = parseAmount(t.spent);
                const received = parseAmount(t.received);
                totalSpent += spent;
                totalReceived += received;
            });

            document.getElementById('totalSpent').textContent = totalSpent.toFixed(2);
            document.getElementById('totalReceived').textContent = totalReceived.toFixed(2);
        }

        function parseAmount(amountStr) {
            if (!amountStr) return 0;
            // Remove currency symbols and commas
            const cleaned = amountStr.replace(/[¬£$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Action button handlers
        function handleManualEdit(index) {
            const transaction = allTransactions[index];
            currentEditingIndex = index;

            // Find the detail cell for this row (not description - that's from bank CSV)
            const row = document.querySelector(`tr[data-row-index="${index}"]`);
            if (!row) return;

            const detailCell = row.querySelector('.detail-cell');
            if (!detailCell) return;

            // Create inline input box - read from detail field (or legacy manualDescription)
            const currentValue = transaction.detail || transaction.manualDescription || '';
            detailCell.innerHTML = `
                <div style="display: flex; align-items: center; gap: 4px;">
                    <input type="text"
                           id="inline-edit-${index}"
                           value="${escapeHtml(currentValue)}"
                           placeholder="Add Expense Detail..."
                           style="flex: 1; padding: 4px 6px; border: 2px solid #3b82f6; border-radius: 4px; font-size: 11px; outline: none; background: #eff6ff;"
                           onkeydown="handleInlineEditKeydown(event, ${index})"
                           onblur="cancelInlineEdit(${index})">
                    <span style="font-size: 9px; color: #94a3b8;">Press Enter ‚Üµ</span>
                </div>
            `;

            // Focus the input
            setTimeout(() => {
                const input = document.getElementById(`inline-edit-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        // Handle keyboard input in inline editor
        function handleInlineEditKeydown(event, index) {
            if (event.key === 'Enter') {
                event.preventDefault();
                saveInlineEdit(index);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelInlineEdit(index);
            }
        }

        // Save inline edit
        async function saveInlineEdit(index) {
            const input = document.getElementById(`inline-edit-${index}`);
            if (!input) return;

            const newValue = input.value.trim();

            // Save to transaction detail field
            allTransactions[index].detail = newValue;

            // Save to storage
            await saveTransactionsToStorage();

            // Re-render to show the detail
            renderTransactions();

            // Show success toast
            if (newValue) {
                showToast('‚úÖ Expense Detail saved', 'success');
            } else {
                showToast('‚úÖ Expense Detail cleared', 'success');
            }

            currentEditingIndex = null;
        }

        // Cancel inline edit
        function cancelInlineEdit(index) {
            // Just re-render to restore original state
            setTimeout(() => {
                // Check if we're still in edit mode (not saved)
                const input = document.getElementById(`inline-edit-${index}`);
                if (input) {
                    renderTransactions();
                    currentEditingIndex = null;
                }
            }, 200); // Delay to allow click on other elements
        }

        function closeEditModal() {
            document.getElementById('editDescriptionModal').classList.remove('active');
            currentEditingIndex = null;
            document.getElementById('modalManualDescription').value = '';
            document.getElementById('modalVoiceNotes').value = '';
        }

        function saveManualDescription() {
            if (currentEditingIndex === null) return;

            const manualDescription = document.getElementById('modalManualDescription').value.trim();
            const voiceNotes = document.getElementById('modalVoiceNotes').value.trim();

            // Save manual description to the detail field (not description - that's from bank CSV)
            allTransactions[currentEditingIndex].detail = manualDescription;
            allTransactions[currentEditingIndex].voiceNotes = voiceNotes;

            // Re-render the table to show changes
            renderTransactions();

            // Close modal
            closeEditModal();

            // Show success feedback
            showToast('‚úÖ Transaction updated successfully!', 'success');
        }

        // Close modal when clicking outside
        document.getElementById('editDescriptionModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditModal();
            }
        });

        function handleApplyRule(index) {
            const transaction = allTransactions[index];
            alert(`Apply Rule: ${transaction.description}\n\nThis feature will allow you to apply automated categorization rules.`);
        }

        /**
         * Calculate total claimed costs for a category (sum of all quarterly costs)
         */
        function getCategoryClaimed(category) {
            let total = 0;
            const items = category.items || category.staff || category.contractors || category.trips || [];

            items.forEach(item => {
                if (item.quarterlyCosts) {
                    total += (item.quarterlyCosts.q1 || 0) + (item.quarterlyCosts.q2 || 0) +
                             (item.quarterlyCosts.q3 || 0) + (item.quarterlyCosts.q4 || 0);
                }
            });

            return total;
        }

        /**
         * Calculate claimed costs for a specific item
         */
        function getItemClaimed(item) {
            if (!item.quarterlyCosts) return 0;
            return (item.quarterlyCosts.q1 || 0) + (item.quarterlyCosts.q2 || 0) +
                   (item.quarterlyCosts.q3 || 0) + (item.quarterlyCosts.q4 || 0);
        }

        /**
         * STEP 1: Show project selection
         */
        function showProjectSelection() {
            console.log('üìã [MODAL DEBUG] showProjectSelection called');
            console.log('üìã [MODAL DEBUG] currentEditingIndex:', currentEditingIndex);
            console.log('üìã [MODAL DEBUG] allTransactions.length:', allTransactions.length);

            assignmentStep = 1;
            selectedProject = null;
            selectedCategoryName = null;
            selectedCategory = null;

            const transaction = allTransactions[currentEditingIndex];
            console.log('üìã [MODAL DEBUG] Transaction:', transaction);

            let content = `
                <div style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 11px; color: #666;">Transaction</div>
                        <div style="font-size: 12px; font-weight: 600;">${escapeHtml(transaction.description)}</div>
                        <div style="font-size: 10px; color: #888;">${transaction.date} ‚Ä¢ ¬£${transaction.spent || transaction.received}</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.75); color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px;">
                        ‚å®Ô∏è Press 1-9 to select ‚Ä¢ ‚Üë‚Üì Navigate ‚Ä¢ ‚Üê Back ‚Ä¢ Enter to confirm
                    </div>
                </div>
                <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px; color: #333;">Step 1: Select Project</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            // Add PEBL General Expenses option
            content += `
                <div class="category-option" onclick="selectGeneralExpenses()" style="cursor: pointer; padding: 8px 12px; margin-bottom: 4px; border: 2px solid #f59e0b; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 4px; transition: all 0.2s; display: flex; align-items: center; gap: 10px;">
                    <span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #f59e0b; color: white; border-radius: 4px; font-weight: 700; font-size: 13px;">1</span>
                    <span style="font-size: 16px;">üè¢</span>
                    <div style="flex: 1;">
                        <span style="font-size: 12px; font-weight: 600; color: #92400e;">PEBL General Expenses</span>
                        <span style="font-size: 10px; color: #78350f; margin-left: 8px;">Non-project business expenses</span>
                    </div>
                </div>
                <div style="border-bottom: 1px solid #e5e7eb; margin: 8px 0; padding-bottom: 4px;">
                    <div style="font-size: 10px; color: #6b7280; font-weight: 600;">PROJECT BUDGETS</div>
                </div>
            `;

            activeProjects.forEach((project, idx) => {
                const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;
                const number = idx + 2; // Start from 2 (1 is PEBL General)

                content += `
                    <div class="category-option" onclick="selectProjectStep('${project.projectId}')" style="cursor: pointer; padding: 8px 12px; margin-bottom: 4px; border: 1px solid #e0e0e0; border-radius: 4px; transition: all 0.2s; display: flex; align-items: center; gap: 10px;">
                        <span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px;">${number}</span>
                        <span>üìÅ</span>
                        <span style="font-size: 12px; font-weight: 600; color: #333;">${escapeHtml(projectName)}</span>
                        <span style="font-size: 10px; color: #999; margin-left: auto;">ID: ${project.projectId}</span>
                    </div>
                `;
            });

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;

            console.log('üìã [MODAL DEBUG] Modal content HTML set, length:', content.length);

            // Numbers are already added in HTML generation above
            // addNumbersToOptions(); // Removed to prevent duplication

            console.log('‚úÖ [MODAL DEBUG] showProjectSelection completed successfully');
        }

        /**
         * Add number badges to all category options
         */
        function addNumbersToOptions() {
            const options = document.querySelectorAll('.category-option');
            options.forEach((option, idx) => {
                // Skip if already has a number badge
                if (option.querySelector('[data-number-badge]')) return;

                const number = idx + 1;
                if (number > 9) return; // Only show numbers 1-9

                // Create number badge
                const badge = document.createElement('span');
                badge.setAttribute('data-number-badge', 'true');
                badge.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;';
                badge.textContent = number;

                // Insert at the beginning
                option.insertBefore(badge, option.firstChild);
            });
        }

        /**
         * Handle PEBL General Expenses selection - assigns directly
         */
        async function selectGeneralExpenses() {
            if (currentEditingIndex === null) return;

            const transaction = allTransactions[currentEditingIndex];
            const transAmount = parseAmount(transaction.spent || transaction.received);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Create new assignment object
            const newAssignment = {
                projectId: 'GENERAL_EXPENSES',
                projectName: 'PEBL General Expenses',
                category: 'PEBL General Expenses',
                itemKey: 'general-expense',
                itemName: 'PEBL General Expenses',
                icon: 'üè¢',
                quarter: null,
                percentage: 100,
                amount: transAmount,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] General expense assignment created:', newAssignment);

            // Keep old format for backward compatibility
            transaction.assignedCategory = 'PEBL General Expenses';
            transaction.assignedItem = 'general-expense';
            transaction.assignedItemName = 'PEBL General Expenses';
            transaction.assignedProject = 'GENERAL_EXPENSES';

            // Re-render the table
            renderTransactions();

            // Save to storage
            await saveTransactionsToStorage();

            // Close modal
            closeAssignModal();

            // Show success message
            showToast(`‚úÖ Assigned to PEBL General Expenses - Saved to local storage`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        /**
         * STEP 2: Show category selection for chosen project
         */
        function showCategorySelection() {
            assignmentStep = 2;

            const project = activeProjects.find(p => p.projectId == selectedProject);
            if (!project) return;

            const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;

            let content = `
                <div style="margin-bottom: 15px;">
                    <button onclick="showProjectSelection()" style="background: none; border: none; color: #3AAFA9; cursor: pointer; font-size: 12px; padding: 0;">
                        ‚Üê Back to Projects
                    </button>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">Selected: <strong>${escapeHtml(projectName)}</strong></div>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #333;">Step 2: Select Category</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            let categoryNumber = 1; // Counter for keyboard shortcuts

            // Materials
            if (project.materials && (project.materials.items?.length > 0 || (project.materials.totalCost && project.materials.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.materials);
                const budget = project.materials.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.materials.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Materials')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üîß Materials</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Capital Usage
            if (project.capitalUsage && (project.capitalUsage.items?.length > 0 || (project.capitalUsage.totalCost && project.capitalUsage.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.capitalUsage);
                const budget = project.capitalUsage.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.capitalUsage.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Capital Usage')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üíº Capital Usage</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Subcontracting
            if (project.subcontracting && (project.subcontracting.contractors?.length > 0 || (project.subcontracting.totalCost && project.subcontracting.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.subcontracting);
                const budget = project.subcontracting.totalCost || 0;
                const remaining = budget - claimed;
                const contractorCount = project.subcontracting.contractors?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Subcontracting')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">ü§ù Subcontracting</span>
                                <span style="font-size: 11px; color: #666;">${contractorCount} contractor${contractorCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Travel
            if (project.travel && (project.travel.trips?.length > 0 || (project.travel.totalCost && project.travel.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.travel);
                const budget = project.travel.totalCost || 0;
                const remaining = budget - claimed;
                const tripCount = project.travel.trips?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Travel')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">‚úàÔ∏è Travel</span>
                                <span style="font-size: 11px; color: #666;">${tripCount} trip${tripCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Other Costs
            if (project.otherCosts && (project.otherCosts.items?.length > 0 || (project.otherCosts.totalCost && project.otherCosts.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.otherCosts);
                const budget = project.otherCosts.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.otherCosts.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Other Costs')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Other Costs</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // WELSH GOV CATEGORIES
            if (project.welshGovData?.sections) {
                const sections = project.welshGovData.sections;

                // Capital - Non Standard Costs
                if (sections.capital?.nonStandard?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.capital.nonStandard });
                    const budget = sections.totals?.totalCapitalNonStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Capital Non-Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üèóÔ∏è Capital - Non Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.capital.nonStandard.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Revenue - Non Standard Costs
                if (sections.revenue?.nonStandard?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.revenue.nonStandard });
                    const budget = sections.totals?.totalRevenueNonStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Revenue Non-Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üí∞ Revenue - Non Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.revenue.nonStandard.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Revenue - Standard Costs
                if (sections.revenue?.standardCosts?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.revenue.standardCosts });
                    const budget = sections.totals?.totalRevenueStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Revenue Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üë• Revenue - Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.revenue.standardCosts.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Item Breakdown - Capital
                if (sections.itemBreakdown?.capital?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.itemBreakdown.capital });
                    let budget = 0;
                    sections.itemBreakdown.capital.forEach(item => {
                        budget += parseFloat(item.maxGrantApproved || item.totalCost || 0);
                    });
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Item Breakdown Capital')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Item Breakdown - Capital</span>
                                    <span style="font-size: 11px; color: #666;">${sections.itemBreakdown.capital.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Item Breakdown - Revenue
                if (sections.itemBreakdown?.revenue?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.itemBreakdown.revenue });
                    let budget = 0;
                    sections.itemBreakdown.revenue.forEach(item => {
                        budget += parseFloat(item.maxGrantApproved || item.totalCost || 0);
                    });
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Item Breakdown Revenue')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Item Breakdown - Revenue</span>
                                    <span style="font-size: 11px; color: #666;">${sections.itemBreakdown.revenue.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }
            }

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;
        }

        /**
         * STEP 3: Show item selection for chosen category
         */
        function showItemSelection() {
            assignmentStep = 3;

            const project = activeProjects.find(p => p.projectId == selectedProject);
            if (!project) return;

            const category = getCategoryObject(project, selectedCategoryName);
            if (!category) return;

            const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;

            let content = `
                <div style="margin-bottom: 15px;">
                    <button onclick="showCategorySelection()" style="background: none; border: none; color: #3AAFA9; cursor: pointer; font-size: 12px; padding: 0;">
                        ‚Üê Back to Categories
                    </button>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">${escapeHtml(projectName)} ‚Ä¢ ${selectedCategoryName}</div>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #333;">Step 3: Select Item</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            // Get items based on category
            let items = [];
            let itemPrefix = '';

            // IUK Categories
            if (selectedCategoryName === 'Materials' && category.items) {
                items = category.items;
                itemPrefix = 'materials';
            } else if (selectedCategoryName === 'Capital Usage' && category.items) {
                items = category.items;
                itemPrefix = 'capitalUsage';
            } else if (selectedCategoryName === 'Subcontracting' && category.contractors) {
                items = category.contractors;
                itemPrefix = 'subcontracting';
            } else if (selectedCategoryName === 'Travel' && category.trips) {
                items = category.trips;
                itemPrefix = 'travel';
            } else if (selectedCategoryName === 'Other Costs' && category.items) {
                items = category.items;
                itemPrefix = 'otherCosts';
            }
            // Welsh Gov Categories
            else if (selectedCategoryName === 'Capital Non-Standard' && category.items) {
                items = category.items;
                itemPrefix = 'capitalNonStandard';
            } else if (selectedCategoryName === 'Revenue Non-Standard' && category.items) {
                items = category.items;
                itemPrefix = 'revenueNonStandard';
            } else if (selectedCategoryName === 'Revenue Standard' && category.items) {
                items = category.items;
                itemPrefix = 'revenueStandard';
            } else if (selectedCategoryName === 'Item Breakdown Capital' && category.items) {
                items = category.items;
                itemPrefix = 'itemBreakdownCapital';
            } else if (selectedCategoryName === 'Item Breakdown Revenue' && category.items) {
                items = category.items;
                itemPrefix = 'itemBreakdownRevenue';
            }

            // If category has items, show them
            if (items && items.length > 0) {
                items.forEach((item, idx) => {
                    const itemKey = `${itemPrefix}-${idx}`;
                    const claimed = getItemClaimed(item);

                    // Get item name and budget
                    let itemName = '';
                    let itemBudget = 0;

                    // IUK Categories
                    if (selectedCategoryName === 'Materials') {
                        itemName = item.item;
                        itemBudget = item.total || 0;
                    } else if (selectedCategoryName === 'Capital Usage') {
                        itemName = item.description;
                        itemBudget = item.netCost || 0;
                    } else if (selectedCategoryName === 'Subcontracting') {
                        itemName = item.name;
                        itemBudget = item.cost || 0;
                    } else if (selectedCategoryName === 'Travel') {
                        itemName = item.purpose;
                        itemBudget = item.total || 0;
                    } else if (selectedCategoryName === 'Other Costs') {
                        itemName = item.description;
                        itemBudget = item.estimatedCost || 0;
                    }
                    // Welsh Gov Categories
                    else if (selectedCategoryName === 'Capital Non-Standard' || selectedCategoryName === 'Revenue Non-Standard') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantValue || item.totalCost || 0;
                    } else if (selectedCategoryName === 'Revenue Standard') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantValue || 0;
                    } else if (selectedCategoryName === 'Item Breakdown Capital' || selectedCategoryName === 'Item Breakdown Revenue') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantApproved || item.totalCost || 0;
                    }

                    const remaining = itemBudget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryItem('${selectedCategoryName}', '${itemKey}', '${escapeHtml(itemName)}', ${selectedProject})" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px;">
                            <div style="font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">${escapeHtml(itemName)}</div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${itemBudget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    `;
                });
            } else {
                // No line items - create a "General" option for category-level assignment
                const claimed = getCategoryClaimed(category);
                const budget = category.totalCost || 0;
                const remaining = budget - claimed;
                const generalItemKey = `${itemPrefix}-general`;
                const generalItemName = `General ${selectedCategoryName}`;

                content += `
                    <div style="padding: 12px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; margin-bottom: 12px;">
                        <p style="font-size: 11px; color: #92400e; margin: 0;">‚ÑπÔ∏è This category has no individual line items. Expenses will be assigned to the category as a whole.</p>
                    </div>
                    <div class="category-option" onclick="selectCategoryItem('${selectedCategoryName}', '${generalItemKey}', '${escapeHtml(generalItemName)}', ${selectedProject})" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 2px solid #3b82f6; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 6px;">
                        <div style="font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">üíº ${escapeHtml(generalItemName)}</div>
                        <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                            <span>Budget: ¬£${budget.toLocaleString()}</span>
                            <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                            <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                        </div>
                    </div>
                `;
            }

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;
        }

        /**
         * Handle project selection in step 1
         */
        function selectProjectStep(projectId) {
            selectedProject = projectId;
            showCategorySelection();
        }

        /**
         * Handle category selection in step 2
         */
        function selectCategoryStep(categoryName) {
            selectedCategoryName = categoryName;
            showItemSelection();
        }

        /**
         * Main entry point - open assignment modal
         */
        function handleAssign(index) {
            // Use the positioning handler for dropdown behavior
            handleAssignWithPosition(index);
        }

        async function selectCategoryItem(category, itemKey, itemName, projectId) {
            if (currentEditingIndex === null) return;

            const transaction = allTransactions[currentEditingIndex];
            const project = activeProjects.find(p => p.projectId === projectId);

            if (!project) {
                alert('‚ùå Project not found');
                return;
            }

            // Calculate quarter from transaction date
            const quarter = calculateTransactionQuarter(transaction.date, project);

            if (!quarter) {
                alert('‚ö†Ô∏è Cannot calculate quarter. Check project start date or transaction date.');
                return;
            }

            console.log(`üìÖ [ASSIGN] Calculated quarter: Q${quarter}`);

            // Calculate amount to assign (default 100%)
            const transAmount = parseAmount(transaction.spent || transaction.received);
            const percentage = 100;
            const amountToAssign = (transAmount * percentage) / 100;

            console.log(`üí∞ [ASSIGN] Amount to assign: ¬£${amountToAssign} (${percentage}% of ¬£${transAmount})`);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Create new assignment object
            const newAssignment = {
                projectId: projectId,
                projectName: project.projectName || project.projectNumber || `Project ${project.projectId}`,
                category: category,
                itemKey: itemKey,
                itemName: itemName,
                quarter: quarter,
                percentage: percentage,
                amount: amountToAssign,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] New assignment created:', newAssignment);

            // Update project quarterly costs in database
            try {
                await updateProjectQuarterlyCosts(project, { category, itemKey, itemName, projectId }, quarter, amountToAssign);
                console.log('‚úÖ [ASSIGN] Project quarterly costs updated');
            } catch (error) {
                console.error('‚ùå [ASSIGN] Failed to update project:', error);
                alert('‚ö†Ô∏è Assignment saved locally but failed to update project budget. Check console for details.');
            }

            // Keep old format for backward compatibility
            transaction.assignedCategory = category;
            transaction.assignedItem = itemKey;
            transaction.assignedItemName = itemName;
            transaction.assignedProject = projectId;

            // Save values for toast message
            const projectName = project.projectName || 'Unknown Project';

            // Re-render the table
            renderTransactions();

            // Update filter dropdown to include newly assigned project
            populateProjectFilter();

            // Save to storage
            await saveTransactionsToStorage();

            // Close modal
            closeAssignModal();

            // Show success message
            showToast(`‚úÖ Assigned to ${itemName} (${category}) - Q${quarter} - ${projectName} - Saved`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        function closeAssignModal() {
            console.log('‚ùå [MODAL DEBUG] closeAssignModal called');
            console.trace('‚ùå [MODAL DEBUG] Call stack:');

            const modal = document.getElementById('assignCategoryModal');
            const modalContent = modal.querySelector('.modal-content');

            modal.classList.remove('active', 'positioned');
            currentEditingIndex = null;
            selectedCategory = null;
            modalKeyboardIndex = -1;
            keyboardBuffer = '';

            // Reset modal positioning to center
            modalContent.style.position = '';
            modalContent.style.top = '';
            modalContent.style.left = '';
            modalContent.style.width = '';
            modalContent.style.margin = '';
            modalContent.style.maxHeight = '';
            modalContent.style.overflowY = '';
            modalContent.style.opacity = '';
            modalContent.style.transition = '';

            console.log('‚úÖ [MODAL DEBUG] Modal closed');
        }

        /**
         * Save all transactions to IndexedDB
         */
        async function saveTransactionsToStorage() {
            if (!db) {
                await initIndexedDB();
            }

            try {
                console.log('üíæ [SAVE] Saving transactions to storage...');

                // Group transactions by their source CSV file
                const transactionsByFile = {};

                savedCSVFiles.forEach(csvFile => {
                    // Find transactions that belong to this CSV file
                    const fileTransactions = allTransactions.filter(t => {
                        // Match transactions by date, bank, and description (robust matching)
                        return csvFile.transactions.some(ct =>
                            ct.date === t.date &&
                            ct.bank === t.bank &&
                            ct.description === t.description
                        );
                    });

                    if (fileTransactions.length > 0) {
                        transactionsByFile[csvFile.id] = {
                            csvFile: csvFile,
                            transactions: fileTransactions
                        };
                    }
                });

                // Update each CSV file with its transactions
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);

                for (const [id, data] of Object.entries(transactionsByFile)) {
                    const updatedCSVFile = {
                        ...data.csvFile,
                        transactions: data.transactions,
                        lastModified: new Date().toISOString()
                    };

                    await new Promise((resolve, reject) => {
                        const request = objectStore.put(updatedCSVFile);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }

                await loadSavedCSVFiles(); // Refresh the list
                console.log('‚úÖ [SAVE] Transactions saved successfully');

            } catch (error) {
                console.error('‚ùå [SAVE] Failed to save transactions:', error);
            }
        }

        async function saveAssignment() {
            if (currentEditingIndex === null) return;

            if (!selectedCategory) {
                alert('‚ö†Ô∏è Please select a budget item first.');
                return;
            }

            const transaction = allTransactions[currentEditingIndex];
            const project = activeProjects.find(p => p.projectId === selectedCategory.projectId);

            if (!project) {
                alert('‚ùå Project not found');
                return;
            }

            // Calculate quarter from transaction date
            const quarter = calculateTransactionQuarter(transaction.date, project);

            if (!quarter) {
                alert('‚ö†Ô∏è Cannot calculate quarter. Check project start date or transaction date.');
                return;
            }

            console.log(`üìÖ [ASSIGN] Calculated quarter: Q${quarter}`);

            // Calculate amount to assign (default 100%)
            const transAmount = parseAmount(transaction.spent || transaction.received);
            const percentage = 100; // TODO: Add split allocation UI
            const amountToAssign = (transAmount * percentage) / 100;

            console.log(`üí∞ [ASSIGN] Amount to assign: ¬£${amountToAssign} (${percentage}% of ¬£${transAmount})`);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Create new assignment object
            const newAssignment = {
                projectId: selectedCategory.projectId,
                projectName: project.projectName || project.projectNumber || `Project ${project.projectId}`,
                category: selectedCategory.category,
                itemKey: selectedCategory.itemKey,
                itemName: selectedCategory.itemName,
                quarter: quarter,
                percentage: percentage,
                amount: amountToAssign,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] New assignment created:', newAssignment);

            // Update project quarterly costs in database
            try {
                await updateProjectQuarterlyCosts(project, selectedCategory, quarter, amountToAssign);
                console.log('‚úÖ [ASSIGN] Project quarterly costs updated');
            } catch (error) {
                console.error('‚ùå [ASSIGN] Failed to update project:', error);
                alert('‚ö†Ô∏è Assignment saved locally but failed to update project budget. Check console for details.');
            }

            // Keep old format for backward compatibility
            transaction.assignedCategory = selectedCategory.category;
            transaction.assignedItem = selectedCategory.itemKey;
            transaction.assignedItemName = selectedCategory.itemName;
            transaction.assignedProject = selectedCategory.projectId;

            // Save values for toast message BEFORE closing modal (which nulls selectedCategory)
            const projectName = project.projectName || 'Unknown Project';
            const itemName = selectedCategory.itemName;
            const categoryName = selectedCategory.category;

            // Re-render the table
            renderTransactions();

            // Close modal (this will set selectedCategory = null)
            closeAssignModal();

            // Show success message
            showToast(`‚úÖ Assigned to ${itemName} (${categoryName}) - Q${quarter} - ${projectName}`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        /**
         * Update project's quarterly costs in IndexedDB
         */
        async function updateProjectQuarterlyCosts(project, selection, quarter, amount) {
            console.log('üîÑ [UPDATE COSTS] Updating quarterly costs...');
            console.log(`   Project: ${project.projectName || project.projectId}`);
            console.log(`   Category: ${selection.category}`);
            console.log(`   Item: ${selection.itemName}`);
            console.log(`   Quarter: Q${quarter}`);
            console.log(`   Amount: ¬£${amount}`);

            // Load fresh copy from DB to avoid conflicts
            if (!db) await initIndexedDB();

            const freshProject = await new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(project.projectId);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            if (!freshProject) {
                throw new Error('Project not found in database');
            }

            // Get category and item
            const category = getCategoryObject(freshProject, selection.category);
            const item = findItemInCategory(category, selection.itemKey);

            if (!item) {
                throw new Error(`Item not found: ${selection.itemKey}`);
            }

            // Initialize quarterlyCosts if it doesn't exist
            if (!item.quarterlyCosts) {
                item.quarterlyCosts = {q1: 0, q2: 0, q3: 0, q4: 0};
                console.log('üìä [UPDATE COSTS] Initialized quarterly costs for item');
            }

            // Add amount to the correct quarter
            const quarterKey = `q${quarter}`;
            const previousAmount = item.quarterlyCosts[quarterKey] || 0;
            item.quarterlyCosts[quarterKey] = previousAmount + amount;

            console.log(`‚úÖ [UPDATE COSTS] ${quarterKey}: ¬£${previousAmount} ‚Üí ¬£${item.quarterlyCosts[quarterKey]}`);

            // Update lastModified
            freshProject.lastModified = new Date().toISOString();

            // Save back to database
            await saveProjectToDB(freshProject);

            // Update in-memory activeProjects array
            const activeIndex = activeProjects.findIndex(p => p.projectId === freshProject.projectId);
            if (activeIndex !== -1) {
                activeProjects[activeIndex] = freshProject;
            }

            console.log('‚úÖ [UPDATE COSTS] Project saved successfully');
        }

        // Close modal when clicking outside
        document.getElementById('assignCategoryModal').addEventListener('click', function(e) {
            console.log('üñ±Ô∏è [MODAL DEBUG] Click on modal overlay detected');
            console.log('üñ±Ô∏è [MODAL DEBUG] e.target:', e.target);
            console.log('üñ±Ô∏è [MODAL DEBUG] this:', this);
            console.log('üñ±Ô∏è [MODAL DEBUG] Are they equal?', e.target === this);

            if (e.target === this) {
                console.log('‚ö†Ô∏è [MODAL DEBUG] Click outside modal content - closing modal');
                closeAssignModal();
            } else {
                console.log('‚úÖ [MODAL DEBUG] Click inside modal content - keeping modal open');
            }
        });

        // ========================================
        // KEYBOARD NAVIGATION
        // ========================================

        /**
         * Select a row for keyboard navigation
         */
        function selectRow(index, event) {
            if (event && event.target.tagName === 'BUTTON') {
                return; // Don't select row when clicking buttons
            }
            selectedRowIndex = index;
            renderTransactions();
        }

        /**
         * Advance to the next unassigned row after successful assignment
         */
        function advanceToNextRow() {
            if (selectedRowIndex === null) return;

            console.log('üìç [NAV] Advancing to next row from index:', selectedRowIndex);

            // Find the next row in the filtered/displayed transactions
            let nextIndex = selectedRowIndex + 1;

            // Wrap around if we're at the end
            if (nextIndex >= allTransactions.length) {
                nextIndex = 0;
            }

            selectedRowIndex = nextIndex;
            renderTransactions();
            scrollRowIntoView(selectedRowIndex);

            console.log('‚úÖ [NAV] Advanced to row:', selectedRowIndex);
        }

        /**
         * Handle keyboard shortcuts for table navigation and assignment
         */
        document.addEventListener('keydown', function(e) {
            const modalOpen = document.getElementById('assignCategoryModal').classList.contains('active');
            console.log('‚å®Ô∏è [MODAL DEBUG] Keydown event:', e.key, 'Modal open:', modalOpen);

            // Modal is closed - table navigation
            if (!modalOpen) {
                console.log('‚å®Ô∏è [MODAL DEBUG] Processing key in table navigation mode');
                // Arrow Down - select next row
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (selectedRowIndex === null) {
                        selectedRowIndex = 0;
                    } else if (selectedRowIndex < allTransactions.length - 1) {
                        selectedRowIndex++;
                    }
                    renderTransactions();
                    scrollRowIntoView(selectedRowIndex);
                }
                // Arrow Up - select previous row
                else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (selectedRowIndex === null) {
                        selectedRowIndex = allTransactions.length - 1;
                    } else if (selectedRowIndex > 0) {
                        selectedRowIndex--;
                    }
                    renderTransactions();
                    scrollRowIntoView(selectedRowIndex);
                }
                // '1' key - open assign dialog for selected row
                else if (e.key === '1' && selectedRowIndex !== null) {
                    e.preventDefault();
                    console.log('‚å®Ô∏è [MODAL DEBUG] Opening assign modal for row:', selectedRowIndex);
                    handleAssignWithPosition(selectedRowIndex);
                }
            }
            // Modal is open - number-based navigation
            else {
                console.log('‚å®Ô∏è [MODAL DEBUG] Processing key in modal navigation mode');
                // Escape - close modal
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeAssignModal();
                }
                // Number keys (1-9) - direct selection
                else if (e.key >= '1' && e.key <= '9') {
                    e.preventDefault();
                    const optionIndex = parseInt(e.key) - 1;
                    selectModalOptionByIndex(optionIndex);
                }
                // Arrow keys in modal
                else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    handleModalArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);
                }
                // Back arrow - go to previous step
                else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (assignmentStep === 3) {
                        // From item selection back to category selection
                        showCategorySelection();
                    } else if (assignmentStep === 2) {
                        // From category selection back to project selection
                        showProjectSelection();
                    } else if (assignmentStep === 1) {
                        // From project selection, close modal
                        closeAssignModal();
                    }
                }
                // Enter - select highlighted option
                else if (e.key === 'Enter') {
                    e.preventDefault();
                    selectHighlightedModalOption();
                }
            }
        });

        /**
         * Scroll row into view
         */
        function scrollRowIntoView(index) {
            const row = document.querySelector(`tr[data-row-index="${index}"]`);
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Handle assign with dropdown positioning
         */
        function handleAssignWithPosition(index) {
            console.log('üîç [MODAL DEBUG] handleAssignWithPosition called for index:', index);

            const assignBtn = document.getElementById(`assignBtn${index}`);
            if (!assignBtn) {
                console.log('‚ö†Ô∏è [MODAL DEBUG] No assign button found, calling handleAssign directly');
                handleAssign(index);
                return;
            }

            // Get button position
            const rect = assignBtn.getBoundingClientRect();
            const modal = document.getElementById('assignCategoryModal');
            const modalContent = modal.querySelector('.modal-content');

            console.log('‚úÖ [MODAL DEBUG] Opening modal - preparing to position');

            // Hide modal initially to prevent flash
            modalContent.style.opacity = '0';
            modalContent.style.transition = 'none';

            // Position modal as dropdown below the button
            modal.classList.add('active', 'positioned');

            console.log('üîç [MODAL DEBUG] Modal active class added, classList:', modal.classList.toString());

            // Use setTimeout to ensure modal is rendered before positioning
            setTimeout(() => {
                console.log('üìê [MODAL DEBUG] Positioning modal');

                // Calculate available space and modal dimensions
                // NOTE: rect is viewport-relative, and modal-overlay is position:fixed,
                // so we use viewport coordinates (no scrollY/scrollX needed)
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const modalWidth = Math.min(500, viewportWidth - 40);

                // Calculate max height based on available space (with padding)
                const spaceBelow = viewportHeight - rect.bottom - 20;
                const spaceAbove = rect.top - 20;
                const maxModalHeight = Math.min(viewportHeight * 0.7, Math.max(spaceBelow, spaceAbove));

                // Set max height first so we can get accurate offsetHeight
                modalContent.style.maxHeight = maxModalHeight + 'px';
                modalContent.style.overflowY = 'auto';

                // Force layout recalculation
                const modalHeight = modalContent.offsetHeight;

                let top, left;

                // Try to position below the button first
                if (spaceBelow >= modalHeight || spaceBelow >= spaceAbove) {
                    // Position below button (viewport coordinates)
                    top = rect.bottom + 5;

                    // Ensure it doesn't go off bottom of viewport
                    if (top + modalHeight > viewportHeight - 20) {
                        top = viewportHeight - modalHeight - 20;
                    }
                } else {
                    // Position above button (viewport coordinates)
                    top = rect.top - modalHeight - 5;

                    // Ensure it doesn't go off top of viewport
                    if (top < 10) {
                        top = 10;
                    }
                }

                // Position horizontally (align right edge with button)
                left = rect.right - modalWidth;

                // Adjust if modal goes off-screen horizontally
                if (left < 10) left = 10;
                if (left + modalWidth > viewportWidth - 10) {
                    left = viewportWidth - modalWidth - 10;
                }

                modalContent.style.position = 'absolute';
                modalContent.style.top = top + 'px';
                modalContent.style.left = left + 'px';
                modalContent.style.width = modalWidth + 'px';
                modalContent.style.margin = '0';

                // Show modal after positioning
                modalContent.style.opacity = '1';
                modalContent.style.transition = 'opacity 0.15s ease-in-out';

                console.log('‚úÖ [MODAL DEBUG] Modal positioned at:', {
                    top,
                    left,
                    modalHeight,
                    spaceBelow,
                    spaceAbove,
                    buttonRect: { top: rect.top, bottom: rect.bottom, left: rect.left, right: rect.right },
                    viewport: { width: viewportWidth, height: viewportHeight }
                });
            }, 10);

            // Now proceed with normal assignment flow
            currentEditingIndex = index;
            console.log('üîç [MODAL DEBUG] Active projects count:', activeProjects.length);

            if (activeProjects.length === 0) {
                console.log('‚ùå [MODAL DEBUG] No projects loaded, closing modal');
                alert('‚ö†Ô∏è No projects loaded. Please create a budget in the Grants page first.');
                closeAssignModal();
                return;
            }

            console.log('‚úÖ [MODAL DEBUG] Calling showProjectSelection()');
            showProjectSelection();
            modalKeyboardIndex = -1;
            console.log('‚úÖ [MODAL DEBUG] Modal setup complete');
        }

        /**
         * Select modal option by number key (1-9)
         */
        function selectModalOptionByIndex(index) {
            const options = document.querySelectorAll('.category-option');
            if (index >= 0 && index < options.length) {
                options[index].click();
            }
        }

        /**
         * Handle arrow navigation in modal
         */
        function handleModalArrowNavigation(direction) {
            const options = document.querySelectorAll('.category-option');
            if (options.length === 0) return;

            if (modalKeyboardIndex === -1) {
                modalKeyboardIndex = direction > 0 ? 0 : options.length - 1;
            } else {
                modalKeyboardIndex += direction;
                if (modalKeyboardIndex < 0) modalKeyboardIndex = 0;
                if (modalKeyboardIndex >= options.length) modalKeyboardIndex = options.length - 1;
            }

            updateModalHighlight();
            options[modalKeyboardIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        /**
         * Update modal option highlight
         */
        function updateModalHighlight() {
            const options = document.querySelectorAll('.category-option');
            options.forEach((opt, idx) => {
                opt.classList.remove('keyboard-selected');
                if (idx === modalKeyboardIndex) {
                    opt.classList.add('keyboard-selected');
                }
            });
        }

        /**
         * Select highlighted modal option
         */
        function selectHighlightedModalOption() {
            if (modalKeyboardIndex === -1) return;
            const options = document.querySelectorAll('.category-option');
            if (options[modalKeyboardIndex]) {
                options[modalKeyboardIndex].click();
            }
        }

        // ========================================
        // PROJECT UPDATE HELPERS
        // ========================================

        /**
         * Get category object from project by name
         */
        function getCategoryObject(project, categoryName) {
            // IUK Categories
            const categoryMap = {
                'Labour': project.labour,
                'Overheads': project.overheads,
                'Materials': project.materials,
                'Capital Usage': project.capitalUsage,
                'Subcontracting': project.subcontracting,
                'Travel': project.travel,
                'Other Costs': project.otherCosts
            };

            if (categoryMap[categoryName]) {
                return categoryMap[categoryName];
            }

            // Welsh Gov Categories
            if (project.welshGovData?.sections) {
                const sections = project.welshGovData.sections;
                const welshCategoryMap = {
                    'Capital Non-Standard': { items: sections.capital?.nonStandard || [] },
                    'Revenue Non-Standard': { items: sections.revenue?.nonStandard || [] },
                    'Revenue Standard': { items: sections.revenue?.standardCosts || [] },
                    'Item Breakdown Capital': { items: sections.itemBreakdown?.capital || [] },
                    'Item Breakdown Revenue': { items: sections.itemBreakdown?.revenue || [] }
                };

                return welshCategoryMap[categoryName];
            }

            return null;
        }

        /**
         * Find specific item in category by itemKey (e.g., "materials-2")
         */
        function findItemInCategory(category, itemKey) {
            if (!category) return null;

            const [catName, indexStr] = itemKey.split('-');

            // Handle "general" item keys for categories without line items
            if (indexStr === 'general') {
                console.log('üì¶ [FIND ITEM] General category assignment - returning category object');
                return category; // Return the category itself for general assignments
            }

            const index = parseInt(indexStr);

            // IUK categories
            if (catName === 'labour' && category.staff) return category.staff[index];
            if (catName === 'overheads') return category; // Overheads is single object
            if (catName === 'materials' && category.items) return category.items[index];
            if (catName === 'capitalUsage' && category.items) return category.items[index];
            if (catName === 'subcontracting' && category.contractors) return category.contractors[index];
            if (catName === 'travel' && category.trips) return category.trips[index];
            if (catName === 'otherCosts' && category.items) return category.items[index];

            // Welsh Gov categories (all use .items array)
            if (catName === 'capitalNonStandard' && category.items) return category.items[index];
            if (catName === 'revenueNonStandard' && category.items) return category.items[index];
            if (catName === 'revenueStandard' && category.items) return category.items[index];
            if (catName === 'itemBreakdownCapital' && category.items) return category.items[index];
            if (catName === 'itemBreakdownRevenue' && category.items) return category.items[index];

            return null;
        }

        /**
         * Save project back to IndexedDB
         */
        async function saveProjectToDB(project) {
            if (!db) await initIndexedDB();

            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(project);

                request.onsuccess = () => {
                    console.log('‚úÖ [DB] Project saved:', project.projectId);
                    resolve();
                };

                request.onerror = () => {
                    console.error('‚ùå [DB] Error saving project:', request.error);
                    reject(request.error);
                };
            });
        }

        // ========================================
        // UNASSIGNMENT FUNCTIONALITY
        // ========================================

        /**
         * Handle unassignment (right-click on assign button)
         */
        async function handleUnassign(transactionIndex, assignmentIndex = null) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.assignments || transaction.assignments.length === 0) {
                if (!transaction.assignedItemName) {
                    showToast('‚ö†Ô∏è This transaction has no assignments to remove', 'info');
                    return;
                }

                // Old format - convert and remove
                if (confirm('Remove assignment from this transaction?')) {
                    delete transaction.assignedCategory;
                    delete transaction.assignedItem;
                    delete transaction.assignedItemName;
                    delete transaction.assignedProject;

                    renderTransactions();
                    await saveTransactionsToStorage();
                    showToast('‚úÖ Assignment removed and saved', 'success');
                }
                return;
            }

            // If specific assignment index provided, remove that one directly
            if (assignmentIndex !== null && assignmentIndex >= 0 && assignmentIndex < transaction.assignments.length) {
                const assignment = transaction.assignments[assignmentIndex];
                await removeAssignmentFromProject(transaction, assignment);
                transaction.assignments.splice(assignmentIndex, 1);
                renderTransactions();
                await saveTransactionsToStorage();
                showToast('‚úÖ Assignment removed and saved', 'success');
                return;
            }

            // Fallback for old behavior (no assignment index provided)
            // New format - show list of assignments to remove
            if (transaction.assignments.length === 1) {
                if (confirm(`Remove assignment: ${transaction.assignments[0].itemName}?`)) {
                    await removeAssignmentFromProject(transaction, transaction.assignments[0]);
                    transaction.assignments = [];
                    renderTransactions();
                    await saveTransactionsToStorage();
                    showToast('‚úÖ Assignment removed, project updated, and saved', 'success');
                }
            } else {
                // Multiple assignments - let user choose
                const assignmentList = transaction.assignments.map((a, i) =>
                    `${i + 1}. ${a.itemName} (${a.percentage}%) - ${getQuarterName(a.quarter)}`
                ).join('\n');

                const choice = prompt(`Multiple assignments found:\n\n${assignmentList}\n\nEnter number to remove (or 'all' to remove all):`);

                if (choice === 'all') {
                    for (const assignment of transaction.assignments) {
                        await removeAssignmentFromProject(transaction, assignment);
                    }
                    transaction.assignments = [];
                    renderTransactions();
                    await saveTransactionsToStorage();
                    showToast('‚úÖ All assignments removed and saved', 'success');
                } else {
                    const index = parseInt(choice) - 1;
                    if (index >= 0 && index < transaction.assignments.length) {
                        await removeAssignmentFromProject(transaction, transaction.assignments[index]);
                        transaction.assignments.splice(index, 1);
                        renderTransactions();
                        await saveTransactionsToStorage();
                        showToast('‚úÖ Assignment removed and saved', 'success');
                    }
                }
            }
        }

        /**
         * Remove assignment cost from project's quarterly costs
         */
        async function removeAssignmentFromProject(transaction, assignment) {
            console.log('üîÑ [UNASSIGN] Removing assignment from project:', assignment);

            try {
                // Load project from DB
                if (!db) await initIndexedDB();

                const project = await new Promise((resolve, reject) => {
                    const trans = db.transaction([STORE_NAME], 'readonly');
                    const store = trans.objectStore(STORE_NAME);
                    const request = store.get(assignment.projectId);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (!project) {
                    console.error('‚ùå [UNASSIGN] Project not found:', assignment.projectId);
                    return;
                }

                // Calculate amount to subtract
                const transAmount = parseAmount(transaction.spent || transaction.received);
                const amountToRemove = (transAmount * assignment.percentage) / 100;

                console.log(`üí∞ [UNASSIGN] Removing ¬£${amountToRemove} from ${assignment.category} - ${assignment.itemName} Q${assignment.quarter}`);

                // Find the item and update quarterly costs
                const category = getCategoryObject(project, assignment.category);
                const item = findItemInCategory(category, assignment.itemKey);

                if (item && item.quarterlyCosts) {
                    const quarterKey = `q${assignment.quarter}`;
                    item.quarterlyCosts[quarterKey] = (item.quarterlyCosts[quarterKey] || 0) - amountToRemove;

                    console.log(`‚úÖ [UNASSIGN] Updated ${quarterKey}:`, item.quarterlyCosts);

                    // Save project back to DB
                    project.lastModified = new Date().toISOString();
                    await saveProjectToDB(project);
                    console.log('‚úÖ [UNASSIGN] Project saved');
                }

            } catch (error) {
                console.error('‚ùå [UNASSIGN] Error removing assignment:', error);
            }
        }

        // ========================================
        // VOICE RECORDING FUNCTIONALITY
        // ========================================

        // Toast notification function
        function showToast(message, type = 'info', position = null) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if (type) toast.classList.add(type);

            // Position toast near the button if coordinates provided
            if (position && position.x !== undefined && position.y !== undefined) {
                // Position toast near the click, offset slightly to the right and down
                const offsetX = 10;
                const offsetY = 10;

                // Calculate position, ensuring it stays within viewport
                let left = position.x + offsetX;
                let top = position.y + offsetY;

                // Adjust if toast would go off-screen (estimate toast width as 400px)
                if (left + 400 > window.innerWidth) {
                    left = position.x - 400 - offsetX; // Position to the left instead
                }
                if (top + 100 > window.innerHeight) {
                    top = position.y - 100 - offsetY; // Position above instead
                }

                // Ensure minimum margins
                left = Math.max(10, Math.min(left, window.innerWidth - 410));
                top = Math.max(10, Math.min(top, window.innerHeight - 110));

                toast.style.left = left + 'px';
                toast.style.top = top + 'px';
                toast.style.bottom = 'auto';
                toast.style.right = 'auto';
                toast.classList.add('positioned');
            } else {
                // Default position (bottom right)
                toast.style.left = '';
                toast.style.top = '';
                toast.style.bottom = '';
                toast.style.right = '';
                toast.classList.remove('positioned');
            }

            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        // Toggle voice recording for specific row
        async function toggleRowVoiceRecording(rowIndex) {
            if (isRecording && currentRecordingRowIndex === rowIndex) {
                stopRecording();
            } else {
                await startRowRecording(rowIndex);
            }
        }

        // Start recording for specific row
        async function startRowRecording(rowIndex) {
            // If already recording another row, stop it first
            if (isRecording) {
                stopRecording();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const micBtn = document.getElementById(`micBtn${rowIndex}`);
            if (!micBtn) return;

            try {
                // Reuse existing stream or create new one (permission requested only once)
                if (!microphoneStream) {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                const stream = microphoneStream;

                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                currentRecordingRowIndex = rowIndex;

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    // Keep stream alive - don't stop tracks
                    // stream.getTracks().forEach(track => track.stop());

                    micBtn.classList.remove('recording');
                    micBtn.textContent = 'üé§';

                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        await transcribeAudio(audioBlob);
                    } else {
                        currentRecordingRowIndex = null;
                    }
                };

                mediaRecorder.start();
                isRecording = true;

                micBtn.classList.add('recording');
                micBtn.textContent = '‚èπÔ∏è';

                showToast('üé§ Recording... Click again to stop', 'info');

                // Auto-stop after MAX_RECORDING_TIME
                recordingTimeout = setTimeout(() => {
                    if (isRecording) {
                        showToast('‚è±Ô∏è Max recording time reached (30s)', 'info');
                        stopRecording();
                    }
                }, MAX_RECORDING_TIME);

            } catch (error) {
                console.error('Microphone error:', error);
                showToast('‚ùå Microphone access denied. Please allow microphone access.', 'error');
                micBtn.classList.remove('recording');
                micBtn.textContent = 'üé§';
                currentRecordingRowIndex = null;
            }
        }

        // Stop recording
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                clearTimeout(recordingTimeout);
                mediaRecorder.stop();
                isRecording = false;
            }
        }

        // Transcribe audio using Whisper API
        async function transcribeAudio(audioBlob) {
            if (currentRecordingRowIndex === null) {
                showToast('‚ùå No row selected for voice note', 'error');
                return;
            }

            const micBtn = document.getElementById(`micBtn${currentRecordingRowIndex}`);
            if (!micBtn) return;

            // Check for API key
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                showToast('‚ùå OpenAI API Key required for voice transcription', 'error');
                micBtn.classList.remove('processing');
                micBtn.disabled = false;
                micBtn.textContent = 'üé§';
                currentRecordingRowIndex = null;
                return;
            }

            micBtn.classList.add('processing');
            micBtn.disabled = true;
            micBtn.textContent = '‚è≥';

            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');

                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Transcription failed: ${response.status}`);
                }

                const data = await response.json();
                const transcription = data.text;

                console.log('Transcription:', transcription);

                if (!transcription || transcription.trim().length === 0) {
                    showToast('‚ùå Could not understand audio. Please try again.', 'error');
                    micBtn.classList.remove('processing');
                    micBtn.disabled = false;
                    micBtn.textContent = 'üé§';
                    currentRecordingRowIndex = null;
                    return;
                }

                // Show transcription modal for review
                document.getElementById('transcriptionText').value = transcription;
                document.getElementById('transcriptionModal').classList.add('show');

            } catch (error) {
                console.error('Transcription error:', error);
                showToast('‚ùå Transcription failed. Please try again.', 'error');
                currentRecordingRowIndex = null;
            } finally {
                micBtn.classList.remove('processing');
                micBtn.disabled = false;
                micBtn.textContent = 'üé§';
            }
        }

        // Close transcription modal
        function closeTranscriptionModal() {
            document.getElementById('transcriptionModal').classList.remove('show');
            document.getElementById('transcriptionText').value = '';
            currentRecordingRowIndex = null; // Reset recording row
        }

        // Process transcription and save as voice note
        async function processTranscription() {
            const transcription = document.getElementById('transcriptionText').value.trim();

            if (!transcription) {
                showToast('‚ùå No transcription to process', 'error');
                return;
            }

            if (currentRecordingRowIndex === null) {
                showToast('‚ùå No row selected for voice note', 'error');
                closeTranscriptionModal();
                return;
            }

            // Save the transcription directly as a voice note for the row
            const rowIndex = currentRecordingRowIndex;
            allTransactions[rowIndex].voiceNotes = transcription;

            // Re-render to show the note
            renderTransactions();
            updateSummary();

            showToast(`‚úÖ Voice note added to transaction`, 'success');

            closeTranscriptionModal();
        }

        // ========================================
        // TEXT POPUP FOR LONG DESCRIPTIONS/DETAILS
        // ========================================

        function showTextPopup(fieldName, rowIndex) {
            const transaction = allTransactions[rowIndex];
            if (!transaction) return;

            const modal = document.getElementById('textPopupModal');
            const title = document.getElementById('textPopupTitle');
            const content = document.getElementById('textPopupContent');

            // Get the appropriate text based on field name
            let text = '';
            if (fieldName === 'description') {
                text = transaction.description || '';
                title.textContent = 'Full Description';
            } else if (fieldName === 'detail') {
                text = transaction.detail || transaction.manualDescription || '';
                title.textContent = 'Full Detail';
            }

            content.textContent = text;
            modal.style.display = 'flex';
        }

        function closeTextPopup() {
            document.getElementById('textPopupModal').style.display = 'none';
        }

        // Close popup when clicking outside
        document.getElementById('textPopupModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTextPopup();
            }
        });

        // ========================================
        // GMAIL API AUTHENTICATION (Google Identity Services)
        // ========================================

        // Initialize GAPI client
        function gapiLoaded() {
            gapi.load('client', async () => {
                await gapi.client.init({
                    apiKey: GOOGLE_API_KEY,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'],
                });
                gapiInited = true;
                console.log('GAPI client initialized');
                maybeEnableButtons();
            });
        }

        // Initialize GIS client
        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GMAIL_SCOPES,
                callback: (response) => {
                    if (response.error !== undefined) {
                        console.error('GIS error:', response);
                        showToast('‚ùå Gmail authentication failed', 'error');
                        return;
                    }
                    handleAuthSuccess(response.access_token);
                },
            });
            gisInited = true;
            console.log('GIS client initialized');
            maybeEnableButtons();
        }

        // Enable buttons when both libraries are loaded
        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                updateGmailStatus();
            }
        }

        // Initialize Google Auth when page loads
        function initializeGoogleAuth() {
            // Load GAPI
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            } else {
                window.addEventListener('load', () => {
                    setTimeout(gapiLoaded, 100);
                });
            }

            // Load GIS
            if (typeof google !== 'undefined' && google.accounts) {
                gisLoaded();
            } else {
                window.addEventListener('load', () => {
                    setTimeout(gisLoaded, 100);
                });
            }
        }

        // Sign in to Gmail (add new account)
        async function signInToGmail() {
            if (!tokenClient) {
                showToast('‚ö†Ô∏è Google API not initialized yet. Please wait...', 'error');
                return;
            }

            // Request an access token (will prompt for account selection)
            tokenClient.requestAccessToken({ prompt: 'select_account' });
        }

        // Sign out from specific Gmail account
        function signOutFromAccount(email) {
            const accountIndex = gmailAccounts.findIndex(acc => acc.email === email);
            if (accountIndex !== -1) {
                const account = gmailAccounts[accountIndex];
                if (account.accessToken) {
                    google.accounts.oauth2.revoke(account.accessToken, () => {
                        console.log('Access token revoked for:', email);
                    });
                }
                gmailAccounts.splice(accountIndex, 1);
                saveGmailAccountsToStorage(); // Persist removal
                updateGmailStatus();
                showToast(`‚úÖ Signed out: ${email}`, 'success');
            }
        }

        // Sign out from all Gmail accounts
        function signOutFromGmail() {
            gmailAccounts.forEach(account => {
                if (account.accessToken) {
                    google.accounts.oauth2.revoke(account.accessToken, () => {
                        console.log('Access token revoked for:', account.email);
                    });
                }
            });
            gmailAccounts = [];
            saveGmailAccountsToStorage(); // Clear saved accounts
            updateGmailStatus();
            showToast('‚úÖ Signed out from all accounts', 'success');
        }

        async function handleAuthSuccess(accessToken) {
            console.log('Authentication successful, token received');

            // Calculate token expiry time (Google OAuth2 tokens expire after 1 hour)
            // Set expiry to 55 minutes from now to be safe (account for clock skew)
            const tokenExpiresAt = Date.now() + (55 * 60 * 1000); // 55 minutes in milliseconds
            const expiryDate = new Date(tokenExpiresAt);
            console.log(`üïê Token will expire at: ${expiryDate.toLocaleTimeString()}`);

            try {
                // Get user info
                const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`
                    }
                });

                if (response.ok) {
                    const userInfo = await response.json();
                    const email = userInfo.email;

                    // Check if account already exists
                    const existingAccount = gmailAccounts.find(acc => acc.email === email);
                    if (existingAccount) {
                        // Update token for existing account
                        existingAccount.accessToken = accessToken;
                        existingAccount.tokenExpiresAt = tokenExpiresAt;
                        showToast(`‚úÖ Reconnected: ${email}`, 'success');
                    } else {
                        // Add new account (selected by default)
                        gmailAccounts.push({
                            email: email,
                            accessToken: accessToken,
                            tokenExpiresAt: tokenExpiresAt,
                            selected: true
                        });
                        showToast(`‚úÖ Connected: ${email}`, 'success');
                    }

                    console.log('User info retrieved:', email);
                } else {
                    console.warn('Could not get user info, but token is valid');
                    // Add account without email
                    gmailAccounts.push({
                        email: 'Account ' + (gmailAccounts.length + 1),
                        accessToken: accessToken,
                        tokenExpiresAt: tokenExpiresAt,
                        selected: true
                    });
                    showToast('‚úÖ Connected to Gmail', 'success');
                }
            } catch (error) {
                console.error('Error getting user info:', error);
                // Even if we can't get user info, we have the token
                gmailAccounts.push({
                    email: 'Account ' + (gmailAccounts.length + 1),
                    accessToken: accessToken,
                    tokenExpiresAt: tokenExpiresAt,
                    selected: true
                });
                showToast('‚úÖ Connected to Gmail', 'success');
            }

            saveGmailAccountsToStorage(); // Persist to localStorage (including token and expiry)
            updateGmailStatus();
        }

        function updateGmailStatus() {
            const statusDiv = document.getElementById('gmailConnectionStatus');
            const accountsList = document.getElementById('gmailAccountsList');
            const connectBtn = document.getElementById('gmailConnectBtn');
            const signOutBtn = document.getElementById('gmailSignOutBtn');

            if (gmailAccounts.length === 0) {
                statusDiv.innerHTML = '<span style="color: #dc2626;">‚ùå Not connected</span>';
                accountsList.innerHTML = '';
                if (connectBtn) connectBtn.style.display = 'inline-flex';
                if (signOutBtn) signOutBtn.style.display = 'none';
            } else {
                const selectedCount = gmailAccounts.filter(acc => acc.selected).length;
                statusDiv.innerHTML = `<span style="color: #059669;">${gmailAccounts.length} account${gmailAccounts.length > 1 ? 's' : ''} (${selectedCount} selected)</span>`;

                let html = '';

                gmailAccounts.forEach((account, index) => {
                    // Check if token is missing or expired
                    const now = Date.now();
                    const isTokenExpired = account.tokenExpiresAt && account.tokenExpiresAt < now;
                    const needsAuth = !account.accessToken || isTokenExpired;

                    let statusIndicator, tooltipText;
                    if (!account.accessToken) {
                        statusIndicator = '‚ö†Ô∏è';
                        tooltipText = 'Not authenticated';
                    } else if (isTokenExpired) {
                        statusIndicator = 'üïê';
                        tooltipText = 'Token expired - click Reconnect';
                    } else {
                        statusIndicator = '‚úÖ';
                        const expiryDate = new Date(account.tokenExpiresAt);
                        tooltipText = `Token valid until ${expiryDate.toLocaleTimeString()}`;
                    }

                    html += `
                        <div style="display: flex; align-items: center; gap: 5px; background: ${needsAuth ? '#fff3cd' : '#f8f9fa'}; padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; border: 1px solid ${account.selected ? '#3AAFA9' : '#e9ecef'};" title="${tooltipText}">
                            <input
                                type="checkbox"
                                id="gmailAccount${index}"
                                ${account.selected ? 'checked' : ''}
                                ${needsAuth ? 'disabled' : ''}
                                onchange="toggleAccountSelection(${index})"
                                style="cursor: ${needsAuth ? 'not-allowed' : 'pointer'}; width: 14px; height: 14px; margin: 0;"
                            >
                            <label for="gmailAccount${index}" style="flex: 1; cursor: pointer; font-size: 11px; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${statusIndicator} ${escapeHtml(account.email.split('@')[0])}
                            </label>
                            ${needsAuth ? `
                                <button
                                    onclick="reconnectAccount(${index})"
                                    class="modal-btn modal-btn-primary"
                                    style="margin: 0; padding: 2px 6px; font-size: 10px;">
                                    Reconnect
                                </button>
                            ` : ''}
                            <button
                                onclick="signOutFromAccount('${escapeHtml(account.email)}')"
                                class="modal-btn modal-btn-secondary"
                                style="margin: 0; padding: 2px 6px; font-size: 10px;">
                                ‚úï
                            </button>
                        </div>
                    `;
                });

                accountsList.innerHTML = html;

                if (connectBtn) {
                    connectBtn.innerHTML = '+ Add Account';
                }
                if (signOutBtn) signOutBtn.style.display = 'none';
            }
        }

        // Reconnect a specific account that needs re-authentication
        function reconnectAccount(index) {
            if (!tokenClient) {
                showToast('‚ùå Gmail client not initialized', 'error');
                return;
            }

            // Store the index we're reconnecting so we can match it in handleAuthSuccess
            window.reconnectingAccountIndex = index;

            // Trigger OAuth flow
            tokenClient.requestAccessToken({ prompt: 'select_account' });
        }

        // Toggle account selection for searching
        function toggleAccountSelection(index) {
            if (gmailAccounts[index]) {
                gmailAccounts[index].selected = !gmailAccounts[index].selected;
                saveGmailAccountsToStorage(); // Persist selection state
                updateGmailStatus();
            }
        }

        // ========================================
        // GMAIL SEARCH & EMAIL PARSING
        // ========================================

        async function searchEmailsForTransaction(transaction) {
            const searchQueries = buildSearchQueries(transaction);
            const selectedAccounts = gmailAccounts.filter(acc => acc.selected);

            if (selectedAccounts.length === 0) {
                showToast('‚ö†Ô∏è No accounts selected for search', 'error');
                return [];
            }

            let allResults = [];

            // Search across all selected accounts
            for (const account of selectedAccounts) {
                console.log(`Searching account: ${account.email}`);

                for (const query of searchQueries) {
                    try {
                        const results = await searchGmail(query, account.accessToken);
                        // Tag results with account email
                        results.forEach(msg => msg.accountEmail = account.email);
                        allResults = allResults.concat(results);
                    } catch (error) {
                        console.error(`Search error for ${account.email}, query:`, query, error);
                    }
                }
            }

            // Deduplicate by message ID + account email
            const uniqueResults = [];
            const seenIds = new Set();
            for (const msg of allResults) {
                const uniqueKey = `${msg.accountEmail}:${msg.id}`;
                if (!seenIds.has(uniqueKey)) {
                    seenIds.add(uniqueKey);
                    uniqueResults.push(msg);
                }
            }

            console.log(`Found ${uniqueResults.length} unique results across ${selectedAccounts.length} account(s)`);
            return uniqueResults;
        }

        function buildSearchQueries(transaction) {
            const queries = [];
            const amount = parseAmount(transaction.spent || transaction.received);
            const date = new Date(transaction.date);

            // Date range: ¬±3 days from transaction date
            const afterDate = formatGmailDate(new Date(date.getTime() - 3 * 24 * 60 * 60 * 1000));
            const beforeDate = formatGmailDate(new Date(date.getTime() + 3 * 24 * 60 * 60 * 1000));

            // Extract merchant/vendor name from description
            const merchant = extractMerchantName(transaction.description);

            // Query 1: Merchant name + date range + common invoice keywords
            if (merchant) {
                queries.push(
                    `{from:${merchant} OR subject:${merchant}} ` +
                    `{invoice OR receipt OR order OR confirmation OR payment} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            }

            // Query 2: Amount-based search (format variations)
            const amountVariations = [
                amount.toFixed(2),
                '¬£' + amount.toFixed(2),
                amount.toFixed(2).replace('.', ',') // European format
            ];

            amountVariations.forEach(amt => {
                queries.push(
                    `{${amt}} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            });

            // Query 3: Description keywords + date
            const keywords = extractKeywords(transaction.description);
            if (keywords.length > 0) {
                queries.push(
                    `{${keywords.join(' OR ')}} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            }

            return queries.slice(0, 3); // Limit to first 3 queries to avoid too many searches
        }

        function extractMerchantName(description) {
            // Remove common payment processor prefixes
            let cleaned = description
                .replace(/^(CARD PAYMENT TO|PAYMENT TO|PURCHASE AT|POS|DEBIT CARD|PAYPAL|STRIPE)/i, '')
                .trim();

            // Extract first significant word(s)
            const words = cleaned.split(/\s+/).filter(w => w.length > 2);
            return words.slice(0, 2).join(' '); // First 2 words
        }

        function extractKeywords(description) {
            const stopWords = ['the', 'and', 'to', 'at', 'from', 'for', 'on', 'in', 'card', 'payment'];
            return description.toLowerCase()
                .split(/\s+/)
                .filter(word => word.length > 3 && !stopWords.includes(word))
                .slice(0, 5); // Top 5 keywords
        }

        function formatGmailDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}/${month}/${day}`;
        }

        async function searchGmail(query, accessToken) {
            try {
                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.list({
                    userId: 'me',
                    q: query,
                    maxResults: 10
                });

                return response.result.messages || [];
            } catch (error) {
                console.error('Gmail search error:', error);
                return [];
            }
        }

        async function extractPDFsFromEmail(messageId, accessToken) {
            try {
                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.get({
                    userId: 'me',
                    id: messageId,
                    format: 'full'
                });

                const message = response.result;
                const pdfs = [];

                // Parse email parts recursively
                function extractAttachments(parts) {
                    if (!parts) return;

                    parts.forEach(part => {
                        if (part.mimeType === 'application/pdf') {
                            pdfs.push({
                                filename: part.filename,
                                attachmentId: part.body.attachmentId,
                                size: part.body.size,
                                messageId: messageId
                            });
                        }

                        if (part.parts) {
                            extractAttachments(part.parts);
                        }
                    });
                }

                extractAttachments(message.payload.parts);
                return pdfs;
            } catch (error) {
                console.error('Error extracting PDFs:', error);
                return [];
            }
        }

        async function downloadPDFAttachment(messageId, attachmentId, accessToken) {
            try {
                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.attachments.get({
                    userId: 'me',
                    messageId: messageId,
                    id: attachmentId
                });

                // Gmail returns data in URL-safe base64 format
                const data = response.result.data
                    .replace(/-/g, '+')
                    .replace(/_/g, '/');

                // Convert base64 to Blob
                const binaryString = atob(data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                return new Blob([bytes], { type: 'application/pdf' });
            } catch (error) {
                console.error('Error downloading attachment:', error);
                return null;
            }
        }

        // ========================================
        // PDF STORAGE IN INDEXEDDB
        // ========================================

        async function saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId = null) {
            if (!db) await initIndexedDB();

            const invoiceData = {
                transactionIndex: transactionIndex,
                filename: filename,
                pdfBlob: pdfBlob,
                size: pdfBlob.size,
                uploadDate: new Date().toISOString(),
                source: messageId ? 'gmail' : 'manual',
                gmailMessageId: messageId,
                extractedText: null,
                aiDescription: null
            };

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const request = store.add(invoiceData);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        console.log('Invoice saved with ID:', request.result);
                        resolve(request.result);
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error saving invoice:', error);
                return null;
            }
        }

        async function getInvoicesForTransaction(transactionIndex) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readonly');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const index = store.index('transactionIndex');
                const request = index.getAll(transactionIndex);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error getting invoices:', error);
                return [];
            }
        }

        async function updateInvoiceText(invoiceId, text) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.extractedText = text;
                        store.put(invoice);
                    }
                };
            } catch (error) {
                console.error('Error updating invoice text:', error);
            }
        }

        async function updateInvoiceWithAIDescription(invoiceId, description) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.aiDescription = description;
                        store.put(invoice);
                    }
                };
            } catch (error) {
                console.error('Error updating invoice:', error);
            }
        }

        // ========================================
        // PDF TEXT EXTRACTION (PDF.js + OCR)
        // ========================================

        async function extractTextFromPDF(pdfBlob) {
            try {
                const arrayBuffer = await pdfBlob.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                let fullText = '';
                const totalPages = pdf.numPages;

                console.log(`Processing PDF with ${totalPages} page(s)...`);

                for (let pageNum = 1; pageNum <= Math.min(totalPages, 5); pageNum++) { // Limit to first 5 pages
                    const page = await pdf.getPage(pageNum);

                    // Try text extraction first (for text-based PDFs)
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');

                    if (pageText.trim().length > 50) {
                        // Text-based PDF
                        fullText += `\n--- Page ${pageNum} ---\n` + pageText;
                    } else {
                        // Scanned PDF - use OCR
                        fullText += `\n--- Page ${pageNum} (OCR) ---\n`;
                        const ocrText = await performOCR(page);
                        fullText += ocrText;
                    }
                }

                return fullText.trim();
            } catch (error) {
                console.error('PDF extraction error:', error);
                showToast('‚ùå Failed to extract text from PDF', 'error');
                return null;
            }
        }

        async function performOCR(pdfPage) {
            try {
                const viewport = pdfPage.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;

                // Perform OCR on canvas
                const { data: { text } } = await Tesseract.recognize(
                    canvas,
                    'eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                            }
                        }
                    }
                );

                return text;
            } catch (error) {
                console.error('OCR error:', error);
                return '';
            }
        }

        // ========================================
        // AI DESCRIPTION GENERATION
        // ========================================

        async function generateDescriptionFromInvoice(invoiceText, transaction) {
            // Check for API key
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                showToast('‚ùå OpenAI API Key required for AI description generation', 'error');
                return null;
            }

            const prompt = `You are a financial transaction classifier. Based on the invoice/receipt text below, generate a CONCISE description of the purchase in 2-10 words.

Transaction Details:
- Date: ${transaction.date}
- Amount: ¬£${transaction.spent || transaction.received}
- Original Description: ${transaction.description}

Invoice/Receipt Text:
${invoiceText.substring(0, 4000)}

IMPORTANT: Return ONLY a concise 2-10 word description. Focus on what was purchased, not who sold it.

Examples:
- "Google Workspace subscription"
- "Office supplies and stationery"
- "Website hosting services"
- "Marketing consultation"

Description:`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a financial assistant that creates concise 2-10 word purchase descriptions.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 50,
                        temperature: 0.2
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('AI description generation error:', error);
                showToast('‚ö†Ô∏è AI description generation failed', 'error');
                return null;
            }
        }

        // ========================================
        // STRUCTURED DATA EXTRACTION FROM INVOICE
        // ========================================

        /**
         * Extract structured data (company, amount, date) from invoice text using AI
         */
        async function extractStructuredDataFromInvoice(invoiceText) {
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                console.warn('‚ö†Ô∏è No API key available for structured extraction');
                return null;
            }

            const prompt = `Extract the following information from this invoice/receipt text and return it as a JSON object:

Required fields:
- company: The company/vendor name (string)
- amount: The total amount (number, no currency symbols)
- date: The invoice/transaction date in YYYY-MM-DD format (string)

Invoice Text:
${invoiceText.substring(0, 4000)}

Return ONLY a valid JSON object with these three fields. If a field cannot be found, use null.
Example: {"company": "Acme Corp", "amount": 123.45, "date": "2025-01-15"}`;

            try {
                console.log('üîç [EXTRACT] Sending invoice text to ChatGPT for structured extraction...');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a data extraction assistant. Always return valid JSON only, no additional text.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 150,
                        temperature: 0.1,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content.trim());

                console.log('‚úÖ [EXTRACT] Structured data extracted:', extractedData);
                return extractedData;

            } catch (error) {
                console.error('‚ùå [EXTRACT] Structured extraction failed:', error);
                return null;
            }
        }

        /**
         * Validate extracted invoice data against transaction entry using AI
         */
        async function validateInvoiceData(extractedData, transaction) {
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                console.warn('‚ö†Ô∏è No API key available for validation');
                return null;
            }

            // Parse transaction amount
            const transactionAmountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').trim();
            const transactionAmount = parseFloat(transactionAmountStr) || 0;

            // Parse extracted amount (handle both string and number)
            const extractedAmount = parseFloat(extractedData.amount) || 0;

            // Client-side validation checks for override
            const amountDifference = Math.abs(transactionAmount - extractedAmount);
            const clientSideAmountMatch = amountDifference <= 0.02; // Allow 2p tolerance for rounding

            // Client-side date validation (within 5 days)
            let clientSideDateMatch = false;
            let dateDaysDifference = null;
            if (extractedData.date && transaction.date) {
                try {
                    // Parse extracted date (usually YYYY-MM-DD from AI)
                    const extractedDate = new Date(extractedData.date);

                    // Parse transaction date - handle DD/MM/YYYY format
                    let transactionDate;
                    if (transaction.date.includes('/')) {
                        // DD/MM/YYYY format
                        const [day, month, year] = transaction.date.split('/');
                        transactionDate = new Date(year, month - 1, day); // month is 0-indexed
                    } else {
                        // Assume ISO format YYYY-MM-DD
                        transactionDate = new Date(transaction.date);
                    }

                    const timeDiff = Math.abs(extractedDate - transactionDate);
                    dateDaysDifference = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                    clientSideDateMatch = dateDaysDifference <= 5; // Within 5 days = match

                    console.log('üìÖ [VALIDATE] Date parsing DETAILED:', {
                        transactionRaw: transaction.date,
                        transactionParsed: transactionDate.toISOString().split('T')[0],
                        transactionDateObj: transactionDate,
                        extractedRaw: extractedData.date,
                        extractedParsed: extractedDate.toISOString().split('T')[0],
                        extractedDateObj: extractedDate,
                        timeDiffMS: timeDiff,
                        daysDifference: dateDaysDifference,
                        within5Days: clientSideDateMatch
                    });
                } catch (e) {
                    console.warn('Could not parse dates for client-side validation:', e);
                }
            }

            console.log('üí∞ [VALIDATE] Amount comparison:', {
                transaction: transactionAmount,
                extracted: extractedAmount,
                difference: amountDifference,
                clientSideMatch: clientSideAmountMatch
            });

            console.log('üìÖ [VALIDATE] Date comparison:', {
                transaction: transaction.date,
                extracted: extractedData.date,
                daysDifference: dateDaysDifference,
                clientSideMatch: clientSideDateMatch
            });

            const prompt = `You are a financial data validator. Compare the extracted invoice data with the transaction entry and determine if they match.

Extracted from Invoice:
- Company: ${extractedData.company || 'Not found'}
- Amount: ¬£${extractedData.amount || 'Not found'}
- Date: ${extractedData.date || 'Not found'}

Transaction Entry:
- Description/Company: ${transaction.description || 'Not provided'}
- Amount: ¬£${transactionAmount.toFixed(2)}
- Date: ${transaction.date || 'Not provided'}

Analyze each field and return a JSON object with:
{
  "companyMatch": true/false,
  "amountMatch": true/false,
  "dateMatch": true/false,
  "companyReason": "2-10 word explanation",
  "amountReason": "2-10 word explanation",
  "dateReason": "2-10 word explanation",
  "overallConfidence": "high"/"medium"/"low",
  "recommendation": "attach"/"review"/"reject"
}

IMPORTANT: Keep all reason fields concise (2-10 words maximum). Examples:
- "Exact match"
- "Names similar"
- "Within tolerance"
- "3 days difference"

Consider:
- Company: Allow partial matches, common abbreviations, similar names
- Amount: Match if difference is ‚â§ ¬£0.02 (to account for rounding)
- Date: Should be within ¬±5 days of transaction date

Return ONLY valid JSON.`;

            try {
                console.log('üîç [VALIDATE] Sending data to ChatGPT for validation...');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a financial validation assistant. Always return valid JSON only, no additional text.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 300,
                        temperature: 0.1,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const validationResult = JSON.parse(data.choices[0].message.content.trim());

                // CLIENT-SIDE OVERRIDE: If amounts match within tolerance, override AI if it says they don't match
                if (clientSideAmountMatch && !validationResult.amountMatch) {
                    console.log('‚ö†Ô∏è [VALIDATE] AI said amounts don\'t match, but client-side check says they do. Overriding AI decision.');
                    validationResult.amountMatch = true;
                    validationResult.amountReason = `Amounts match within tolerance (difference: ¬£${amountDifference.toFixed(2)})`;
                }

                // CLIENT-SIDE OVERRIDE: If dates within 5 days, override AI if it says they don't match
                if (clientSideDateMatch && !validationResult.dateMatch) {
                    console.log('‚ö†Ô∏è [VALIDATE] AI said dates don\'t match, but client-side check says they do (within 5 days). Overriding AI decision.');
                    console.log('üìÖ [OVERRIDE] Date override details:', {
                        clientSideDateMatch,
                        dateDaysDifference,
                        aiDateMatch: validationResult.dateMatch,
                        overridingTo: true
                    });
                    validationResult.dateMatch = true;
                    validationResult.dateReason = `Dates match within tolerance (${dateDaysDifference} day(s) difference)`;
                }

                // Log final validation state
                console.log('üèÅ [VALIDATE] Final validation result:', {
                    companyMatch: validationResult.companyMatch,
                    amountMatch: validationResult.amountMatch,
                    dateMatch: validationResult.dateMatch,
                    recommendation: validationResult.recommendation
                });

                // Update overall recommendation if all fields now match
                if (validationResult.companyMatch && validationResult.amountMatch && validationResult.dateMatch) {
                    validationResult.recommendation = 'attach';
                    validationResult.overallConfidence = 'high';
                }

                console.log('‚úÖ [VALIDATE] Validation complete:', validationResult);
                return validationResult;

            } catch (error) {
                console.error('‚ùå [VALIDATE] Validation failed:', error);
                return null;
            }
        }

        // ========================================
        // INTELLIGENT INVOICE SEARCH - PHASE 1
        // ========================================

        /**
         * Build comprehensive search context from transaction
         */
        function buildTransactionContext(transaction, transactionIndex) {
            console.log('üîç [CONTEXT] Building search context for:', transaction);

            // Extract core data - strip ¬£ symbol first
            const amountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').trim();
            const amount = parseFloat(amountStr) || 0;
            const isSpending = transaction.spent && transaction.spent.trim();

            console.log('üí∞ [CONTEXT] Amount parsing:', {
                original: transaction.spent || transaction.received,
                cleaned: amountStr,
                parsed: amount
            });

            // Clean merchant name from description
            const merchantInfo = extractMerchantName(transaction.description);

            // Generate amount variations
            const amountFormats = generateAmountFormats(amount);

            // Extract keywords from assignments
            const contextKeywords = [];
            if (transaction.assignedItemName) {
                contextKeywords.push(transaction.assignedItemName);
            }
            if (transaction.assignments && transaction.assignments.length > 0) {
                transaction.assignments.forEach(a => {
                    if (a.itemName) contextKeywords.push(a.itemName);
                });
            }

            // Include user voice notes
            const userNotes = transaction.voiceNotes ? transaction.voiceNotes.trim() : '';

            const context = {
                // Core data
                index: transactionIndex,
                date: parseTransactionDate(transaction.date),
                amount: amount,
                description: transaction.description,
                fromTo: transaction.fromTo || null,
                bank: transaction.bank,
                isSpending: isSpending,

                // Extracted/derived
                merchantName: merchantInfo.cleaned,
                merchantOriginal: merchantInfo.original,
                merchantVariants: merchantInfo.variants,

                // Amount formats
                amountFormats: amountFormats,

                // User context
                userContext: contextKeywords.join(', '),
                userNotes: userNotes,

                // Temporal
                dayOfWeek: getDayOfWeek(transaction.date),

                // Search hints
                expectedDocumentTypes: isSpending
                    ? ['invoice', 'receipt', 'order confirmation', 'payment confirmation']
                    : ['receipt', 'payment received', 'transfer confirmation']
            };

            console.log('‚úÖ [CONTEXT] Built context:', context);
            return context;
        }

        /**
         * Extract and clean merchant name from description
         */
        function extractMerchantName(description) {
            if (!description) return { original: '', cleaned: '', variants: [] };

            let cleaned = description.trim();

            // Remove common prefixes
            const prefixes = [
                'CARD PAYMENT TO ',
                'CARD PAYMENT ',
                'DIRECT DEBIT TO ',
                'DIRECT DEBIT ',
                'PAYPAL \\*',
                'PAYPAL ',
                'STANDING ORDER TO ',
                'FASTER PAYMENT TO ',
                'PAYMENT TO ',
                'TRANSFER TO ',
                'DD ',
                'SO '
            ];

            for (const prefix of prefixes) {
                const regex = new RegExp('^' + prefix, 'i');
                cleaned = cleaned.replace(regex, '');
            }

            // Remove dates at end (e.g., "AMAZON UK 23/01/25")
            cleaned = cleaned.replace(/\s+\d{1,2}\/\d{1,2}\/\d{2,4}$/, '');

            // Remove reference numbers (e.g., "REF 12345678")
            cleaned = cleaned.replace(/\s+REF\s+\w+/i, '');
            cleaned = cleaned.replace(/\s+\d{6,}$/, '');

            // Generate variants
            const variants = [cleaned];

            // Add without country codes
            const withoutCountry = cleaned.replace(/\s+(UK|GB|US|EU)\b/gi, '').trim();
            if (withoutCountry !== cleaned) {
                variants.push(withoutCountry);
            }

            // Add common abbreviations
            if (cleaned.toLowerCase().includes('amazon')) {
                variants.push('Amazon', 'Amazon UK', 'Amazon.co.uk', 'Amazon Marketplace');
            }
            if (cleaned.toLowerCase().includes('tesco')) {
                variants.push('Tesco', 'Tesco Stores');
            }
            // Add more common merchants as needed

            return {
                original: description,
                cleaned: cleaned,
                variants: [...new Set(variants)] // Remove duplicates
            };
        }

        /**
         * Generate amount in multiple formats
         */
        function generateAmountFormats(amount) {
            if (!amount || amount === 0) return [];

            const formats = [
                amount.toFixed(2),                    // 50.00
                `¬£${amount.toFixed(2)}`,              // ¬£50.00
                `\u00A3${amount.toFixed(2)}`,         // ¬£50.00 (unicode)
                amount.toFixed(2).replace('.', ','),  // 50,00 (European)
                `GBP ${amount.toFixed(2)}`,           // GBP 50.00
            ];

            // Add variations without decimals if whole number
            if (amount % 1 === 0) {
                formats.push(amount.toString());      // 50
                formats.push(`¬£${amount}`);           // ¬£50
            }

            return [...new Set(formats)];
        }

        /**
         * Parse transaction date to Date object
         */
        function parseTransactionDate(dateStr) {
            if (!dateStr) return new Date();

            // Assuming DD/MM/YYYY or DD/MM/YY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
                let year = parseInt(parts[2]);

                // Handle 2-digit years
                if (year < 100) {
                    year += year < 50 ? 2000 : 1900;
                }

                return new Date(year, month, day);
            }

            return new Date(dateStr);
        }

        /**
         * Get day of week from date string
         */
        function getDayOfWeek(dateStr) {
            const date = parseTransactionDate(dateStr);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days[date.getDay()];
        }

        // ========================================
        // SEARCH LOGGER
        // ========================================

        class SearchLogger {
            constructor() {
                this.logs = [];
                this.container = null;
            }

            init(containerId) {
                this.container = document.getElementById(containerId);
                this.logs = [];
                this.render();
            }

            logStage(stage, name) {
                this.addLog('stage', `\n[STAGE ${stage}] ${name}`, 'info', 'üîÑ');
                this.render();
            }

            logProgress(message, type = 'info') {
                const icons = {
                    info: '‚è≥',
                    success: '‚úÖ',
                    warning: '‚ö†Ô∏è',
                    error: '‚ùå',
                    ai: 'ü§ñ'
                };
                this.addLog('progress', message, type, icons[type] || '‚Ä¢');
                this.render();
                this.updateHeader(message, icons[type]);
            }

            updateHeader(message, icon) {
                const statusEl = document.getElementById('searchLogStatus');
                const summaryEl = document.getElementById('searchLogSummary');

                if (statusEl) statusEl.textContent = icon;

                // Update summary with last message (truncated)
                if (summaryEl && message) {
                    const truncated = message.length > 40 ? message.substring(0, 40) + '...' : message;
                    summaryEl.textContent = truncated;
                }
            }

            logAI(action, result) {
                this.addLog('ai', `ü§ñ AI: ${action}`, 'ai', 'ü§ñ');
                if (result) {
                    this.addLog('ai', `   ‚Üí ${JSON.stringify(result).substring(0, 100)}...`, 'info', '  ');
                }
                this.render();
            }

            logResults(count, stage) {
                if (count > 0) {
                    this.addLog('result', `üìä Found ${count} potential invoice${count > 1 ? 's' : ''}!`, 'success', '‚úÖ');
                } else {
                    this.addLog('result', `No results in ¬±${stage} days`, 'warning', '‚ö†Ô∏è');
                }
                this.render();
            }

            addLog(category, message, type, icon) {
                this.logs.push({
                    timestamp: new Date(),
                    category,
                    message,
                    type,
                    icon
                });
            }

            render() {
                if (!this.container) return;

                const html = this.logs.map(log => {
                    const colors = {
                        info: '#94a3b8',
                        success: '#4ade80',
                        warning: '#fbbf24',
                        error: '#f87171',
                        ai: '#a78bfa'
                    };
                    const color = colors[log.type] || '#e2e8f0';

                    return `<div style="color: ${color}; margin: 3px 0; line-height: 1.5;">
                        ${log.icon} ${log.message}
                    </div>`;
                }).join('');

                this.container.innerHTML = html;

                // Auto-scroll to bottom
                this.container.scrollTop = this.container.scrollHeight;
            }

            clear() {
                this.logs = [];
                this.render();
            }
        }

        // Global search logger instance
        const searchLogger = new SearchLogger();

        /**
         * Format email date to compact format (e.g., "Jan 15" or "15 Jan 2025")
         */
        function formatCompactDate(emailDateStr) {
            try {
                const date = new Date(emailDateStr);
                const now = new Date();
                const isCurrentYear = date.getFullYear() === now.getFullYear();

                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = months[date.getMonth()];
                const day = date.getDate();

                if (isCurrentYear) {
                    return `${month} ${day}`;
                } else {
                    return `${month} ${day}, ${date.getFullYear()}`;
                }
            } catch (error) {
                return emailDateStr.substring(0, 15); // Fallback: truncate
            }
        }

        /**
         * Toggle search log visibility
         */
        function toggleSearchLog() {
            const container = document.getElementById('searchLogContainer');
            const icon = document.getElementById('searchLogIcon');
            const summary = document.getElementById('searchLogSummary');

            if (container.style.display === 'none') {
                // Expand
                container.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
                icon.textContent = '‚ñº';
                summary.textContent = '(Click to collapse)';
            } else {
                // Collapse
                container.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
                icon.textContent = '‚ñ∂';
                summary.textContent = '(Click to expand)';
            }
        }

        // ========================================
        // INTELLIGENT SEARCH MODAL CONTROLS
        // ========================================

        function showIntelligentSearchModal(transaction, transactionIndex) {
            const modal = document.getElementById('intelligentSearchModal');

            // Set transaction details
            document.getElementById('searchTxDate').textContent = transaction.date || 'N/A';

            // Fix double ¬£ sign - strip existing ¬£ before adding new one
            const amount = (transaction.spent || transaction.received || '0.00').toString().replace(/¬£/g, '');
            document.getElementById('searchTxAmount').textContent = `¬£${amount}`;

            document.getElementById('searchTxDesc').textContent = transaction.description || 'N/A';

            // Show/hide From/To field
            if (transaction.fromTo && transaction.fromTo.trim()) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = transaction.fromTo;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Show/hide user notes field
            if (transaction.voiceNotes && transaction.voiceNotes.trim()) {
                document.getElementById('searchTxNotesContainer').style.display = 'block';
                document.getElementById('searchTxNotes').textContent = transaction.voiceNotes;
                console.log('üìù [MODAL] Showing user notes:', transaction.voiceNotes);
            } else {
                document.getElementById('searchTxNotesContainer').style.display = 'none';
                console.log('üìù [MODAL] No user notes to display');
            }

            // Initialize logger
            searchLogger.init('searchLogContainer');

            // Show modal
            modal.style.display = 'flex';

            // Start search
            executeIntelligentSearch(transaction, transactionIndex);
        }

        function closeIntelligentSearchModal() {
            document.getElementById('intelligentSearchModal').style.display = 'none';

            // Restore log header visibility for next search
            const logHeader = document.getElementById('searchLogHeader');
            if (logHeader) logHeader.style.display = 'flex';

            searchLogger.clear();
        }

        async function connectGmailFromSearch() {
            searchLogger.logProgress('Connecting to Gmail...', 'info');
            try {
                await signInToGmail();
                // Wait for auth to complete
                await new Promise(resolve => setTimeout(resolve, 1500));

                if (gmailAccounts.length > 0) {
                    searchLogger.logProgress('‚úÖ Gmail connected successfully!', 'success');
                    searchLogger.logProgress('Restarting search...', 'info');
                    // Restart the search
                    const modal = document.getElementById('intelligentSearchModal');
                    const txIndex = currentInvoiceSearchIndex; // Should be set from handleInvoiceFetch
                    const transaction = allTransactions[txIndex];
                    executeIntelligentSearch(transaction, txIndex);
                } else {
                    searchLogger.logProgress('‚ùå Failed to connect Gmail', 'error');
                }
            } catch (error) {
                searchLogger.logProgress(`‚ùå Connection error: ${error.message}`, 'error');
            }
        }

        function updateSearchProgress(percent, text) {
            const bar = document.getElementById('searchProgressBar');
            const fill = document.getElementById('searchProgressFill');
            const progressText = document.getElementById('searchProgressText');

            bar.style.display = 'block';
            fill.style.width = percent + '%';
            progressText.textContent = text;
        }

        // ========================================
        // PROGRESSIVE SEARCH ENGINE
        // ========================================

        const SEARCH_STAGES = [
            {
                stage: 1,
                name: "Exact Match",
                dateWindow: 5,
                autoExecute: true,
                description: "Searching ¬±5 days with exact merchant and amount"
            },
            {
                stage: 2,
                name: "Expanded Search",
                dateWindow: 10,
                autoExecute: true,
                description: "Searching ¬±10 days with merchant variants and AI keywords"
            },
            {
                stage: 3,
                name: "Wide Search",
                dateWindow: 15,
                autoExecute: false,
                description: "Searching ¬±15 days with fuzzy matching"
            }
        ];

        async function executeIntelligentSearch(transaction, transactionIndex) {
            try {
                // Check if Gmail is connected
                if (gmailAccounts.length === 0) {
                    searchLogger.logProgress('‚ùå Gmail not connected!', 'error');
                    const resultsContainer = document.getElementById('searchResultsContainer');
                    resultsContainer.style.display = 'block';
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; padding: 30px; background: #fef3c7; border-radius: 8px; border: 2px solid #f59e0b;">
                            <div style="font-size: 48px; margin-bottom: 15px;">üìß</div>
                            <h4 style="margin: 0 0 10px 0; color: #92400e;">Gmail Not Connected</h4>
                            <p style="color: #78350f; margin: 0 0 20px 0;">
                                You need to connect your Gmail account to search for invoices.
                            </p>
                            <button onclick="connectGmailFromSearch()" class="btn-primary" style="margin-right: 10px;">
                                Connect Gmail Now
                            </button>
                            <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                Cancel
                            </button>
                        </div>
                    `;
                    return;
                }

                // Step 1: Build context
                searchLogger.logProgress('Building search context...', 'info');
                const context = buildTransactionContext(transaction, transactionIndex);

                // Extract core keyword for human-like search
                const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
                searchLogger.logProgress(`Merchant: "${context.merchantName}"`, 'success');
                searchLogger.logProgress(`Search keyword: "${merchantKeyword}"`, 'success');
                searchLogger.logProgress(`Amount formats: ${context.amountFormats.length} variations`, 'success');

                // Step 2: Optional AI enhancement
                updateSearchProgress(20, 'Enhancing search with AI...');
                searchLogger.logAI('Generating smart search keywords...');

                const aiKeywords = await generateAISearchKeywords(context);
                if (aiKeywords) {
                    searchLogger.logProgress(`AI keywords: ${aiKeywords.join(', ')}`, 'success');
                }

                // Step 3: Progressive search stages
                for (let i = 0; i < SEARCH_STAGES.length; i++) {
                    const stage = SEARCH_STAGES[i];

                    // Ask user before non-auto stages
                    if (!stage.autoExecute && i > 0) {
                        const shouldContinue = await promptUserToContinueSearch(stage);
                        if (!shouldContinue) {
                            searchLogger.logProgress('Search cancelled by user', 'warning');
                            return;
                        }
                    }

                    searchLogger.logStage(stage.stage, `${stage.name} (¬±${stage.dateWindow} days)`);
                    updateSearchProgress(20 + (i * 25), `Stage ${stage.stage}: ${stage.description}`);

                    const results = await executeSearchStage(context, stage, aiKeywords);

                    searchLogger.logResults(results.length, stage.dateWindow);

                    if (results.length > 0) {
                        updateSearchProgress(70, 'Processing invoices...');
                        searchLogger.logProgress(`‚úÖ Found ${results.length} potential invoice(s)!`, 'success');
                        await displayIntelligentSearchResults(results, transaction, transactionIndex);
                        return;
                    }
                }

                // No results found
                searchLogger.logProgress('No invoices found in any search stage', 'warning');
                updateSearchProgress(100, 'Search complete - no results');

                // Show no results options
                showNoResultsOptions(context);

            } catch (error) {
                console.error('Intelligent search error:', error);
                searchLogger.logProgress(`Error: ${error.message}`, 'error');
                showToast('Search error: ' + error.message, 'error');
            }
        }

        /**
         * Execute a single search stage
         */
        async function executeSearchStage(context, stage, aiKeywords) {
            const queries = buildStageQueries(context, stage, aiKeywords);
            const allResults = [];

            for (let i = 0; i < queries.length; i++) {
                const query = queries[i];
                searchLogger.logProgress(`${query.description}...`, 'info');
                console.log('üìß [Gmail Query]:', query.query);

                try {
                    // Search all Gmail accounts
                    for (const account of gmailAccounts) {
                        const messages = await searchGmailWithQuery(query.query, account, context.date, stage.dateWindow);

                        if (messages.length > 0) {
                            searchLogger.logProgress(`  Found ${messages.length} email(s) in ${account.email}`, 'success');
                            allResults.push(...messages.map(m => ({ ...m, accountEmail: account.email, accountAccessToken: account.accessToken })));
                        } else {
                            searchLogger.logProgress(`  No results in ${account.email}`, 'info');
                        }
                    }
                } catch (error) {
                    searchLogger.logProgress(`  Query failed: ${error.message}`, 'error');
                    console.error('Gmail search error:', error);
                }
            }

            // Deduplicate by message ID
            const uniqueResults = deduplicateMessages(allResults);
            return uniqueResults;
        }

        /**
         * Build search queries for a stage (Human-like search approach)
         */
        function buildStageQueries(context, stage, aiKeywords) {
            const queries = [];

            // Extract core merchant keyword (e.g., "google" from "Card Purchase Google GSUITE pebl-cic")
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);

            // Query 1: Simple human-like search - merchant + invoice keywords
            if (merchantKeyword) {
                queries.push({
                    query: `${merchantKeyword} (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                    description: `Searching for "${merchantKeyword} invoice"`,
                    weight: 1.0
                });
            }

            // Query 2: Merchant + payment keywords (broader)
            if (merchantKeyword && stage.stage >= 2) {
                queries.push({
                    query: `${merchantKeyword} (payment OR bill OR statement) has:attachment filename:pdf`,
                    description: `Searching for "${merchantKeyword} payment/bill"`,
                    weight: 0.9
                });
            }

            // Query 3: Full merchant name search (if different from keyword)
            if (context.merchantName && context.merchantName !== merchantKeyword) {
                queries.push({
                    query: `"${context.merchantName}" invoice has:attachment`,
                    description: `Searching for exact merchant name`,
                    weight: 0.85
                });
            }

            // Query 4: Amount-based search
            if (context.amountFormats.length > 0 && stage.stage >= 2) {
                const amountOr = context.amountFormats.slice(0, 3).map(a => `"${a}"`).join(' OR ');
                queries.push({
                    query: `${merchantKeyword} (${amountOr}) has:attachment`,
                    description: `Searching for "${merchantKeyword}" + amount`,
                    weight: 0.8
                });
            }

            // Query 5: AI keywords (if available)
            if (aiKeywords && aiKeywords.length > 0 && stage.stage >= 2) {
                // Use AI keywords with merchant name
                const topKeywords = aiKeywords.slice(0, 3).join(' OR ');
                queries.push({
                    query: `${merchantKeyword} (${topKeywords}) has:attachment filename:pdf`,
                    description: `Searching "${merchantKeyword}" + AI keywords`,
                    weight: 0.9
                });
            }

            // Query 6: User notes (if available) - High priority!
            if (context.userNotes && stage.stage >= 2) {
                const notesSnippet = context.userNotes.substring(0, 50).split(/[.!?]/)[0];
                queries.push({
                    query: `${merchantKeyword} "${notesSnippet}" has:attachment`,
                    description: `Searching "${merchantKeyword}" + your notes`,
                    weight: 0.95
                });
            }

            // Query 7: User context (if available)
            if (context.userContext && stage.stage >= 3) {
                queries.push({
                    query: `${merchantKeyword} "${context.userContext}" has:attachment`,
                    description: `Searching "${merchantKeyword}" + project assignments`,
                    weight: 0.85
                });
            }

            // Query 8: Fallback - just merchant name + attachment (Stage 3 only)
            if (stage.stage >= 3 && merchantKeyword) {
                queries.push({
                    query: `${merchantKeyword} has:attachment`,
                    description: `Wide search for "${merchantKeyword}" with any attachment`,
                    weight: 0.5
                });
            }

            return queries;
        }

        /**
         * Extract core merchant keyword (like a human would type)
         * "Card Purchase Google GSUITE pebl-cic" ‚Üí "google"
         * "Amazon UK" ‚Üí "amazon"
         */
        function extractCoreMerchantKeyword(merchantName) {
            if (!merchantName) return '';

            // Convert to lowercase for matching
            const lower = merchantName.toLowerCase();

            // Common merchant keywords to extract
            const knownMerchants = [
                'amazon', 'google', 'microsoft', 'apple', 'paypal', 'stripe',
                'tesco', 'sainsbury', 'asda', 'morrisons', 'waitrose',
                'edf', 'british gas', 'thames water', 'vodafone', 'bt', 'sky',
                'spotify', 'netflix', 'adobe', 'dropbox', 'zoom',
                'uber', 'deliveroo', 'just eat'
            ];

            // Check if any known merchant appears in the name
            for (const merchant of knownMerchants) {
                if (lower.includes(merchant)) {
                    return merchant;
                }
            }

            // If no known merchant, extract first meaningful word
            const words = merchantName.split(/\s+/);
            for (const word of words) {
                // Skip common words
                if (word.length > 3 && !['card', 'payment', 'purchase'].includes(word.toLowerCase())) {
                    return word.toLowerCase();
                }
            }

            // Fallback: return cleaned merchant name
            return merchantName.toLowerCase();
        }

        /**
         * Search Gmail with date window
         */
        async function searchGmailWithQuery(query, account, transactionDate, dateWindowDays) {
            try {
                // Check if Gmail API is available
                if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.gmail) {
                    throw new Error('Gmail API not initialized');
                }

                // Set the access token for this account
                if (!account || !account.accessToken) {
                    throw new Error('No valid access token for account');
                }

                gapi.client.setToken({ access_token: account.accessToken });
                console.log('üîë [Gmail Search] Set access token for:', account.email);

                // Calculate date range
                const startDate = new Date(transactionDate);
                startDate.setDate(startDate.getDate() - dateWindowDays);

                const endDate = new Date(transactionDate);
                endDate.setDate(endDate.getDate() + dateWindowDays);

                // Format dates for Gmail (YYYY/MM/DD)
                const formatDate = (d) => {
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}/${month}/${day}`;
                };

                const dateQuery = `after:${formatDate(startDate)} before:${formatDate(endDate)}`;
                const fullQuery = `${query} ${dateQuery}`;

                console.log('üìß [Gmail Search]', fullQuery);

                // Execute Gmail search
                const response = await gapi.client.gmail.users.messages.list({
                    userId: 'me',
                    q: fullQuery,
                    maxResults: 10
                });

                if (!response || !response.result) {
                    console.error('Invalid Gmail API response:', response);
                    return [];
                }

                if (!response.result.messages) {
                    return [];
                }

                return response.result.messages;

            } catch (error) {
                console.error('Gmail search error:', error);
                const errorMsg = error.message || error.result?.error?.message || 'Unknown error';
                throw new Error(`Gmail search failed: ${errorMsg}`);
            }
        }

        /**
         * Deduplicate messages by ID
         */
        function deduplicateMessages(messages) {
            const seen = new Set();
            return messages.filter(msg => {
                const key = `${msg.id}_${msg.accountEmail}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        /**
         * Prompt user to continue to next search stage
         */
        async function promptUserToContinueSearch(stage) {
            return new Promise((resolve) => {
                const btnHtml = `
                    <div id="continueSearchPrompt" style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <p style="margin: 0 0 10px 0; font-weight: 500;">No invoices found. Continue searching?</p>
                        <p style="margin: 0 0 15px 0; font-size: 14px; color: #92400e;">
                            ${stage.description}
                        </p>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="continueSearchResponse(true)" class="btn-primary" style="flex: 1;">
                                Continue to Stage ${stage.stage}
                            </button>
                            <button onclick="continueSearchResponse(false)" class="btn-secondary" style="flex: 1;">
                                Stop Searching
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById('searchActionButtons').insertAdjacentHTML('beforebegin', btnHtml);

                window.continueSearchResponse = (response) => {
                    const prompt = document.getElementById('continueSearchPrompt');
                    if (prompt) prompt.remove();
                    delete window.continueSearchResponse;
                    resolve(response);
                };
            });
        }

        /**
         * Display search results
         */
        async function displayIntelligentSearchResults(messages, transaction, transactionIndex) {
            console.log('üìä [RESULTS] Displaying', messages.length, 'invoice matches');
            searchLogger.logProgress(`Analyzing and scoring ${messages.length} invoice(s)...`, 'info');

            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.style.display = 'block';

            // Get transaction context for scoring
            const context = buildTransactionContext(transaction, transactionIndex);

            // Show initial placeholder
            resultsContainer.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 10px;">
                        Found ${messages.length} potential invoice${messages.length > 1 ? 's' : ''} (processing...)
                    </div>
                </div>
                <div id="invoiceResultsContainer"></div>
            `;

            // Fetch, score, and AUTOMATICALLY PROCESS PDFs
            const scoredMessages = [];
            const totalMessages = messages.length;

            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];

                try {
                    // Update progress bar incrementally during OCR/validation
                    const progressPercent = 70 + Math.floor((i / totalMessages) * 25); // 70% to 95%
                    updateSearchProgress(progressPercent, `Processing invoice ${i + 1} of ${totalMessages}...`);
                    searchLogger.logProgress(`Processing invoice ${i + 1} of ${totalMessages}...`, 'info');

                    // Set access token for this message's account
                    if (msg.accountAccessToken) {
                        gapi.client.setToken({ access_token: msg.accountAccessToken });
                        console.log('üîë [AUTO-PROCESS] Set token for:', msg.accountEmail);
                    } else {
                        throw new Error(`No access token for message from ${msg.accountEmail}`);
                    }

                    // Get full message details
                    const response = await gapi.client.gmail.users.messages.get({
                        userId: 'me',
                        id: msg.id
                    });

                    const message = response.result;

                    // Score this invoice
                    const scoring = scoreInvoiceRelevance(message, transaction, context);

                    // Extract attachments
                    const attachments = extractAttachments(message.payload);

                    // AUTOMATIC PDF PROCESSING: Download and extract data from PDFs
                    let pdfBlob = null;
                    let extractedData = null;
                    let validation = null;
                    let ocrText = null;

                    if (attachments.length > 0) {
                        try {
                            searchLogger.logProgress(`  üìÑ Downloading and analyzing PDF...`, 'info');

                            // Download the first PDF attachment
                            const attachment = attachments[0];
                            // Token already set above, no need to set again
                            const attachResponse = await gapi.client.gmail.users.messages.attachments.get({
                                userId: 'me',
                                messageId: msg.id,
                                id: attachment.id
                            });

                            // Decode PDF
                            const data = attachResponse.result.data;
                            const pdfData = data.replace(/-/g, '+').replace(/_/g, '/');
                            pdfBlob = base64ToBlob(pdfData, 'application/pdf');

                            // Extract text using OCR
                            searchLogger.logProgress(`  üîç Running OCR on PDF...`, 'info');
                            ocrText = await extractTextFromPDF(pdfBlob);

                            if (ocrText && ocrText.trim().length > 20) {
                                // Extract structured data (company, amount, date)
                                searchLogger.logProgress(`  ü§ñ Extracting invoice data with AI...`, 'info');
                                extractedData = await extractStructuredDataFromInvoice(ocrText);

                                if (extractedData) {
                                    // Validate against transaction
                                    searchLogger.logProgress(`  ‚úì Validating invoice data...`, 'info');
                                    validation = await validateInvoiceData(extractedData, transaction);

                                    console.log('‚úÖ [AUTO-PROCESS] Extracted and validated:', {
                                        company: extractedData.company,
                                        amount: extractedData.amount,
                                        date: extractedData.date,
                                        validation: validation.recommendation
                                    });
                                } else {
                                    searchLogger.logProgress(`  ‚ö†Ô∏è Could not extract structured data`, 'warning');
                                }
                            } else {
                                searchLogger.logProgress(`  ‚ö†Ô∏è Insufficient text extracted from PDF`, 'warning');
                            }
                        } catch (pdfError) {
                            console.error('‚ùå [AUTO-PROCESS] PDF processing error:', pdfError);
                            searchLogger.logProgress(`  ‚ö†Ô∏è PDF processing failed: ${pdfError.message}`, 'warning');
                        }
                    }

                    scoredMessages.push({
                        message,
                        scoring,
                        attachments,
                        accountEmail: msg.accountEmail,
                        pdfBlob,           // Store for later attachment
                        extractedData,     // Store extracted invoice data
                        validation,        // Store validation results
                        ocrText            // Store OCR text
                    });

                    console.log('üìä Scored email:', {
                        subject: message.payload.headers.find(h => h.name === 'Subject')?.value,
                        score: scoring.total,
                        breakdown: scoring.details,
                        extracted: extractedData
                    });

                    // IMMEDIATE DISPLAY: Render results incrementally as each invoice is processed
                    renderInvoiceResults(scoredMessages, transaction, transactionIndex, context);

                } catch (error) {
                    console.error('Error fetching message details:', error);
                    searchLogger.logProgress(`Error loading email ${msg.id}: ${error.message}`, 'error');
                }
            }

            // Final render with completion message
            searchLogger.logProgress(`‚úÖ Processed and ranked ${scoredMessages.length} results`, 'success');
            renderInvoiceResults(scoredMessages, transaction, transactionIndex, context, true);
        }

        /**
         * Render invoice results (called incrementally or at completion)
         */
        function renderInvoiceResults(scoredMessages, transaction, transactionIndex, context, isComplete = false) {
            // Sort by validation quality first, then email score
            scoredMessages.sort((a, b) => {
                // Calculate validation match count (0-3 for how many fields match)
                const getValidationScore = (item) => {
                    if (!item.validation) return -1; // No validation = lowest priority
                    let score = 0;
                    if (item.validation.companyMatch) score++;
                    if (item.validation.amountMatch) score++;
                    if (item.validation.dateMatch) score++;
                    return score;
                };

                const aValidationScore = getValidationScore(a);
                const bValidationScore = getValidationScore(b);

                // Sort by validation score first (3 matches > 2 matches > 1 match > no validation)
                if (aValidationScore !== bValidationScore) {
                    return bValidationScore - aValidationScore;
                }

                // If same validation score, sort by email scoring
                return b.scoring.total - a.scoring.total;
            });

            // Build HTML
            const statusText = isComplete ? 'sorted by match probability' : `processing ${scoredMessages.length}...`;
            let html = `<div style="margin-bottom: 20px;">
                <div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 10px;">
                    Found ${scoredMessages.length} potential invoice${scoredMessages.length > 1 ? 's' : ''} (${statusText})
                </div>
            </div>`;

            // Display scored results
            scoredMessages.forEach((item, index) => {
                const headers = item.message.payload.headers;
                const from = headers.find(h => h.name === 'From')?.value || 'Unknown';
                const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                const date = headers.find(h => h.name === 'Date')?.value || '';
                const messageId = item.message.id;

                // Border color based on rank
                const borderColor = index === 0 ? '#3AAFA9' : (index === 1 ? '#d97706' : '#94a3b8');

                // Score color
                let scoreColor, scoreIcon;
                if (item.scoring.total >= 80) {
                    scoreColor = '#059669';
                } else if (item.scoring.total >= 60) {
                    scoreColor = '#d97706';
                } else if (item.scoring.total >= 40) {
                    scoreColor = '#ea580c';
                } else {
                    scoreColor = '#dc2626';
                }

                // Scoring pill colors and icons
                const getMatchIcon = (score, threshold) => score >= threshold ? '‚úì' : '‚úó';
                const getMatchColor = (score, threshold) => score >= threshold ? '#059669' : '#dc2626';

                // PRIORITY: Use validation results from OCR if available, otherwise fall back to email scoring
                let companyColor, amountColor, dateColor, companyIcon, amountIcon, dateIcon;

                if (item.validation) {
                    // Use OCR validation results (more accurate!)
                    companyColor = item.validation.companyMatch ? '#059669' : '#dc2626';
                    amountColor = item.validation.amountMatch ? '#059669' : '#dc2626';
                    dateColor = item.validation.dateMatch ? '#059669' : '#dc2626';

                    companyIcon = item.validation.companyMatch ? '‚úì' : '‚úó';
                    amountIcon = item.validation.amountMatch ? '‚úì' : '‚úó';
                    dateIcon = item.validation.dateMatch ? '‚úì' : '‚úó';

                    console.log('üìä Using OCR validation for pills:', {
                        company: item.validation.companyMatch,
                        amount: item.validation.amountMatch,
                        date: item.validation.dateMatch
                    });
                } else {
                    // Fallback to email-based scoring
                    companyColor = getMatchColor(item.scoring.company, 30);
                    amountColor = getMatchColor(item.scoring.amount, 25);
                    dateColor = item.scoring.date >= 15 ? '#059669' : '#ea580c';

                    companyIcon = getMatchIcon(item.scoring.company, 30);
                    amountIcon = getMatchIcon(item.scoring.amount, 25);
                    dateIcon = getMatchIcon(item.scoring.date, 15);

                    console.log('üìä Using email scoring for pills (no OCR validation available)');
                }

                // Format date compactly
                const formattedDate = formatCompactDate(date);
                const fromName = from.includes('<') ? from.split('<')[0].trim() : from.substring(0, 30);

                html += `<div style="background: #fff; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${borderColor}; box-shadow: 0 1px 4px rgba(0,0,0,0.08); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'" onmouseout="this.style.boxShadow='0 1px 4px rgba(0,0,0,0.08)'">

                    <!-- Compact Scoring: Horizontal pills with validation status -->
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
                        <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                            <span style="background: ${companyColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                ${companyIcon} Company
                            </span>
                            <span style="background: ${amountColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                ${amountIcon} Amount
                            </span>
                            <span style="background: ${dateColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                ${dateIcon} Date
                            </span>
                        </div>`;

                // Add validation status badge on the right side
                if (item.extractedData && item.validation) {
                    const allMatch = item.validation.companyMatch && item.validation.amountMatch && item.validation.dateMatch;
                    const someMatch = item.validation.companyMatch || item.validation.amountMatch || item.validation.dateMatch;

                    let validationIcon, validationText, validationColor;
                    if (allMatch) {
                        validationIcon = '‚úÖ';
                        validationText = 'All fields validated';
                        validationColor = '#22c55e';
                    } else if (someMatch) {
                        validationIcon = '‚ö†Ô∏è';
                        validationText = 'Partial match';
                        validationColor = '#f59e0b';
                    } else {
                        validationIcon = '‚ùå';
                        validationText = 'Validation mismatch';
                        validationColor = '#ef4444';
                    }

                    html += `
                        <div style="display: flex; align-items: center; gap: 4px; color: ${validationColor}; font-size: 10px; font-weight: 600; white-space: nowrap;">
                            <span style="font-size: 12px;">${validationIcon}</span>
                            <span>${validationText}</span>
                        </div>`;
                }

                html += `
                    </div>

                    <!-- Email info: Single line, truncated -->
                    <div style="font-size: 13px; color: #1e293b; margin-bottom: 4px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(subject)}">
                        ${escapeHtml(subject)}
                    </div>
                    <div style="font-size: 11px; color: #64748b; margin-bottom: 8px;">
                        ${escapeHtml(fromName)} ‚Ä¢ ${formattedDate}
                    </div>

                    <!-- Compact button -->`;

                if (item.attachments.length > 0) {
                    const att = item.attachments[0]; // Show first attachment
                    const sizeKB = (att.size / 1024).toFixed(1);

                    // Store the processed data in a global map so previewAndAttachInvoice can access it
                    const dataKey = `${messageId}_${att.id}`;
                    if (!window.processedInvoiceData) window.processedInvoiceData = {};
                    window.processedInvoiceData[dataKey] = {
                        pdfBlob: item.pdfBlob,
                        extractedData: item.extractedData,
                        validation: item.validation,
                        ocrText: item.ocrText
                    };

                    html += `<button onclick="previewAndAttachInvoice(${transactionIndex}, '${messageId}', '${att.id}', '${escapeHtml(att.filename)}', '${escapeHtml(item.accountEmail)}')"
                        style="background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); color: white; padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; width: 100%; transition: all 0.2s;"
                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(58,175,169,0.3)'"
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        üìÑ Preview Invoice (${sizeKB} KB)
                    </button>`;

                    // Show additional attachments if any
                    if (item.attachments.length > 1) {
                        html += `<div style="font-size: 10px; color: #64748b; margin-top: 4px; text-align: center;">
                            +${item.attachments.length - 1} more attachment(s)
                        </div>`;
                    }
                } else {
                    html += `<div style="color: #f59e0b; font-size: 11px; padding: 6px; text-align: center; background: #fffbeb; border-radius: 4px;">
                        ‚ö†Ô∏è No PDF attachments
                    </div>`;
                }

                html += `</div>`;
            });

            // Render to invoiceResultsContainer (inside the main results container)
            const invoiceResultsContainer = document.getElementById('invoiceResultsContainer');
            if (invoiceResultsContainer) {
                invoiceResultsContainer.innerHTML = html;
            }

            // Update progress and log only on completion
            if (isComplete) {
                updateSearchProgress(100, 'Complete! Results displayed.');
                searchLogger.logProgress('‚úÖ Results displayed! Click "Preview & Attach" to view invoice.', 'success');
            }
        }

        /**
         * Extract attachments from email payload
         */
        function extractAttachments(payload, attachments = []) {
            if (payload.parts) {
                for (const part of payload.parts) {
                    if (part.filename && part.body && part.body.attachmentId) {
                        attachments.push({
                            filename: part.filename,
                            id: part.body.attachmentId,
                            mimeType: part.mimeType,
                            size: part.body.size || 0
                        });
                    }
                    // Recursively check nested parts
                    if (part.parts) {
                        extractAttachments(part, attachments);
                    }
                }
            }
            return attachments;
        }

        /**
         * Score an email's relevance to the transaction
         * Returns score 0-100 based on company, amount, and date match
         */
        function scoreInvoiceRelevance(email, transaction, context) {
            let score = 0;
            const scoring = {
                company: 0,
                amount: 0,
                date: 0,
                details: {}
            };

            // Get email metadata
            const headers = email.payload.headers;
            const from = headers.find(h => h.name === 'From')?.value || '';
            const subject = headers.find(h => h.name === 'Subject')?.value || '';
            const dateStr = headers.find(h => h.name === 'Date')?.value || '';
            const snippet = email.snippet || '';

            // 1. COMPANY NAME MATCH (max 40 points)
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
            const searchText = `${from} ${subject}`.toLowerCase();

            if (searchText.includes(merchantKeyword.toLowerCase())) {
                score += 40;
                scoring.company = 40;
                scoring.details.companyMatch = `‚úì "${merchantKeyword}" found in email`;
            } else {
                // Partial match - check merchant variants
                const partialMatch = context.merchantVariants.some(variant =>
                    searchText.includes(variant.toLowerCase())
                );
                if (partialMatch) {
                    score += 20;
                    scoring.company = 20;
                    scoring.details.companyMatch = `~ Partial match found`;
                } else {
                    scoring.details.companyMatch = `‚úó Company name not found`;
                }
            }

            // 2. AMOUNT MATCH (max 35 points)
            const amountStr = context.amount.toFixed(2);
            const amountGBP = `¬£${amountStr}`;
            const fullText = `${subject} ${snippet}`.toLowerCase();

            if (fullText.includes(amountStr) || fullText.includes(amountGBP)) {
                score += 35;
                scoring.amount = 35;
                scoring.details.amountMatch = `‚úì ¬£${amountStr} found`;
            } else {
                // Check for amount variations (with commas, different formats)
                const hasAmountVariation = context.amountFormats.some(format =>
                    fullText.includes(format.toLowerCase())
                );
                if (hasAmountVariation) {
                    score += 20;
                    scoring.amount = 20;
                    scoring.details.amountMatch = `~ Amount format variation found`;
                } else {
                    scoring.details.amountMatch = `‚úó Amount not found`;
                }
            }

            // 3. DATE PROXIMITY (max 25 points)
            try {
                const emailDate = new Date(dateStr);
                const txDate = context.date;
                const daysDiff = Math.abs(Math.floor((emailDate - txDate) / (1000 * 60 * 60 * 24)));

                if (daysDiff === 0) {
                    score += 25;
                    scoring.date = 25;
                    scoring.details.dateMatch = `‚úì Same day`;
                } else if (daysDiff <= 2) {
                    score += 20;
                    scoring.date = 20;
                    scoring.details.dateMatch = `‚úì ${daysDiff} day(s) difference`;
                } else if (daysDiff <= 5) {
                    score += 15;
                    scoring.date = 15;
                    scoring.details.dateMatch = `~ ${daysDiff} days difference`;
                } else if (daysDiff <= 10) {
                    score += 10;
                    scoring.date = 10;
                    scoring.details.dateMatch = `~ ${daysDiff} days difference`;
                } else {
                    score += 5;
                    scoring.date = 5;
                    scoring.details.dateMatch = `‚ö† ${daysDiff} days difference`;
                }
            } catch (error) {
                scoring.details.dateMatch = `? Could not parse date`;
            }

            scoring.total = score;
            return scoring;
        }

        /**
         * Get score badge HTML with color coding
         */
        function getScoreBadge(score) {
            let color, label, bgColor;

            if (score >= 80) {
                color = '#059669';
                bgColor = '#d1fae5';
                label = 'HIGH MATCH';
            } else if (score >= 60) {
                color = '#d97706';
                bgColor = '#fef3c7';
                label = 'LIKELY';
            } else if (score >= 40) {
                color = '#ea580c';
                bgColor = '#ffedd5';
                label = 'POSSIBLE';
            } else {
                color = '#dc2626';
                bgColor = '#fee2e2';
                label = 'LOW MATCH';
            }

            return `<div style="display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; background: ${bgColor}; border-radius: 6px; border: 2px solid ${color};">
                <span style="font-weight: 700; font-size: 18px; color: ${color};">${score}%</span>
                <span style="font-weight: 600; font-size: 11px; color: ${color}; letter-spacing: 0.5px;">${label}</span>
            </div>`;
        }

        /**
         * Show no results options
         */
        function showNoResultsOptions(context) {
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 30px; background: #f8fafc; border-radius: 8px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">üì≠</div>
                    <h4 style="margin: 0 0 10px 0; color: #1e293b;">No Invoices Found</h4>
                    <p style="color: #64748b; margin: 0 0 20px 0;">
                        Searched up to ¬±15 days for "${context.merchantName}"
                    </p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="document.getElementById('manualInvoiceUpload').click()" class="btn-primary">
                            üìé Upload PDF Manually
                        </button>
                        <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                            Close
                        </button>
                    </div>
                </div>
            `;
        }

        // ========================================
        // PDF PREVIEW & ATTACHMENT WORKFLOW
        // ========================================

        // Store current attachment details
        let currentAttachmentData = null;

        /**
         * Display validation results in the UI
         */
        function displayValidationResults(validation, extractedData, transaction) {
            const container = document.getElementById('validationResultsContainer');
            container.style.display = 'block';

            // Parse transaction amount for display
            const transactionAmountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').trim();
            const transactionAmount = parseFloat(transactionAmountStr) || 0;

            // Company validation
            const companyValidation = document.getElementById('companyValidation');
            const companyStatus = document.getElementById('companyStatus');
            const companyReason = document.getElementById('companyReason');
            const companyExpected = document.getElementById('companyExpected');
            const companyFound = document.getElementById('companyFound');

            // Populate Expected vs Found
            companyExpected.textContent = (transaction.description || 'N/A').substring(0, 20);
            companyFound.textContent = (extractedData?.company || 'Not found').substring(0, 20);

            if (validation.companyMatch) {
                companyStatus.textContent = '‚úÖ';
                companyValidation.style.background = '#f0fdf4';
                companyValidation.style.borderColor = '#22c55e';
            } else {
                companyStatus.textContent = '‚ùå';
                companyValidation.style.background = '#fef2f2';
                companyValidation.style.borderColor = '#ef4444';
            }
            companyReason.textContent = validation.companyReason || 'No reason provided';

            // Amount validation
            const amountValidation = document.getElementById('amountValidation');
            const amountStatus = document.getElementById('amountStatus');
            const amountReason = document.getElementById('amountReason');
            const amountExpected = document.getElementById('amountExpected');
            const amountFound = document.getElementById('amountFound');

            // Populate Expected vs Found
            amountExpected.textContent = `¬£${transactionAmount.toFixed(2)}`;
            amountFound.textContent = extractedData?.amount ? `¬£${extractedData.amount}` : 'Not found';

            if (validation.amountMatch) {
                amountStatus.textContent = '‚úÖ';
                amountValidation.style.background = '#f0fdf4';
                amountValidation.style.borderColor = '#22c55e';
            } else {
                amountStatus.textContent = '‚ùå';
                amountValidation.style.background = '#fef2f2';
                amountValidation.style.borderColor = '#ef4444';
            }
            amountReason.textContent = validation.amountReason || 'No reason provided';

            // Date validation
            const dateValidation = document.getElementById('dateValidation');
            const dateStatus = document.getElementById('dateStatus');
            const dateReason = document.getElementById('dateReason');
            const dateExpected = document.getElementById('dateExpected');
            const dateFound = document.getElementById('dateFound');

            // Populate Expected vs Found
            dateExpected.textContent = transaction.date || 'N/A';
            dateFound.textContent = extractedData?.date || 'Not found';

            if (validation.dateMatch) {
                dateStatus.textContent = '‚úÖ';
                dateValidation.style.background = '#f0fdf4';
                dateValidation.style.borderColor = '#22c55e';
            } else {
                dateStatus.textContent = '‚ùå';
                dateValidation.style.background = '#fef2f2';
                dateValidation.style.borderColor = '#ef4444';
            }
            dateReason.textContent = validation.dateReason || 'No reason provided';

            // Overall recommendation
            const recommendationContainer = document.getElementById('validationRecommendation');
            const recommendationIcon = document.getElementById('recommendationIcon');
            const recommendationText = document.getElementById('recommendationText');

            const allMatch = validation.companyMatch && validation.amountMatch && validation.dateMatch;

            if (validation.recommendation === 'attach' || allMatch) {
                recommendationContainer.style.background = '#f0fdf4';
                recommendationContainer.style.borderColor = '#22c55e';
                recommendationIcon.textContent = '‚úÖ';
                recommendationText.textContent = 'AI Recommendation: Safe to attach - All fields match!';
            } else if (validation.recommendation === 'review') {
                recommendationContainer.style.background = '#fffbeb';
                recommendationContainer.style.borderColor = '#f59e0b';
                recommendationIcon.textContent = '‚ö†Ô∏è';
                recommendationText.textContent = 'AI Recommendation: Please review - Some fields don\'t match';
            } else {
                recommendationContainer.style.background = '#fef2f2';
                recommendationContainer.style.borderColor = '#ef4444';
                recommendationIcon.textContent = 'üö´';
                recommendationText.textContent = 'AI Recommendation: Mismatched invoice - Consider rejecting';
            }

            // Update button text based on confidence
            const attachBtn = document.getElementById('attachInvoiceBtn');
            if (validation.overallConfidence === 'high' && allMatch) {
                attachBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
            } else if (validation.recommendation === 'reject') {
                attachBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
                attachBtn.textContent = '‚ö†Ô∏è Attach Anyway';
            } else {
                attachBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            }
        }

        /**
         * Perform validation on loaded PDF
         */
        async function performInvoiceValidation(pdfBlob, transaction) {
            try {
                console.log('üîç [VALIDATE] Starting invoice validation...');

                // Show validation container with loading state
                const container = document.getElementById('validationResultsContainer');
                container.style.display = 'block';

                // Extract text from PDF
                const extractedText = await extractTextFromPDF(pdfBlob);

                if (!extractedText || extractedText.trim().length < 20) {
                    throw new Error('Insufficient text extracted from PDF');
                }

                // Extract structured data
                const extractedData = await extractStructuredDataFromInvoice(extractedText);

                if (!extractedData) {
                    throw new Error('Failed to extract structured data');
                }

                // Validate against transaction
                const validation = await validateInvoiceData(extractedData, transaction);

                if (!validation) {
                    throw new Error('Validation failed');
                }

                // Store validation results
                currentAttachmentData.validation = validation;
                currentAttachmentData.extractedData = extractedData;

                // Display results
                displayValidationResults(validation, extractedData, transaction);

                console.log('‚úÖ [VALIDATE] Validation complete and displayed');

            } catch (error) {
                console.error('‚ùå [VALIDATE] Validation error:', error);

                // Show error state
                const container = document.getElementById('validationResultsContainer');
                container.style.display = 'block';
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: #fef2f2; border-radius: 8px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                        <div style="color: #dc2626; font-weight: 600;">Validation Failed</div>
                        <div style="color: #64748b; font-size: 14px; margin-top: 5px;">
                            ${error.message || 'Unable to validate invoice automatically'}
                        </div>
                        <div style="color: #64748b; font-size: 13px; margin-top: 10px;">
                            You can still attach this invoice manually.
                        </div>
                    </div>
                `;
            }
        }

        /**
         * Preview PDF and prepare for attachment
         */
        async function previewAndAttachInvoice(transactionIndex, messageId, attachmentId, filename, accountEmail) {
            console.log('üìÑ [PREVIEW] Opening PDF preview...', { messageId, attachmentId, filename });

            try {
                // Store attachment details for later confirmation
                currentAttachmentData = {
                    transactionIndex,
                    messageId,
                    attachmentId,
                    filename,
                    accountEmail
                };

                // Show modal with loading state
                const modal = document.getElementById('pdfPreviewModal');
                const iframe = document.getElementById('pdfViewerIframe');
                document.getElementById('pdfPreviewTitle').textContent = `Preview: ${filename}`;

                modal.style.display = 'flex';
                iframe.src = '';  // Clear previous PDF

                // Show loading message
                const container = document.getElementById('pdfViewerContainer');
                container.innerHTML = `<div style="text-align: center; color: #64748b;">
                    <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
                    <div>Loading PDF...</div>
                </div>`;

                let pdfBlob, extractedData, validation, ocrText;

                // Check if we already processed this PDF (from automatic search)
                const dataKey = `${messageId}_${attachmentId}`;
                const processedData = window.processedInvoiceData?.[dataKey];

                if (processedData && processedData.pdfBlob) {
                    console.log('‚úÖ [PREVIEW] Using cached PDF data (already processed)');
                    pdfBlob = processedData.pdfBlob;
                    extractedData = processedData.extractedData;
                    validation = processedData.validation;
                    ocrText = processedData.ocrText;
                } else {
                    console.log('üì• [PREVIEW] Downloading PDF from Gmail...');

                    // Find account and set access token
                    const account = gmailAccounts.find(acc => acc.email === accountEmail);
                    if (!account || !account.accessToken) {
                        throw new Error(`No valid access token for account: ${accountEmail}`);
                    }
                    gapi.client.setToken({ access_token: account.accessToken });
                    console.log('üîë [PREVIEW] Set token for:', accountEmail);

                    // Download PDF from Gmail
                    const response = await gapi.client.gmail.users.messages.attachments.get({
                        userId: 'me',
                        messageId: messageId,
                        id: attachmentId
                    });

                    // Decode base64 PDF data
                    const data = response.result.data;
                    const pdfData = data.replace(/-/g, '+').replace(/_/g, '/');
                    pdfBlob = base64ToBlob(pdfData, 'application/pdf');
                }

                // Create blob URL and show in iframe
                const blobUrl = URL.createObjectURL(pdfBlob);

                // Restore iframe
                container.innerHTML = `<iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>`;
                const newIframe = document.getElementById('pdfViewerIframe');
                newIframe.src = blobUrl;

                // Store blob for later save
                currentAttachmentData.pdfBlob = pdfBlob;
                currentAttachmentData.blobUrl = blobUrl;
                currentAttachmentData.extractedData = extractedData;
                currentAttachmentData.validation = validation;

                console.log('‚úÖ [PREVIEW] PDF loaded successfully');

                // If we already have validation data, display it immediately
                const transaction = allTransactions[transactionIndex];
                if (validation && extractedData) {
                    console.log('‚úÖ [PREVIEW] Using cached validation results');
                    displayValidationResults(validation, extractedData, transaction);
                } else {
                    // Trigger automatic validation (fallback for manual uploads or uncached PDFs)
                    console.log('üîç [PREVIEW] Running validation...');
                    await performInvoiceValidation(pdfBlob, transaction);
                }

            } catch (error) {
                console.error('Error loading PDF preview:', error);
                showToast('‚ùå Failed to load PDF preview', 'error');
                closePDFPreview();
            }
        }

        /**
         * Confirm and attach invoice to transaction
         */
        async function confirmAttachInvoice() {
            if (!currentAttachmentData) {
                showToast('‚ùå No invoice data available', 'error');
                return;
            }

            console.log('üíæ [ATTACH] Attaching invoice to transaction...', currentAttachmentData);

            try {
                const { transactionIndex, messageId, filename, pdfBlob, validation, extractedData } = currentAttachmentData;

                // Disable button during processing
                const attachBtn = document.getElementById('attachInvoiceBtn');
                const originalBtnText = attachBtn.textContent;
                attachBtn.disabled = true;
                attachBtn.textContent = '‚è≥ Attaching...';

                // Save PDF to IndexedDB
                const invoiceId = await saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId);

                // Extract text from PDF (might already be done during validation)
                const extractedText = await extractTextFromPDF(pdfBlob);

                // Generate AI description
                const aiDescription = await generateDescriptionFromInvoice(extractedText, allTransactions[transactionIndex]);

                // Store invoice ID in transaction for future access
                allTransactions[transactionIndex].invoiceId = invoiceId;
                allTransactions[transactionIndex].invoiceFilename = filename;

                // Update transaction detail with AI-generated 2-10 word description
                if (aiDescription) {
                    allTransactions[transactionIndex].detail = aiDescription;
                }

                // Update From/To (supplier) with extracted company name
                if (extractedData && extractedData.company) {
                    allTransactions[transactionIndex].fromTo = extractedData.company;
                }

                // Log validation results for audit trail
                if (validation) {
                    console.log('üìä [ATTACH] Validation results:', {
                        invoiceId,
                        extractedData,
                        validation,
                        decision: 'attached'
                    });

                    // Optionally store validation data in invoice record
                    if (invoiceId && extractedData) {
                        await updateInvoiceWithValidationData(invoiceId, extractedData, validation);
                    }
                }

                // Save updated transactions
                await saveTransactionsToStorage();

                // Update UI
                renderTransactions();

                // Close modals
                closePDFPreview();
                closeIntelligentSearchModal();

                // Show success message with validation status
                let successMessage = `‚úÖ Invoice "${filename}" attached successfully!`;
                if (validation) {
                    if (validation.recommendation === 'attach') {
                        successMessage += ' (AI validated ‚úì)';
                    } else if (validation.recommendation === 'review') {
                        successMessage += ' (Manual review recommended)';
                    }
                }
                showToast(successMessage, 'success');

                console.log('‚úÖ [ATTACH] Invoice attached successfully, ID:', invoiceId);

            } catch (error) {
                console.error('Error attaching invoice:', error);
                showToast(`‚ùå Failed to attach invoice: ${error.message}`, 'error');

                // Re-enable button
                const attachBtn = document.getElementById('attachInvoiceBtn');
                attachBtn.disabled = false;
                attachBtn.textContent = '‚úÖ Attach Invoice';
            }
        }

        /**
         * Open an already-attached invoice from IndexedDB
         */
        async function openAttachedInvoice(transactionIndex) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.invoiceId) {
                showToast('‚ùå No invoice attached to this transaction', 'error');
                return;
            }

            console.log('üìÑ [VIEW] Opening attached invoice...', { invoiceId: transaction.invoiceId, filename: transaction.invoiceFilename });

            try {
                // Load invoice from IndexedDB
                const invoice = await getInvoiceFromDB(transaction.invoiceId);

                if (!invoice || !invoice.pdfBlob) {
                    showToast('‚ùå Invoice not found in database', 'error');
                    return;
                }

                // Show PDF preview modal
                const modal = document.getElementById('pdfPreviewModal');
                const iframe = document.getElementById('pdfViewerIframe');
                document.getElementById('pdfPreviewTitle').textContent = `Invoice: ${transaction.invoiceFilename || 'invoice.pdf'}`;

                modal.style.display = 'flex';

                // Create blob URL and show in iframe
                const blobUrl = URL.createObjectURL(invoice.pdfBlob);
                const container = document.getElementById('pdfViewerContainer');
                container.innerHTML = `<iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>`;
                const newIframe = document.getElementById('pdfViewerIframe');
                newIframe.src = blobUrl;

                // Hide validation section and attach button for viewing mode
                const validationContainer = document.getElementById('validationResultsContainer');
                if (validationContainer) {
                    validationContainer.style.display = 'none';
                }

                // Hide the attach button footer (since it's already attached)
                const attachFooter = document.querySelector('#pdfPreviewModal .modal-footer');
                if (attachFooter) {
                    attachFooter.style.display = 'none';
                }

                console.log('‚úÖ [VIEW] Invoice loaded successfully');

            } catch (error) {
                console.error('Error loading attached invoice:', error);
                showToast('‚ùå Failed to load invoice', 'error');
            }
        }

        /**
         * Get invoice from IndexedDB
         */
        async function getInvoiceFromDB(invoiceId) {
            if (!db) await initIndexedDB();

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['invoices'], 'readonly');
                const store = transaction.objectStore('invoices');
                const request = store.get(invoiceId);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        /**
         * Close PDF preview modal
         */
        function closePDFPreview() {
            const modal = document.getElementById('pdfPreviewModal');
            modal.style.display = 'none';

            // Restore attach button footer for next use
            const attachFooter = document.querySelector('#pdfPreviewModal .modal-footer');
            if (attachFooter) {
                attachFooter.style.display = 'block';
            }

            // Reset validation UI
            const validationContainer = document.getElementById('validationResultsContainer');
            if (validationContainer) {
                validationContainer.style.display = 'none';

                // Reset all validation fields to default state
                ['company', 'amount', 'date'].forEach(field => {
                    const statusEl = document.getElementById(`${field}Status`);
                    const reasonEl = document.getElementById(`${field}Reason`);
                    const validationEl = document.getElementById(`${field}Validation`);

                    if (statusEl) statusEl.textContent = '‚è≥';
                    if (reasonEl) reasonEl.textContent = 'Analyzing...';
                    if (validationEl) {
                        validationEl.style.background = '#f8fafc';
                        validationEl.style.borderColor = '#e5e7eb';
                    }
                });

                // Reset recommendation
                const recommendationContainer = document.getElementById('validationRecommendation');
                if (recommendationContainer) {
                    recommendationContainer.style.background = '#f0f9ff';
                    recommendationContainer.style.borderColor = '#3b82f6';
                }

                const recommendationIcon = document.getElementById('recommendationIcon');
                const recommendationText = document.getElementById('recommendationText');
                if (recommendationIcon) recommendationIcon.textContent = 'ü§ñ';
                if (recommendationText) recommendationText.textContent = 'Analyzing invoice...';
            }

            // Reset attach button
            const attachBtn = document.getElementById('attachInvoiceBtn');
            if (attachBtn) {
                attachBtn.disabled = false;
                attachBtn.textContent = '‚úÖ Attach Invoice';
                attachBtn.style.background = '';
            }

            // Clean up blob URL
            if (currentAttachmentData && currentAttachmentData.blobUrl) {
                URL.revokeObjectURL(currentAttachmentData.blobUrl);
            }

            currentAttachmentData = null;
        }

        /**
         * Store validation data with invoice in IndexedDB
         */
        async function updateInvoiceWithValidationData(invoiceId, extractedData, validation) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.extractedData = extractedData;
                        invoice.validationResults = validation;
                        invoice.validatedAt = new Date().toISOString();
                        store.put(invoice);
                        console.log('‚úÖ [DB] Validation data stored with invoice');
                    }
                };
            } catch (error) {
                console.error('Error updating invoice with validation data:', error);
            }
        }

        /**
         * Convert base64 to Blob
         */
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteArrays = [];

            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                const slice = byteCharacters.slice(offset, offset + 512);
                const byteNumbers = new Array(slice.length);

                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mimeType });
        }

        // ========================================
        // ADVANCED PDF TEXT EXTRACTION WITH OCR
        // ========================================

        /**
         * Extract text from PDF with OCR fallback
         */
        async function extractTextFromPDFAdvanced(pdfBlob) {
            console.log('üìÑ [EXTRACT] Starting advanced PDF text extraction...');

            try {
                // Method 1: Try PDF.js text extraction first (faster)
                const pdfText = await extractTextWithPDFjs(pdfBlob);

                if (pdfText && pdfText.length > 50) {
                    console.log('‚úÖ [EXTRACT] PDF.js extraction successful:', pdfText.length, 'characters');
                    return pdfText;
                }

                console.log('‚ö†Ô∏è [EXTRACT] PDF.js returned insufficient text, trying OCR...');

                // Method 2: Use OCR as fallback (slower but handles scanned PDFs)
                const ocrText = await extractTextWithOCR(pdfBlob);
                console.log('‚úÖ [EXTRACT] OCR extraction successful:', ocrText.length, 'characters');
                return ocrText;

            } catch (error) {
                console.error('‚ùå [EXTRACT] Text extraction failed:', error);
                return '';
            }
        }

        /**
         * Extract text using PDF.js
         */
        async function extractTextWithPDFjs(pdfBlob) {
            const arrayBuffer = await pdfBlob.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n';
            }

            return fullText.trim();
        }

        /**
         * Extract text using Tesseract OCR
         */
        async function extractTextWithOCR(pdfBlob) {
            // Convert PDF first page to image
            const arrayBuffer = await pdfBlob.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1); // OCR first page only for speed

            const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            // Run Tesseract OCR on the canvas
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                logger: m => console.log('OCR Progress:', m)
            });

            return text;
        }

        /**
         * Parse invoice data using AI
         */
        async function parseInvoiceWithAI(extractedText, transaction) {
            console.log('ü§ñ [AI PARSE] Analyzing invoice text with AI...');

            try {
                const apiKey = getOpenAIKey();
                if (!apiKey) {
                    console.log('‚ö†Ô∏è [AI PARSE] No API key, skipping AI parsing');
                    return null;
                }

                const prompt = `Extract the following information from this invoice text. Return ONLY valid JSON, nothing else.

Invoice Text:
${extractedText.substring(0, 3000)}

Expected Transaction:
- Date: ${transaction.date}
- Amount: ¬£${transaction.spent || transaction.received}
- Merchant: ${transaction.description}

Return JSON with this exact structure:
{
  "invoiceDate": "DD/MM/YYYY",
  "invoiceAmount": "35.00",
  "companyName": "Google",
  "currency": "GBP",
  "invoiceNumber": "...",
  "confidence": "high|medium|low"
}

If you cannot find a field, use null. Be precise with the amount (don't include currency symbols in the amount field).`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an invoice data extraction expert. Always return valid JSON only, no markdown or explanation.'
                            },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 300,
                        temperature: 0.1
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                let jsonStr = data.choices[0].message.content.trim();

                // Remove markdown code blocks if present
                jsonStr = jsonStr.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                const invoiceData = JSON.parse(jsonStr);
                console.log('‚úÖ [AI PARSE] Invoice data extracted:', invoiceData);

                return invoiceData;

            } catch (error) {
                console.error('‚ùå [AI PARSE] Failed to parse invoice:', error);
                return null;
            }
        }

        /**
         * Score invoice using actual PDF data (AI-enhanced)
         */
        function scoreInvoiceWithPDFData(invoiceData, transaction, context) {
            if (!invoiceData) {
                return null; // Fall back to email-based scoring
            }

            let score = 0;
            const scoring = {
                company: 0,
                amount: 0,
                date: 0,
                details: {}
            };

            // 1. COMPANY NAME MATCH (max 40 points)
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
            if (invoiceData.companyName) {
                const companyLower = invoiceData.companyName.toLowerCase();
                const merchantLower = merchantKeyword.toLowerCase();

                if (companyLower.includes(merchantLower) || merchantLower.includes(companyLower)) {
                    score += 40;
                    scoring.company = 40;
                    scoring.details.companyMatch = `‚úì PDF shows "${invoiceData.companyName}"`;
                } else {
                    scoring.details.companyMatch = `‚ö† PDF shows "${invoiceData.companyName}" (expected ${merchantKeyword})`;
                }
            } else {
                scoring.details.companyMatch = `? Company not found in PDF`;
            }

            // 2. AMOUNT MATCH (max 35 points)
            if (invoiceData.invoiceAmount) {
                const pdfAmount = parseFloat(invoiceData.invoiceAmount);
                const txAmount = context.amount;

                if (Math.abs(pdfAmount - txAmount) < 0.01) { // Exact match
                    score += 35;
                    scoring.amount = 35;
                    scoring.details.amountMatch = `‚úì PDF shows ¬£${pdfAmount.toFixed(2)} (exact match!)`;
                } else if (Math.abs(pdfAmount - txAmount) < 1.0) { // Within ¬£1
                    score += 25;
                    scoring.amount = 25;
                    scoring.details.amountMatch = `~ PDF shows ¬£${pdfAmount.toFixed(2)} (close match)`;
                } else {
                    scoring.details.amountMatch = `‚úó PDF shows ¬£${pdfAmount.toFixed(2)} (expected ¬£${txAmount.toFixed(2)})`;
                }
            } else {
                scoring.details.amountMatch = `? Amount not found in PDF`;
            }

            // 3. DATE PROXIMITY (max 25 points)
            if (invoiceData.invoiceDate) {
                try {
                    const parts = invoiceData.invoiceDate.split('/');
                    const pdfDate = new Date(parts[2], parts[1] - 1, parts[0]);
                    const txDate = context.date;
                    const daysDiff = Math.abs(Math.floor((pdfDate - txDate) / (1000 * 60 * 60 * 24)));

                    if (daysDiff === 0) {
                        score += 25;
                        scoring.date = 25;
                        scoring.details.dateMatch = `‚úì PDF date: ${invoiceData.invoiceDate} (same day!)`;
                    } else if (daysDiff <= 2) {
                        score += 20;
                        scoring.date = 20;
                        scoring.details.dateMatch = `‚úì PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    } else if (daysDiff <= 5) {
                        score += 15;
                        scoring.date = 15;
                        scoring.details.dateMatch = `~ PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    } else {
                        score += 5;
                        scoring.date = 5;
                        scoring.details.dateMatch = `‚ö† PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    }
                } catch (error) {
                    scoring.details.dateMatch = `? Could not parse PDF date: ${invoiceData.invoiceDate}`;
                }
            } else {
                scoring.details.dateMatch = `? Date not found in PDF`;
            }

            scoring.total = score;
            scoring.source = 'PDF_AI_ANALYSIS';
            scoring.invoiceNumber = invoiceData.invoiceNumber;

            return scoring;
        }

        /**
         * Generate smart search keywords using AI
         */
        async function generateAISearchKeywords(context) {
            try {
                // Use existing API key mechanism
                const apiKey = getOpenAIKey();
                if (!apiKey) {
                    console.log('No API key, skipping AI enhancement');
                    return null;
                }

                const prompt = `Given this purchase transaction, generate 5-7 search keywords that would appear in an invoice or receipt email.

Transaction details:
- Merchant: ${context.merchantName}
- Amount: ¬£${context.amount}
- Description: ${context.description}
${context.fromTo ? `- From/To: ${context.fromTo}` : ''}
${context.userContext ? `- Project: ${context.userContext}` : ''}
${context.userNotes ? `- User Notes: ${context.userNotes}` : ''}

Consider:
- Product/service names
- Order number patterns
- Common email subject line phrases
- Transaction confirmation phrases
- Any specific details mentioned in user notes

Return ONLY a comma-separated list of keywords, no explanation.`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a search keyword generator. Return only comma-separated keywords, nothing else.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 100,
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const keywords = data.choices[0].message.content.trim().split(',').map(k => k.trim());

                return keywords.slice(0, 7); // Limit to 7 keywords

            } catch (error) {
                console.error('AI keyword generation failed:', error);
                searchLogger.logProgress('AI enhancement skipped (no API key or error)', 'warning');
                return null; // Graceful fallback - continue without AI
            }
        }

        // ========================================
        // INVOICE SEARCH UI HANDLERS
        // ========================================

        /**
         * Show styled Gmail connection alert
         */
        function showGmailConnectionAlert(transactionIndex) {
            const transaction = allTransactions[transactionIndex];
            const modal = document.getElementById('intelligentSearchModal');
            const modalTitle = document.getElementById('searchModalTitle');
            const searchLogContainer = document.getElementById('searchLogContainer');
            const searchProgressBar = document.getElementById('searchProgressBar');
            const resultsContainer = document.getElementById('searchResultsContainer');
            const actionButtons = document.getElementById('searchActionButtons');

            // Show modal
            modal.style.display = 'flex';

            // Update title
            modalTitle.textContent = 'Gmail Connection Required';

            // Hide log and progress (but keep them in collapsed state)
            const logHeader = document.getElementById('searchLogHeader');
            if (logHeader) logHeader.style.display = 'none';
            searchLogContainer.style.display = 'none';
            searchProgressBar.style.display = 'none';

            // Populate transaction summary
            document.getElementById('searchTxDate').textContent = transaction.date || 'N/A';
            document.getElementById('searchTxAmount').textContent = `¬£${transaction.spent || transaction.received || '0'}`;
            document.getElementById('searchTxDesc').textContent = transaction.description || 'No description';

            // Show From/To if available
            if (transaction.from_to) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = transaction.from_to;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Show user notes if available
            if (transaction.manualDescription) {
                document.getElementById('searchTxNotesContainer').style.display = 'block';
                document.getElementById('searchTxNotes').textContent = transaction.manualDescription;
            } else {
                document.getElementById('searchTxNotesContainer').style.display = 'none';
            }

            // Show connection alert
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; border: 3px solid #f59e0b; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);">
                    <div style="font-size: 64px; margin-bottom: 20px; animation: bounce 1s ease-in-out infinite;">üìß</div>
                    <h3 style="margin: 0 0 15px 0; color: #92400e; font-size: 24px; font-weight: 700;">
                        Gmail Not Connected
                    </h3>
                    <p style="color: #78350f; margin: 0 0 25px 0; font-size: 15px; line-height: 1.6; max-width: 400px; margin-left: auto; margin-right: auto;">
                        You need to connect your Gmail account to search for invoices automatically.
                        This allows the app to find matching invoices in your email.
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px; max-width: 300px; margin: 0 auto;">
                        <button onclick="connectGmailAndRetry(${transactionIndex})"
                            style="background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); color: white; padding: 14px 24px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 15px; box-shadow: 0 4px 10px rgba(58, 175, 169, 0.3); transition: all 0.2s;"
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(58, 175, 169, 0.4)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 10px rgba(58, 175, 169, 0.3)'">
                            üîó Connect Gmail Now
                        </button>
                        <button onclick="closeIntelligentSearchModal()"
                            style="background: #f3f4f6; color: #64748b; padding: 12px 24px; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s;"
                            onmouseover="this.style.background='#e5e7eb'"
                            onmouseout="this.style.background='#f3f4f6'">
                            Cancel
                        </button>
                    </div>

                    <div style="margin-top: 25px; padding: 15px; background: rgba(255, 255, 255, 0.6); border-radius: 8px; border-left: 4px solid #3AAFA9;">
                        <div style="font-size: 12px; color: #475569; text-align: left;">
                            <strong style="color: #1e293b; display: block; margin-bottom: 8px;">‚ÑπÔ∏è What happens next:</strong>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                                <li>You'll be asked to sign in to your Gmail account</li>
                                <li>Grant permission to read emails (search only)</li>
                                <li>Invoice search will start automatically</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <style>
                    @keyframes bounce {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(-10px); }
                    }
                </style>
            `;

            // Update action buttons
            actionButtons.innerHTML = '';
        }

        /**
         * Connect Gmail and retry invoice search
         */
        async function connectGmailAndRetry(transactionIndex) {
            console.log('üîó [CONNECT] Initiating Gmail connection from alert...');

            // Update modal to show connecting status
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px 20px;">
                    <div style="font-size: 48px; margin-bottom: 20px; animation: spin 2s linear infinite;">‚è≥</div>
                    <h4 style="margin: 0 0 10px 0; color: #1e293b;">Connecting to Gmail...</h4>
                    <p style="color: #64748b; font-size: 14px;">Please complete the sign-in process in the popup window.</p>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;

            try {
                // Attempt Gmail sign-in
                await signInToGmail();

                // Wait for auth to complete
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Check if connection was successful
                if (gmailAccounts.length > 0) {
                    console.log('‚úÖ [CONNECT] Gmail connected successfully, starting search...');

                    // Close the alert modal
                    closeIntelligentSearchModal();

                    // Show success toast
                    showToast('‚úÖ Gmail connected! Starting invoice search...', 'success');

                    // Wait a moment then trigger the search
                    setTimeout(() => {
                        handleInvoiceFetch(transactionIndex);
                    }, 500);
                } else {
                    console.warn('‚ö†Ô∏è [CONNECT] Gmail connection incomplete');
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px; background: #fef2f2; border-radius: 12px; border: 2px solid #dc2626;">
                            <div style="font-size: 48px; margin-bottom: 15px;">‚ùå</div>
                            <h4 style="margin: 0 0 10px 0; color: #991b1b;">Connection Failed</h4>
                            <p style="color: #7f1d1d; margin: 0 0 20px 0;">
                                Unable to connect to Gmail. Please try again or check your browser permissions.
                            </p>
                            <div style="display: flex; gap: 10px; justify-content: center;">
                                <button onclick="connectGmailAndRetry(${transactionIndex})" class="btn-primary">
                                    Try Again
                                </button>
                                <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                    Close
                                </button>
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('‚ùå [CONNECT] Gmail connection error:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; background: #fef2f2; border-radius: 12px; border: 2px solid #dc2626;">
                        <div style="font-size: 48px; margin-bottom: 15px;">‚ùå</div>
                        <h4 style="margin: 0 0 10px 0; color: #991b1b;">Connection Error</h4>
                        <p style="color: #7f1d1d; margin: 0 0 20px 0;">
                            ${error.message || 'An error occurred while connecting to Gmail.'}
                        </p>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="connectGmailAndRetry(${transactionIndex})" class="btn-primary">
                                Try Again
                            </button>
                            <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                Close
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        async function handleInvoiceFetch(index) {
            const transaction = allTransactions[index];
            currentInvoiceSearchIndex = index;

            // Check if Gmail is connected
            if (gmailAccounts.length === 0) {
                // Show styled alert modal instead of basic confirm
                showGmailConnectionAlert(index);
                return;
            }

            // Update button state
            const btn = document.getElementById(`invoiceBtn${index}`);
            if (btn) {
                btn.classList.add('searching');
                btn.textContent = '‚è≥';
            }

            // Show new intelligent search modal
            showIntelligentSearchModal(transaction, index);

            // Re-enable button after a short delay
            setTimeout(() => {
                if (btn) {
                    btn.classList.remove('searching');
                    btn.textContent = 'üìß';
                }
            }, 1000);
        }

        async function displayInvoiceSearchResults(messages, transaction) {
            const selectedCount = gmailAccounts.filter(acc => acc.selected).length;
            let html = `<div style="font-weight: 600; margin-bottom: 10px;">Found ${messages.length} potential match(es) across ${selectedCount} account(s):</div>`;

            for (const msg of messages) {
                try {
                    // Get the access token for this message's account
                    const account = gmailAccounts.find(acc => acc.email === msg.accountEmail);
                    if (!account) continue;

                    // Set the access token for Gmail API calls
                    gapi.client.setToken({ access_token: account.accessToken });

                    // Get full message details
                    const messageDetail = await gapi.client.gmail.users.messages.get({
                        userId: 'me',
                        id: msg.id,
                        format: 'metadata',
                        metadataHeaders: ['From', 'Subject', 'Date']
                    });

                    const headers = messageDetail.result.payload.headers;
                    const from = headers.find(h => h.name === 'From')?.value || 'Unknown';
                    const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    // Extract PDFs
                    const pdfs = await extractPDFsFromEmail(msg.id, account.accessToken);

                    html += `
                        <div class="invoice-result-card">
                            <div style="font-size: 12px; color: #3AAFA9; margin-bottom: 5px;">
                                <strong>Account:</strong> ${escapeHtml(msg.accountEmail)}
                            </div>
                            <div style="font-weight: 600; margin-bottom: 5px;">üìß ${escapeHtml(subject)}</div>
                            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">
                                <strong>From:</strong> ${escapeHtml(from)}<br>
                                <strong>Date:</strong> ${date}
                            </div>
                    `;

                    if (pdfs.length > 0) {
                        html += `<div style="margin-top: 10px;"><strong>Attachments (${pdfs.length}):</strong></div>`;
                        pdfs.forEach((pdf) => {
                            html += `
                                <button
                                    onclick="attachInvoiceToTransaction('${msg.id}', '${pdf.attachmentId}', '${escapeHtml(pdf.filename)}', ${currentInvoiceSearchIndex}, '${escapeHtml(msg.accountEmail)}')"
                                    class="modal-btn modal-btn-primary pdf-attachment-btn">
                                    üìé ${escapeHtml(pdf.filename)} (${formatFileSize(pdf.size)})
                                </button>
                            `;
                        });
                    } else {
                        html += `<div style="color: #999; font-style: italic;">No PDF attachments</div>`;
                    }

                    html += `</div>`;
                } catch (error) {
                    console.error('Error processing message:', msg.id, error);
                }
            }

            document.getElementById('invoiceSearchResults').innerHTML = html;
        }

        async function attachInvoiceToTransaction(messageId, attachmentId, filename, transactionIndex, accountEmail) {
            try {
                showToast('‚è≥ Downloading invoice...', 'info');

                // Get the access token for this account
                const account = gmailAccounts.find(acc => acc.email === accountEmail);
                if (!account) {
                    showToast('‚ùå Account not found', 'error');
                    return;
                }

                // Download PDF
                const pdfBlob = await downloadPDFAttachment(messageId, attachmentId, account.accessToken);
                if (!pdfBlob) {
                    showToast('‚ùå Failed to download invoice', 'error');
                    return;
                }

                // Save to IndexedDB
                const invoiceId = await saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId);

                // Extract text
                showToast('üìÑ Extracting text from invoice...', 'info');
                const extractedText = await extractTextFromPDF(pdfBlob);

                if (extractedText) {
                    // Update invoice with extracted text
                    await updateInvoiceText(invoiceId, extractedText);

                    // Generate AI description
                    showToast('ü§ñ Generating description...', 'info');
                    const aiDescription = await generateDescriptionFromInvoice(
                        extractedText,
                        allTransactions[transactionIndex]
                    );

                    if (aiDescription) {
                        await updateInvoiceWithAIDescription(invoiceId, aiDescription);

                        // Apply description to transaction
                        allTransactions[transactionIndex].manualDescription = aiDescription;
                        renderTransactions();
                    }
                }

                showToast('‚úÖ Invoice attached successfully!', 'success');
                closeInvoiceSearchModal();

                // Update button to show attachment
                const btn = document.getElementById(`invoiceBtn${transactionIndex}`);
                if (btn) {
                    btn.classList.add('invoice-attached');
                }

            } catch (error) {
                console.error('Error attaching invoice:', error);
                showToast('‚ùå Failed to attach invoice', 'error');
            }
        }

        async function handleManualInvoiceUpload() {
            const fileInput = document.getElementById('manualInvoiceUpload');
            const file = fileInput.files[0];

            if (!file || file.type !== 'application/pdf') {
                showToast('‚ùå Please select a PDF file', 'error');
                return;
            }

            if (currentInvoiceSearchIndex === null) {
                showToast('‚ùå No transaction selected', 'error');
                return;
            }

            try {
                showToast('‚è≥ Uploading invoice...', 'info');

                const pdfBlob = new Blob([await file.arrayBuffer()], { type: 'application/pdf' });
                const invoiceId = await saveInvoiceToDB(currentInvoiceSearchIndex, pdfBlob, file.name, null);

                // Extract and process
                showToast('üìÑ Extracting text from invoice...', 'info');
                const extractedText = await extractTextFromPDF(pdfBlob);

                if (extractedText) {
                    await updateInvoiceText(invoiceId, extractedText);

                    showToast('ü§ñ Generating description...', 'info');
                    const aiDescription = await generateDescriptionFromInvoice(
                        extractedText,
                        allTransactions[currentInvoiceSearchIndex]
                    );

                    if (aiDescription) {
                        await updateInvoiceWithAIDescription(invoiceId, aiDescription);
                        allTransactions[currentInvoiceSearchIndex].manualDescription = aiDescription;
                        renderTransactions();
                    }
                }

                showToast('‚úÖ Invoice uploaded successfully!', 'success');
                closeInvoiceSearchModal();

                const btn = document.getElementById(`invoiceBtn${currentInvoiceSearchIndex}`);
                if (btn) {
                    btn.classList.add('invoice-attached');
                }

            } catch (error) {
                console.error('Manual upload error:', error);
                showToast('‚ùå Failed to upload invoice', 'error');
            } finally {
                fileInput.value = ''; // Reset input
            }
        }

        function closeInvoiceSearchModal() {
            document.getElementById('invoiceSearchModal').classList.remove('active');
            currentInvoiceSearchIndex = null;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Close invoice modal when clicking outside
        document.getElementById('invoiceSearchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeInvoiceSearchModal();
            }
        });

        // Initialize Google Auth when page loads
        window.addEventListener('load', () => {
            initializeGoogleAuth();
        });
    </script>
    </div>

    <!-- Keyboard Shortcuts Hint -->
    <div id="keyboardHint" class="keyboard-shortcut-hint" style="display: none;">
        <div style="font-weight: 600; margin-bottom: 6px;">‚å®Ô∏è Keyboard Shortcuts</div>
        <div style="font-size: 11px; opacity: 0.9;">
            <div>‚Üë‚Üì Navigate rows</div>
            <div><kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">A</kbd> Assign</div>
            <div><kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">Esc</kbd> Close</div>
            <div>Type letters to search</div>
        </div>
    </div>

    <script>
        // Show keyboard hint when user first interacts with keyboard
        let hintShown = false;
        document.addEventListener('keydown', function showHintOnce(e) {
            if (!hintShown && (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'a' || e.key === 'A')) {
                const hint = document.getElementById('keyboardHint');
                hint.style.display = 'block';
                hint.classList.add('visible');
                hintShown = true;

                setTimeout(() => {
                    hint.classList.remove('visible');
                    setTimeout(() => {
                        hint.style.display = 'none';
                    }, 300);
                }, 4000);

                document.removeEventListener('keydown', showHintOnce);
            }
        });
    </script>
</body>
</html>
