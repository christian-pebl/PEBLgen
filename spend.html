<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spend</title>
    <!-- Google Fonts - PEBL Brand Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400&display=swap" rel="stylesheet">

    <!-- External Libraries for Gmail & PDF Processing -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        .nav-banner { position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); padding: 15px 40px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 30px; margin-bottom: 0; z-index: 100; }
        .nav-banner .page-title { color: white; font-size: 28px; font-weight: 700; margin: 0; font-family: 'Roboto', sans-serif; letter-spacing: 0.5px; }
        .nav-banner h1 { color: white; font-size: 28px; font-weight: 700; margin: 0; font-family: 'Roboto', sans-serif; letter-spacing: 0.5px; }
        .nav-buttons { display: flex; gap: 8px; }
        .nav-btn { background-color: rgba(255, 255, 255, 0.15); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; display: inline-block; font-family: 'Roboto', sans-serif; }
        .nav-btn:hover { background-color: rgba(255, 255, 255, 0.25); border-color: rgba(255, 255, 255, 0.5); }
        .nav-btn.active { background-color: rgba(255, 255, 255, 0.9); color: #2B7A78; border-color: rgba(255, 255, 255, 0.9); }
        .content-container { padding: 20px; max-width: 1200px; margin: 0 auto; padding-top: 90px; }

        body {
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #DEF2F1 0%, #ffffff 100%);
            min-height: 100vh;
        }

        /* Upload Section */
        .upload-section {
            background-color: #f5f5f5;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px dashed #3AAFA9;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .upload-section.drag-over {
            background-color: #e8eaf6;
            border-color: #2B7A78;
            border-width: 3px;
            transform: scale(1.02);
        }
        .upload-section p {
            margin: 10px 0 0 0;
            color: #666;
            font-size: 14px;
        }
        .upload-label {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Table Container */
        .table-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-x: auto;
            overflow-y: hidden;
        }
        #transactionsTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            table-layout: auto;
        }
        #transactionsTable thead {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
        }
        #transactionsTable th {
            padding: 6px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-sizing: border-box;
        }
        #transactionsTable tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s ease;
        }
        #transactionsTable tbody tr:hover {
            background-color: #f8f9ff;
        }
        #transactionsTable tbody tr.row-selected {
            background-color: #e0f2fe !important;
            border-left: 4px solid #3b82f6;
        }
        #transactionsTable tbody tr.row-flagged-red {
            background-color: #fee2e2 !important;
            border-left: 4px solid #ef4444;
        }
        #transactionsTable tbody tr.row-flagged-red:hover {
            background-color: #fecaca !important;
        }
        #transactionsTable tbody tr.row-flagged-blue {
            background-color: #dbeafe !important;
            border-left: 4px solid #3b82f6;
        }
        #transactionsTable tbody tr.row-flagged-blue:hover {
            background-color: #bfdbfe !important;
        }

        /* Highlight animation for transaction rows (from grants page navigation) */
        @keyframes highlightGlow {
            0% {
                background: #dbeafe;
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }
            50% {
                background: #bfdbfe;
                box-shadow: 0 0 20px 10px rgba(59, 130, 246, 0.4);
            }
            100% {
                background: #dbeafe;
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }
        }

        #transactionsTable td {
            padding: 6px;
            vertical-align: middle;
            box-sizing: border-box;
        }
        #transactionsTable td.notes-cell {
            max-width: 200px;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 11px;
            color: #555;
            display: none;
        }
        .empty-state td {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }
        .description-detail-cell {
            padding: 6px;
            vertical-align: middle;
        }
        .description-detail-cell > div {
            margin-bottom: 2px;
        }
        .description-detail-cell > div:last-child {
            margin-bottom: 0;
        }
        .description-cell {
            min-width: 200px;
            max-width: 600px;
            font-size: 11px;
            /* Clip text after 3 lines */
            display: -webkit-box !important;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
            word-wrap: break-word;
        }
        .description-cell span {
            /* Ensure span doesn't break line-clamp */
            display: inline;
            white-space: normal;
        }
        .detail-cell {
            min-width: 200px;
            max-width: 600px;
            font-size: 11px;
            /* Clip text after 3 lines */
            display: -webkit-box !important;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
            word-wrap: break-word;
        }
        .detail-cell span {
            /* Ensure span doesn't break line-clamp */
            display: inline;
            white-space: normal;
        }
        .original-description {
            color: #999;
            font-size: 10px;
            font-style: italic;
        }
        .manual-description {
            color: #333;
            font-weight: 500;
            margin-bottom: 3px;
            font-size: 11px;
        }
        .manual-description::before {
            content: "üìù ";
        }
        .amount-spent {
            color: #d32f2f;
            font-weight: 600;
        }
        .amount-received {
            color: #2e7d32;
            font-weight: 600;
        }
        .fromto-cell {
            min-width: 120px;
            max-width: 200px;
            font-size: 11px;
            color: #64748b;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            white-space: normal;
        }
        .action-btn {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .action-btn:hover {
            background-color: #3AAFA9;
            border-color: #3AAFA9;
        }
        .action-btn:hover svg {
            stroke: white;
        }
        .action-btn svg {
            display: block;
            stroke: #555;
            transition: stroke 0.2s ease;
        }

        /* Completion Mode Toggle Switch */
        .switch input:checked + span {
            background-color: #10b981 !important;
        }
        .switch input:checked + span span {
            transform: translateX(16px);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.active {
            display: flex;
        }
        /* When modal is positioned near a button, disable flex centering */
        .modal-overlay.active.positioned {
            display: block;
            align-items: unset;
            justify-content: unset;
        }
        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            color: #333;
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
        }
        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        .form-input:focus {
            outline: none;
            border-color: #3AAFA9;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-btn {
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        .modal-btn-primary {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
        }
        .modal-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .modal-btn-secondary {
            background-color: #f5f5f5;
            color: #555;
            border: 1px solid #ddd;
        }
        .modal-btn-secondary:hover {
            background-color: #e0e0e0;
        }
        .modal-btn-danger {
            background-color: #dc3545;
            color: white;
            border: none;
        }
        .modal-btn-danger:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        .current-value {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
        }
        .category-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: white;
        }
        .category-option:hover {
            border-color: #3AAFA9;
            background-color: #f8f9ff;
        }
        .category-option.selected {
            border-color: #3AAFA9;
            background-color: #e8eaf6;
        }
        .category-option.keyboard-selected {
            border-color: #f59e0b !important;
            background-color: #fef3c7 !important;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
        }
        .category-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        tbody tr.row-selected {
            background-color: #dbeafe !important;
            border-left: 4px solid #3b82f6 !important;
        }
        tbody tr:focus {
            outline: none;
        }
        .keyboard-shortcut-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .keyboard-shortcut-hint.visible {
            opacity: 1;
        }
        .category-budget {
            font-size: 12px;
            color: #666;
        }
        .budget-warning {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .assigned-category {
            display: inline-block;
            background-color: #e8eaf6;
            color: #3AAFA9;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
            vertical-align: top;
            line-height: 1.3;
        }

        /* Voice Recording Styles - Row Action Buttons */
        .action-btn {
            background-color: transparent;
            border: none;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
            border-radius: 4px;
        }
        .action-btn:hover {
            transform: scale(1.2);
        }
        .action-btn.edit-btn {
            color: #3AAFA9;
        }
        .action-btn.edit-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.mic-btn {
            color: #3AAFA9;
        }
        .action-btn.mic-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.mic-btn.recording {
            color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        .action-btn.mic-btn.processing {
            color: #f59e0b;
        }
        .action-btn.delete-btn {
            color: #dc2626;
        }
        .action-btn.delete-btn:hover {
            background-color: #fee2e2;
        }
        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: #17252A;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            max-width: 400px;
            font-family: 'Roboto', sans-serif;
            font-size: 13px;
            line-height: 1.4;
        }
        .toast.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        .toast.positioned {
            animation: fadeIn 0.2s ease;
        }
        .toast.success {
            background-color: #059669;
        }
        .toast.error {
            background-color: #dc2626;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Transcription Modal */
        .transcription-modal {
            display: none;
            position: fixed;
            z-index: 1500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .transcription-modal.show {
            display: flex;
        }
        .transcription-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        .transcription-content h3 {
            color: #17252A;
            margin-bottom: 15px;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
        }
        .transcription-content textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid #DEF2F1;
            border-radius: 8px;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            margin-bottom: 20px;
            resize: vertical;
        }
        .transcription-content textarea:focus {
            outline: none;
            border-color: #3AAFA9;
        }
        .transcription-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .transcription-buttons button {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            transition: all 0.2s;
        }
        .transcription-buttons .cancel-btn {
            background-color: #e2e8f0;
            color: #334155;
        }
        .transcription-buttons .cancel-btn:hover {
            background-color: #cbd5e1;
        }
        .transcription-buttons .process-btn {
            background-color: #3AAFA9;
            color: white;
        }
        .transcription-buttons .process-btn:hover {
            background-color: #2B7A78;
        }

        /* Invoice Search & Gmail Integration Styles */
        .action-btn.invoice-btn {
            color: #3AAFA9;
            position: relative;
        }
        .action-btn.invoice-btn:hover {
            background-color: #DEF2F1;
        }
        .action-btn.invoice-btn.searching {
            color: #f59e0b;
            animation: pulse 1.5s infinite;
        }
        .action-btn.invoice-btn.invoice-attached::after {
            content: "üìé";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
        }
        .gmail-account-badge {
            display: inline-block;
            background: #e8f5e9;
            padding: 6px 12px;
            border-radius: 4px;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            border: 1px solid #4caf50;
        }
        .invoice-result-card {
            background: #f9f9f9;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 4px solid #3AAFA9;
        }
        .invoice-result-card:hover {
            background: #f0f0f0;
        }
        .pdf-attachment-btn {
            margin: 5px 5px 0 0;
            font-size: 13px;
            padding: 8px 15px;
        }
        .invoice-mini-table {
            width: 100%;
            border-collapse: collapse;
            margin: 8px 0;
            font-size: 12px;
            background: white;
            border-radius: 4px;
            overflow: hidden;
        }
        .invoice-mini-table th {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            padding: 6px 8px;
            text-align: left;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
        }
        .invoice-mini-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #e2e8f0;
        }
        .invoice-mini-table tr:last-child td {
            border-bottom: none;
        }
        .invoice-mini-table .row-label {
            font-weight: 600;
            color: #64748b;
            width: 110px;
        }
        .invoice-mini-table .match-icon {
            text-align: center;
            font-size: 16px;
        }
        .invoice-mini-table .amount-cell {
            font-weight: 600;
            color: #1e293b;
        }
        .invoice-mini-table .pending-cell {
            color: #94a3b8;
            font-style: italic;
        }

        /* Match score indicators */
        .match-perfect {
            background-color: #d1fae5 !important;
        }
        .match-good {
            background-color: #fef3c7 !important;
        }
        .match-possible {
            background-color: #fed7aa !important;
        }
        .match-weak {
            background-color: #fee2e2 !important;
        }

        /* Custom scrollbar for results container */
        #searchResultsContainer {
            scrollbar-width: thin;
            scrollbar-color: #3AAFA9 #f1f5f9;
        }
        #searchResultsContainer::-webkit-scrollbar {
            width: 6px;
        }
        #searchResultsContainer::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        #searchResultsContainer::-webkit-scrollbar-thumb {
            background: #3AAFA9;
            border-radius: 3px;
        }
        #searchResultsContainer::-webkit-scrollbar-thumb:hover {
            background: #2B7A78;
        }

        /* ============================================================
           QUEUE SYSTEM & TOAST NOTIFICATION STYLES
           ============================================================ */

        /* Toast Animations */
        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Queue Pulse Animation */
        .queue-pulse {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }

        /* Button Pulse Animation (for completed searches) */
        .pulse-once {
            animation: pulseOnce 0.6s ease-out;
        }

        @keyframes pulseOnce {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        /* Searching Pulse Animation */
        .searching-pulse {
            animation: searchingPulse 1.5s ease-in-out infinite;
        }

        @keyframes searchingPulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        /* Queue Panel Styles */
        .queue-section {
            margin-bottom: 16px;
        }

        .queue-section-header {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e2e8f0;
        }

        .queue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 6px;
            transition: all 0.2s;
        }

        .queue-item-running {
            background: #eff6ff;
            border-left: 3px solid #3b82f6;
        }

        .queue-item-pending {
            background: #fef3c7;
            border-left: 3px solid #f59e0b;
        }

        .queue-item-completed {
            background: #f8fafc;
            border-left: 3px solid #94a3b8;
        }

        .queue-item:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .queue-btn-cancel, .queue-btn-view {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .queue-btn-cancel {
            background: #fef2f2;
            color: #ef4444;
        }

        .queue-btn-cancel:hover {
            background: #ef4444;
            color: white;
        }

        .queue-btn-view {
            background: #eff6ff;
            color: #3b82f6;
        }

        .queue-btn-view:hover {
            background: #3b82f6;
            color: white;
        }
    </style>

    <!-- Automatic Cloud Backup System -->
    <script src="supabase-client.js"></script>
    <script src="auto-sync-manager.js"></script>
    <script src="sync-status-indicator.js"></script>
</head>
<body>
    <!-- Navigation Banner -->
    <div class="nav-banner">
        <h1>PEBLGen</h1>
        <div class="nav-buttons">
            <a href="grants.html" class="nav-btn">Grants</a>
            <a href="spend.html" class="nav-btn active">Spend</a>
            <a href="gantt.html" class="nav-btn">Gantt</a>
            <a href="timesheet.html" class="nav-btn">Timesheet</a>
            <a href="index.html" class="nav-btn">Sketcher</a>
            <!-- Queue Status Indicator -->
            <button id="queueStatusIndicator" onclick="toggleQueuePanel()"
                    style="display: none; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 600; margin-left: auto; align-items: center; gap: 8px; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);">
                <span class="queue-pulse"></span>
                <span>üîç 0 running</span>
            </button>
            <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="nav-btn" style="background-color: rgba(255, 255, 255, 0.15);" title="Scroll to top">‚Üë Top</button>
        </div>
    </div>

    <!-- Queue Manager Panel -->
    <div id="queueManagerPanel" style="display: none; position: fixed; top: 80px; right: 20px; width: 420px; max-height: 70vh; background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); z-index: 9999; overflow: hidden;">
        <div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 16px; display: flex; justify-content: space-between; align-items: center;">
            <div style="font-weight: 700; font-size: 16px;">üìä Invoice Search Queue</div>
            <button onclick="toggleQueuePanel()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 20px; cursor: pointer; width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div id="queuePanelContent" style="overflow-y: auto; max-height: calc(70vh - 120px); padding: 16px;">
            <!-- Content populated by renderQueuePanel() -->
        </div>
        <div style="border-top: 1px solid #e2e8f0; padding: 12px 16px; display: flex; gap: 8px;">
            <button onclick="invoiceSearchQueue.clearCompleted()" style="flex: 1; padding: 8px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">Clear Completed</button>
            <button onclick="toggleQueuePanel()" style="flex: 1; padding: 8px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">Close</button>
        </div>
    </div>

    <div class="content-container">

    <!-- Compact Control Panel -->
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">

        <!-- Project Management Card -->
        <div class="table-container" style="margin: 0;">
            <div style="padding: 12px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; font-weight: 600; color: #333; border-bottom: 1px solid #e5e7eb; padding-bottom: 6px;">Project Management</h4>

                <div id="loadedBudgetsInfo" style="font-size: 9px; color: #666; margin-bottom: 6px; min-height: 12px;">
                    Loading...
                </div>

                <div style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 6px;">
                    <select id="filterProject" onchange="handleProjectFilterChange()" style="width: 100%; padding: 4px 6px; font-size: 10px; border: 1px solid #d1d5db; border-radius: 3px; background: white;">
                        <option value="">All Projects</option>
                    </select>
                    <select id="filterCategory" onchange="applyFilters()" style="width: 100%; padding: 4px 6px; font-size: 10px; border: 1px solid #d1d5db; border-radius: 3px; background: white;" disabled>
                        <option value="">All Categories</option>
                    </select>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 4px;">
                    <button onclick="loadProjectsFromDB()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 4px 6px; font-size: 9px;">Refresh</button>
                    <button onclick="clearFilters()" style="padding: 4px 6px; font-size: 9px; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">Clear</button>
                </div>

                <button onclick="jumpToTopUnassigned()" style="padding: 4px 6px; font-size: 9px; background: #3b82f6; color: white; border: none; border-radius: 3px; cursor: pointer; width: 100%; margin-bottom: 3px;">Jump to Top Unassigned</button>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 4px;">
                    <button onclick="recalculateAllQuarters()" style="padding: 4px 6px; font-size: 9px; background: #10b981; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Recalculate all transaction quarters based on current project start dates">üîÑ Fix Quarters</button>
                    <button onclick="restoreFromQuarterBackup()" style="padding: 4px 6px; font-size: 9px; background: #f59e0b; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Restore from most recent backup">‚èÆÔ∏è Restore</button>
                </div>

                <div id="filterStatus" style="font-size: 9px; color: #666; font-style: italic; margin-top: 4px; min-height: 12px;">
                    <!-- Status message -->
                </div>
            </div>
        </div>

        <!-- Unified API Configuration Card -->
        <div class="table-container" style="margin: 0;">
            <div style="padding: 10px;">
                <h4 style="margin: 0 0 6px 0; font-size: 12px; font-weight: 600; color: #333; border-bottom: 1px solid #e5e7eb; padding-bottom: 4px;">API Configuration</h4>

                <!-- OpenAI API -->
                <div style="margin-bottom: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                        <label style="font-size: 10px; font-weight: 500; color: #555;">OpenAI</label>
                        <div id="apiKeyStatus" style="font-size: 9px; color: #666;">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    <div style="display: flex; gap: 2px;">
                        <button onclick="updateOpenAIKey()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 3px 6px; font-size: 9px; flex: 1;">
                            Set Key
                        </button>
                        <button onclick="clearOpenAIKey()" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 3px 6px; font-size: 9px;">
                            Clear
                        </button>
                    </div>
                </div>

                <!-- Currency Exchange API -->
                <div style="margin-bottom: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                        <label style="font-size: 10px; font-weight: 500; color: #555;">Currency</label>
                        <div id="exchangeRateStatus" style="font-size: 9px; color: #666;">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    <div style="display: flex; gap: 2px;">
                        <button onclick="setExchangeRateKey()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 3px 6px; font-size: 9px; flex: 1;">
                            Set Key
                        </button>
                        <button onclick="clearExchangeRateKey()" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 3px 6px; font-size: 9px;">
                            Clear
                        </button>
                    </div>
                    <div style="margin-top: 1px; font-size: 8px; color: #6b7280;">
                        <a href="https://openexchangerates.org/signup/free" target="_blank" style="color: #3b82f6; text-decoration: none;">Get free App ID</a>
                    </div>
                </div>

                <!-- Gmail API -->
                <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                        <label style="font-size: 10px; font-weight: 500; color: #555;">Gmail API</label>
                        <div id="gmailConnectionStatus" style="font-size: 9px; color: #666;">
                            Not connected
                        </div>
                    </div>
                    <div style="display: flex; gap: 3px; align-items: stretch;">
                        <button id="gmailConnectBtn" onclick="signInToGmail()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 3px 6px; font-size: 8px; white-space: nowrap; flex-shrink: 0; writing-mode: horizontal-tb;">
                            + Add
                        </button>
                        <div id="gmailAccountsList" style="flex: 1; max-height: 60px; overflow-y: auto; font-size: 8px; border: 1px solid #e5e7eb; border-radius: 3px; padding: 2px;">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bank Feed Data Card -->
        <div class="table-container" id="bankFeedDropZone" style="margin: 0; transition: all 0.2s; overflow: visible;">
            <div style="padding: 12px; position: relative;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; border-bottom: 1px solid #e5e7eb; padding-bottom: 8px;">
                    <h4 style="margin: 0; font-size: 13px; font-weight: 600; color: #333;">Data Management</h4>

                    <div style="display: flex; align-items: center; gap: 6px;">
                        <!-- Completion Mode Slider -->
                        <div style="display: flex; align-items: center; gap: 4px; font-size: 10px; color: #666;">
                            <span id="incompleteModeIcon">Pending</span>
                            <label class="switch" style="position: relative; display: inline-block; width: 32px; height: 18px; margin: 0;">
                                <input type="checkbox" id="completionModeToggle" onchange="toggleCompletionMode()" style="opacity: 0; width: 0; height: 0;">
                                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5e1; transition: 0.3s; border-radius: 18px;">
                                    <span style="position: absolute; content: ''; height: 12px; width: 12px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                                </span>
                            </label>
                            <span id="completeModeIcon">Done</span>
                        </div>

                        <!-- Table Settings Button -->
                        <button onclick="toggleTableSettings()" id="tableSettingsBtn" style="background: white; border: 1px solid #d1d5db; border-radius: 4px; padding: 3px 6px; cursor: pointer; font-size: 11px; transition: all 0.2s;" title="Table Display Settings">
                            Settings
                        </button>
                    </div>
                </div>

                <!-- Settings Dropdown Menu -->
                <div id="tableSettingsMenu" style="display: none; position: absolute; top: 45px; right: 12px; background: white; border: 1px solid #d1d5db; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 220px; padding: 10px; z-index: 1000;">
                    <div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; color: #374151; border-bottom: 1px solid #e5e7eb; padding-bottom: 6px;">Display Options</div>

                    <!-- Spent Section -->
                    <div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f3f4f6;">
                        <div style="font-size: 10px; font-weight: 600; color: #059669; margin-bottom: 3px;">Expenses</div>
                        <label style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; cursor: pointer; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showSpentColumnToggle" onchange="toggleSpentColumn()" style="cursor: pointer;" checked>
                            <div style="font-size: 11px; color: #1f2937;">Show Spent Columns</div>
                        </label>
                    </div>

                    <!-- Received Section -->
                    <div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f3f4f6;">
                        <div style="font-size: 10px; font-weight: 600; color: #3b82f6; margin-bottom: 3px;">Income</div>
                        <label style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; cursor: pointer; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showReceivedColumnToggle" onchange="toggleReceivedColumn()" style="cursor: pointer;">
                            <div style="font-size: 11px; color: #1f2937;">Show Received Column</div>
                        </label>
                    </div>

                    <!-- Filter Options Section -->
                    <div>
                        <div style="font-size: 10px; font-weight: 600; color: #dc2626; margin-bottom: 3px;">Filters</div>
                        <label style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; cursor: pointer; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showOnlyRedFlagToggle" onchange="toggleRedFlagFilter()" style="cursor: pointer;">
                            <div style="font-size: 11px; color: #1f2937;">Show only üö© red flag</div>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; cursor: pointer; border-radius: 3px; transition: background 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background=''">
                            <input type="checkbox" id="showOnlyBlueFlagToggle" onchange="toggleBlueFlagFilter()" style="cursor: pointer;">
                            <div style="font-size: 11px; color: #1f2937;">Show only üîµ blue flag</div>
                        </label>
                    </div>
                </div>

                <!-- File Summary -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div id="csvSummaryContent" style="font-size: 10px; color: #666; flex: 1;">
                        No files loaded ‚Ä¢ Drop CSV here
                    </div>
                    <button onclick="openCSVManager()" style="font-size: 10px; padding: 2px 6px; background: #3AAFA9; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Manage
                    </button>
                </div>

                <!-- Transaction Stats -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 8px; font-size: 10px; color: #666;">
                    <div><span style="font-weight: 500;" id="totalTransactions">0</span> items</div>
                    <div>Spent: <span style="font-weight: 500; color: #dc2626;">¬£<span id="totalSpent">0.00</span></span></div>
                    <div>In: <span style="font-weight: 500; color: #059669;">¬£<span id="totalReceived">0.00</span></span></div>
                </div>

                <!-- Action Buttons -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    <label for="csvFileInput" class="modal-btn modal-btn-primary" style="margin: 0; padding: 5px 8px; font-size: 10px; cursor: pointer; text-align: center;">
                        Load CSV
                    </label>
                    <button onclick="clearAllTransactions(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 5px 8px; font-size: 10px;">
                        Clear View
                    </button>
                    <button onclick="fixDuplicates(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 5px 8px; font-size: 10px; background: #f59e0b; color: white;" title="Remove duplicate transactions">
                        Fix Dupes
                    </button>
                    <button onclick="clearAndRefreshDatabase(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 5px 8px; font-size: 10px; background: #dc2626; color: white;" title="Clear CSV files">
                        Reset CSVs
                    </button>
                    <button onclick="downloadCurrentTableAsCSV()" class="modal-btn modal-btn-primary" style="margin: 0; padding: 5px 8px; font-size: 10px; grid-column: span 2; background: #10b981; color: white;" title="Download current view as CSV">
                        Download Table
                    </button>
                    <button onclick="regenerateTransactionRefs(event)" class="modal-btn modal-btn-secondary" style="margin: 0; padding: 5px 8px; font-size: 10px; grid-column: span 2; background: #8b5cf6; color: white;" title="Regenerate all transaction reference numbers">
                        üîÑ Regen Transaction Refs
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Hidden file input -->
    <input type="file" id="csvFileInput" accept=".csv" multiple style="display: none;">

    <!-- Transactions Table -->
    <div class="table-container">
        <table id="transactionsTable">
            <thead>
                <tr>
                    <th>Bank</th>
                    <th>Date</th>
                    <th colspan="2" style="text-align: left;">Description<br><span style="font-size: 10px; font-weight: 400; text-transform: none; opacity: 0.8;">(Detail)</span></th>
                    <th>From/To</th>
                    <th id="spentHeader">Spent</th>
                    <th id="spentExVatHeader">Spent (ex. VAT)</th>
                    <th id="receivedHeader" style="display: none;">Received</th>
                    <th style="display: none;">Notes</th>
                    <th>Actions</th>
                    <th id="completeColumnHeader" style="text-align: center; width: 60px; min-width: 60px;">‚úì</th>
                </tr>
            </thead>
            <tbody id="tableBody">
                <tr class="empty-state">
                    <td colspan="11">No transactions loaded. Please upload a CSV file.</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- Edit Description Modal -->
    <div class="modal-overlay" id="editDescriptionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Transaction Description</h3>
                <button class="modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Transaction Date</label>
                    <div class="current-value" id="modalDate"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Current Description</label>
                    <div class="current-value" id="modalCurrentDescription"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Manual Description / Notes</label>
                    <textarea
                        class="form-input form-textarea"
                        id="modalManualDescription"
                        placeholder="Enter custom description or notes for this expense..."
                    ></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Voice Notes</label>
                    <textarea
                        class="form-input form-textarea"
                        id="modalVoiceNotes"
                        placeholder="Voice notes for this transaction..."
                        style="min-height: 60px;"
                    ></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Amount</label>
                    <div class="current-value" id="modalAmount"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveManualDescription()">Save</button>
            </div>
        </div>
    </div>

    <!-- Assign Budget Category Modal -->
    <div class="modal-overlay" id="assignCategoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Assign to Budget Category</h3>
                <button class="modal-close" onclick="closeAssignModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="assignModalContent"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeAssignModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="saveAssignment()">Assign</button>
            </div>
        </div>
    </div>

    <!-- Transcription Modal -->
    <div id="transcriptionModal" class="transcription-modal">
        <div class="transcription-content">
            <h3>Review Voice Note</h3>
            <p style="color: #64748b; font-size: 14px; margin-bottom: 10px;">Edit the text if needed, then click "Save" to add this note to the transaction:</p>
            <textarea id="transcriptionText" placeholder="Your speech will appear here..."></textarea>
            <div class="transcription-buttons">
                <button class="cancel-btn" onclick="closeTranscriptionModal()">Cancel</button>
                <button class="process-btn" onclick="processTranscription()">Save Note</button>
            </div>
        </div>
    </div>

    <!-- Text Popup Modal (for long descriptions/details) -->
    <div id="textPopupModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="modal-title" id="textPopupTitle">Full Text</h3>
                <button class="modal-close" onclick="closeTextPopup()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="textPopupContent" style="font-size: 13px; line-height: 1.6; color: #1e293b; word-wrap: break-word; white-space: pre-wrap; margin-bottom: 15px;"></p>
                <textarea id="textPopupEdit" style="display: none; width: 100%; min-height: 150px; padding: 10px; font-size: 13px; line-height: 1.6; border: 2px solid #3b82f6; border-radius: 6px; font-family: inherit; resize: vertical;"></textarea>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="modal-btn modal-btn-secondary" id="textPopupCloseBtn" onclick="closeTextPopup()">Close</button>
                <button class="modal-btn modal-btn-primary" id="textPopupEditBtn" onclick="enableTextPopupEdit()" style="background: #3b82f6;">‚úèÔ∏è Edit</button>
                <button class="modal-btn modal-btn-primary" id="textPopupSaveBtn" onclick="saveTextPopupEdit()" style="display: none; background: #22c55e;">‚úÖ Save</button>
                <button class="modal-btn modal-btn-secondary" id="textPopupCancelBtn" onclick="cancelTextPopupEdit()" style="display: none;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Invoice Search Modal -->
    <div id="invoiceSearchModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">üìß Invoice Search Results</h3>
                <button class="modal-close" onclick="closeInvoiceSearchModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="invoiceSearchStatus" style="padding: 15px; background: #f5f5f5; border-radius: 6px; margin-bottom: 15px;">
                    <strong>Transaction:</strong> <span id="searchTransactionInfo"></span>
                </div>

                <div id="invoiceSearchResults" style="max-height: 500px; overflow-y: auto;">
                    <!-- Populated dynamically -->
                </div>

                <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">
                    <strong>üí° Tip:</strong> No results? You can manually upload an invoice PDF using the button below.
                    <input type="file" id="manualInvoiceUpload" accept=".pdf,image/*" multiple style="display: none;" onchange="handleManualInvoiceUpload()">
                    <button onclick="document.getElementById('manualInvoiceUpload').click()" class="modal-btn modal-btn-secondary" style="margin-top: 10px; width: 100%;">
                        üìé Upload PDF Manually
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeInvoiceSearchModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- CSV File Manager Modal -->
    <div id="csvManagerModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 style="margin: 0;">üìÅ Manage CSV Files</h3>
                <button class="modal-close-btn" onclick="closeCSVManager()">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="csvFileList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Populated by JavaScript -->
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 12px; color: #856404;">
                    ‚ö†Ô∏è <strong>Note:</strong> Delete old CSV files here and re-upload them to load ALL transactions including spent items.
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-danger" onclick="deleteAllCSVFiles()" style="margin-right: auto;">Delete All</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeCSVManager()">Close</button>
            </div>
        </div>
    </div>

    <!-- Intelligent Invoice Search Modal -->
    <div id="intelligentSearchModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üîç</span>
                    <span id="searchModalTitle">Finding Invoice...</span>
                </h3>
                <button onclick="closeIntelligentSearchModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Transaction summary -->
                <div style="background: #f8fafc; padding: 10px 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 12px; font-size: 13px;">
                        <div><strong>Date:</strong> <span id="searchTxDate"></span></div>
                        <div style="color: #cbd5e1;">‚Ä¢</div>
                        <div><strong>Amount:</strong> <span id="searchTxAmount"></span></div>
                        <div style="color: #cbd5e1;">‚Ä¢</div>
                        <div style="flex: 1; min-width: 200px;"><strong>Description:</strong> <span id="searchTxDesc"></span></div>
                        <div style="width: 100%; display: none;" id="searchTxFromToContainer">
                            <strong>From/To:</strong> <span id="searchTxFromTo"></span>
                        </div>
                    </div>
                </div>

                <!-- Search activity log (collapsible) -->
                <div id="searchLogHeader" onclick="toggleSearchLog()"
                     style="background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); color: white; padding: 12px 15px; border-radius: 6px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; transition: all 0.3s; user-select: none;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="searchLogIcon" style="font-size: 12px; transition: transform 0.3s;">‚ñ∂</span>
                        <span style="font-weight: 600; font-size: 14px;">Search Activity Log</span>
                        <span id="searchLogSummary" style="font-size: 12px; opacity: 0.9;">(Click to expand)</span>
                    </div>
                    <span id="searchLogStatus" style="font-size: 20px;">‚è≥</span>
                </div>
                <div id="searchLogContainer"
                     style="display: none; background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 250px; overflow-y: auto; margin-bottom: 15px; transition: all 0.3s;">
                    <div id="searchLogContent"></div>
                </div>

                <!-- Progress indicator -->
                <div id="searchProgressBar" style="display: none; margin-bottom: 20px;">
                    <div style="background: #e2e8f0; height: 6px; border-radius: 3px; overflow: hidden;">
                        <div id="searchProgressFill" style="background: linear-gradient(90deg, #3b82f6, #8b5cf6); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: #64748b;" id="searchProgressText">Searching...</div>
                </div>

                <!-- Results container -->
                <div id="searchResultsContainer" style="display: none; max-height: 450px; overflow-y: auto; padding-right: 4px;">
                    <!-- Results will be inserted here -->
                </div>

                <!-- Manual Upload Section (Always Visible) -->
                <div id="manualUploadDropZone" style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 8px; border: 2px dashed #3b82f6; transition: all 0.3s ease;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <span style="font-size: 20px;">üì§</span>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: #1e40af; font-size: 14px;">Manual Upload</div>
                            <div style="font-size: 12px; color: #64748b;">
                                Drag & drop files here, or click to browse
                            </div>
                        </div>
                    </div>

                    <!-- Paste Area -->
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 11px; color: #64748b; display: block; margin-bottom: 4px;">Or paste image from clipboard:</label>
                        <input
                            type="text"
                            id="pasteImageInput"
                            placeholder="Click here and press Ctrl+V to paste screenshot"
                            readonly
                            style="width: 100%; padding: 8px; font-size: 12px; border: 1px solid #cbd5e1; border-radius: 4px; background: white; cursor: text; color: #64748b;"
                            onfocus="this.style.borderColor='#3b82f6'; this.style.background='#f8fafc';"
                            onblur="this.style.borderColor='#cbd5e1'; this.style.background='white';">
                        <div id="pasteImagePreview" style="display: none; margin-top: 8px; padding: 10px; background: white; border: 1px solid #cbd5e1; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 11px; color: #059669; font-weight: 600;">‚úì Image pasted</span>
                                <button onclick="clearPastedImage()" style="background: #ef4444; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 10px; cursor: pointer;">Clear</button>
                            </div>
                            <img id="pasteImagePreviewImg" style="max-width: 100%; max-height: 200px; border-radius: 4px; border: 1px solid #e5e7eb;">
                        </div>
                    </div>

                    <button onclick="document.getElementById('manualInvoiceUpload').click()" class="modal-btn modal-btn-primary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);">
                        <span style="font-size: 18px;">üìé</span>
                        <span>Upload PDF or Image</span>
                    </button>
                </div>

                <!-- Action buttons -->
                <div id="searchActionButtons" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                    <button onclick="closeIntelligentSearchModal()" class="btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- PDF Preview Modal -->
    <div id="pdfPreviewModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 95vw; max-height: 90vh; width: 1000px;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üìÑ</span>
                    <span id="pdfPreviewTitle">Invoice Preview</span>
                </h3>
                <button onclick="closePDFPreview()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 0; max-height: 80vh; overflow-y: auto;">
                <!-- PDF Viewer -->
                <div id="pdfViewerContainer" style="width: 100%; height: 40vh; background: #f3f4f6; display: flex; align-items: center; justify-content: center;">
                    <iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>
                </div>

                <!-- Validation Results (shown after analysis) -->
                <div id="validationResultsContainer" style="display: none; padding: 15px; background: #ffffff; border-top: 2px solid #e5e7eb; border-bottom: 2px solid #e5e7eb;">
                    <h4 style="margin: 0 0 10px 0; color: #1e293b; display: flex; align-items: center; gap: 6px; font-size: 14px;">
                        <span id="validationIcon" style="font-size: 16px;">üîç</span>
                        <span id="validationTitle">AI Validation Results</span>
                    </h4>

                    <!-- Validation grid -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <!-- Company validation -->
                        <div id="companyValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">COMPANY</div>
                                <div id="companyStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="companyExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="companyFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="companyReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>

                        <!-- Amount validation -->
                        <div id="amountValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">AMOUNT</div>
                                <div id="amountStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="amountExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="amountFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="amountReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>

                        <!-- Date validation -->
                        <div id="dateValidation" style="padding: 12px; border-radius: 6px; background: #f8fafc; border: 2px solid #e5e7eb;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <div style="font-weight: 600; color: #64748b; font-size: 11px;">DATE</div>
                                <div id="dateStatus" style="font-size: 18px;">‚è≥</div>
                            </div>

                            <!-- Expected vs Found Table -->
                            <table style="width: 100%; font-size: 11px; line-height: 1.4; margin-bottom: 6px;">
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0; width: 55px;">Expected:</td>
                                    <td id="dateExpected" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                                <tr style="color: #64748b;">
                                    <td style="padding: 2px 0;">Found:</td>
                                    <td id="dateFound" style="padding: 2px 0; font-weight: 500; color: #1e293b;">-</td>
                                </tr>
                            </table>

                            <div id="dateReason" style="font-size: 10px; color: #64748b; line-height: 1.3;">
                                Analyzing...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Attachment Buttons -->
                <div style="padding: 15px; background: #f8fafc; border-top: 2px solid #e5e7eb;" id="pdfPreviewFooter">
                    <div style="display: flex; flex-direction: column; gap: 10px;" id="pdfPreviewButtons">
                        <button onclick="confirmAttachInvoice()" class="btn-primary" id="attachInvoiceBtn" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span>‚úÖ</span>
                            <span>Attach Invoice</span>
                        </button>

                        <button onclick="openManualUploadFromPreview()" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: #3b82f6; color: white; border: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span>üì§</span>
                            <span>Upload Different File</span>
                        </button>

                        <button onclick="closePDFPreview()" class="btn-secondary" style="width: 100%; padding: 10px; font-size: 14px;">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Invoice Attachment Confirmation Modal -->
    <div id="invoiceConfirmModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üìé</span>
                    <span>Attach Invoice</span>
                </h3>
                <button onclick="closeInvoiceConfirmModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #64748b; margin: 0 0 20px 0;">
                    Found invoice: <strong id="invoiceConfirmFilename" style="color: #1e293b;">invoice.pdf</strong>
                </p>
                <p style="color: #64748b; margin: 0 0 20px 0;">
                    What would you like to do?
                </p>

                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="confirmPreviewAndAttach()" class="btn-primary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>üëÅÔ∏è</span>
                        <span>Preview & Attach</span>
                    </button>

                    <button onclick="confirmDirectAttach()" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: #22c55e; color: white; border: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>‚úÖ</span>
                        <span>Attach Without Preview</span>
                    </button>

                    <button onclick="confirmManualUpload()" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: #3b82f6; color: white; border: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>üì§</span>
                        <span>Upload Manually Instead</span>
                    </button>

                    <button onclick="closeInvoiceConfirmModal()" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Invoice Manager Modal (Multiple Invoices) -->
    <div id="invoiceManagerModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">
                <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <span>üìÑ</span>
                    <span id="invoiceManagerTitle">Attached Invoices</span>
                </h3>
                <button onclick="closeInvoiceManager()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e5e7eb;">
                    <button onclick="addAnotherInvoice()" class="btn-primary" style="flex: 1; padding: 12px; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>‚ûï</span>
                        <span>Add Another Document</span>
                    </button>
                    <button onclick="handleInvoiceFetch(currentInvoiceManagerTransactionIndex, null)" class="btn-secondary" style="flex: 1; padding: 12px; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px; background: #3b82f6; color: white; border: none;">
                        <span>üîç</span>
                        <span>Search Gmail</span>
                    </button>
                </div>

                <!-- Invoice List -->
                <div id="invoiceListContainer">
                    <!-- Invoices will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for adding additional invoices -->
    <input type="file" id="addInvoiceInput" accept=".pdf,image/*" multiple style="display: none;" onchange="handleAddInvoiceFiles(this.files)">

    <script>
        // ========================================
        // API KEY MANAGEMENT (Secure - Not Exposed)
        // ========================================
        // OpenAI API Key is stored in localStorage, not hardcoded
        let API_KEY = localStorage.getItem('openai_api_key');

        // Function to get or prompt for API key
        function getOpenAIKey() {
            if (!API_KEY || API_KEY === '') {
                API_KEY = prompt('Please enter your OpenAI API Key:\n\n(Get one from: https://platform.openai.com/api-keys)\n\nYour key will be stored locally in your browser.');
                if (API_KEY && API_KEY.trim() !== '') {
                    localStorage.setItem('openai_api_key', API_KEY.trim());
                    showSimpleToast('‚úÖ OpenAI API Key saved', 'success');
                    return API_KEY.trim();
                } else {
                    return null;
                }
            }
            return API_KEY;
        }

        // Function to update API key
        function updateOpenAIKey() {
            const newKey = prompt('Enter your new OpenAI API Key:', API_KEY || '');
            if (newKey && newKey.trim() !== '') {
                API_KEY = newKey.trim();
                localStorage.setItem('openai_api_key', API_KEY);
                updateAPIKeyStatus();
                showSimpleToast('‚úÖ OpenAI API Key updated', 'success');
            }
        }

        // Function to clear API key
        function clearOpenAIKey() {
            if (confirm('Are you sure you want to remove your stored OpenAI API Key?')) {
                localStorage.removeItem('openai_api_key');
                API_KEY = null;
                updateAPIKeyStatus();
                showSimpleToast('‚úÖ OpenAI API Key removed', 'success');
            }
        }

        // Update API key status display
        function updateAPIKeyStatus() {
            const statusDiv = document.getElementById('apiKeyStatus');
            if (API_KEY && API_KEY.length > 0) {
                const maskedKey = API_KEY.substring(0, 7) + '...' + API_KEY.substring(API_KEY.length - 4);
                statusDiv.innerHTML = `<span style="color: #059669;">‚úÖ Key configured (${maskedKey})</span>`;
            } else {
                statusDiv.innerHTML = '<span style="color: #dc2626;">‚ùå No key configured</span>';
            }
        }

        // ========================================
        // EXCHANGE RATE API CONFIGURATION
        // ========================================

        // Set Exchange Rate API key
        function setExchangeRateKey() {
            const currentKey = localStorage.getItem('exchangeRateApiKey') || '';
            const newKey = prompt(
                'Enter your OpenExchangeRates App ID:\n\n' +
                '(Get a free App ID from: https://openexchangerates.org/signup/free)\n' +
                'Free tier: 1,000 requests/month\n\n' +
                'This enables historical exchange rates for USD invoices.\n' +
                'Without an App ID, current rates will be used as approximation.',
                currentKey
            );

            if (newKey !== null && newKey.trim() !== '') {
                localStorage.setItem('exchangeRateApiKey', newKey.trim());
                updateExchangeRateStatus();
                showSimpleToast('‚úÖ OpenExchangeRates App ID saved', 'success');
            }
        }

        // Clear Exchange Rate API key
        function clearExchangeRateKey() {
            if (confirm('Remove stored OpenExchangeRates App ID?\n\nYou can still convert currencies using current rates (approximate).')) {
                localStorage.removeItem('exchangeRateApiKey');
                updateExchangeRateStatus();
                showSimpleToast('‚úÖ OpenExchangeRates App ID removed', 'success');
            }
        }

        // Update Exchange Rate API key status display
        function updateExchangeRateStatus() {
            const statusDiv = document.getElementById('exchangeRateStatus');
            const apiKey = localStorage.getItem('exchangeRateApiKey');

            if (apiKey && apiKey.length > 0) {
                const maskedKey = apiKey.substring(0, 8) + '...' + apiKey.substring(apiKey.length - 4);
                statusDiv.innerHTML = `<span style="color: #059669;">‚úÖ App ID configured (${maskedKey})</span>`;
            } else {
                statusDiv.innerHTML = '<span style="color: #059669;">‚úÖ Using default App ID (shared)</span>';
            }
        }

        // ========================================
        // GMAIL API CONFIGURATION
        // ========================================
        const GOOGLE_CLIENT_ID = '335938881771-o8q7kbrmk4militaeolsamfcreohn094.apps.googleusercontent.com';
        const GOOGLE_API_KEY = 'AIzaSyAJGE3KTxDhFXKAkXRj1SIDoSnqGOohPSE';
        const GMAIL_SCOPES = 'https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/userinfo.email';

        // Gmail authentication state
        let tokenClient = null;
        let gmailAccounts = []; // Array of { email, accessToken, selected }
        let gapiInited = false;
        let gisInited = false;

        // Load saved Gmail accounts from localStorage on page load
        function loadGmailAccountsFromStorage() {
            try {
                const stored = localStorage.getItem('gmailAccounts');
                if (stored) {
                    const accounts = JSON.parse(stored);
                    const now = Date.now();
                    let restoredCount = 0;
                    let expiredCount = 0;

                    // Restore accounts and check if tokens are still valid
                    gmailAccounts = accounts.map(acc => {
                        // Check if token is still valid (not expired)
                        if (acc.accessToken && acc.tokenExpiresAt && acc.tokenExpiresAt > now) {
                            restoredCount++;
                            return {
                                email: acc.email,
                                accessToken: acc.accessToken,
                                tokenExpiresAt: acc.tokenExpiresAt,
                                selected: acc.selected
                            };
                        } else {
                            // Token expired or doesn't exist
                            if (acc.tokenExpiresAt) expiredCount++;
                            return {
                                email: acc.email,
                                accessToken: null,
                                tokenExpiresAt: null,
                                selected: acc.selected
                            };
                        }
                    });

                    console.log(`üìß [GMAIL] Restored ${gmailAccounts.length} Gmail account(s) from storage`);
                    console.log(`   ‚úÖ ${restoredCount} with valid tokens`);
                    if (expiredCount > 0) {
                        console.log(`   ‚è∞ ${expiredCount} with expired tokens (need re-authentication)`);
                    }
                }
            } catch (error) {
                console.error('Error loading Gmail accounts from storage:', error);
            }
        }

        // Save Gmail account emails, tokens (with expiry), and selection state to localStorage
        function saveGmailAccountsToStorage() {
            try {
                const accountsToSave = gmailAccounts.map(acc => ({
                    email: acc.email,
                    selected: acc.selected,
                    accessToken: acc.accessToken,         // Save token
                    tokenExpiresAt: acc.tokenExpiresAt    // Save expiry timestamp
                }));
                localStorage.setItem('gmailAccounts', JSON.stringify(accountsToSave));
                console.log('üíæ Saved Gmail accounts to storage (with tokens)');
            } catch (error) {
                console.error('Error saving Gmail accounts to storage:', error);
            }
        }

        // PDF.js configuration
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc =
                'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        let allTransactions = [];
        let currentEditingIndex = null;
        let selectedCategory = null; // Currently selected category for assignment
        let currentAssignments = []; // For split allocations: [{projectId, category, itemKey, itemName, percentage, quarter}]
        let remainingAllocation = 100; // Percentage remaining to allocate
        let newSplitPercentage = 100; // Percentage for the new split assignment being added

        // Multi-step assignment state
        let assignmentStep = 1; // 1=Project, 2=Category, 3=Item
        let selectedProject = null;
        let selectedCategoryName = null;

        // Keyboard navigation state
        let selectedRowIndex = null;
        let keyboardBuffer = '';
        let keyboardBufferTimeout = null;
        let modalKeyboardIndex = -1;

        // Table display settings
        let showSpentColumn = true; // Show spent column by default
        let showReceivedColumn = false; // Hide received column by default
        let showOnlyRedFlag = false; // Show only red flagged entries (false = show all)
        let showOnlyBlueFlag = false; // Show only blue flagged entries (false = show all)

        // Load settings from localStorage
        function loadDisplaySettings() {
            const savedSettings = localStorage.getItem('spendTableSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    showSpentColumn = settings.showSpentColumn ?? true;
                    showReceivedColumn = settings.showReceivedColumn ?? false;
                    showOnlyRedFlag = settings.showOnlyRedFlag ?? false;
                    showOnlyBlueFlag = settings.showOnlyBlueFlag ?? false;
                    console.log('üìã [SETTINGS] Loaded saved settings from localStorage:', settings);
                } catch (e) {
                    console.error('‚ùå [SETTINGS] Failed to load settings:', e);
                }
            } else {
                console.log('üìã [SETTINGS] No saved settings found, using defaults');
            }

            console.log(`üìã [SETTINGS] Active column settings: showSpentColumn=${showSpentColumn}, showReceivedColumn=${showReceivedColumn}, showOnlyRedFlag=${showOnlyRedFlag}, showOnlyBlueFlag=${showOnlyBlueFlag}`);

            // Sync checkbox states with loaded settings
            syncCheckboxStates();

            applyColumnVisibility();
        }

        // Sync checkbox states with current settings (called on load and when needed)
        function syncCheckboxStates() {
            const spentColToggle = document.getElementById('showSpentColumnToggle');
            const receivedColToggle = document.getElementById('showReceivedColumnToggle');
            const redFlagFilterToggle = document.getElementById('showOnlyRedFlagToggle');
            const blueFlagFilterToggle = document.getElementById('showOnlyBlueFlagToggle');

            if (spentColToggle) spentColToggle.checked = showSpentColumn;
            if (receivedColToggle) receivedColToggle.checked = showReceivedColumn;
            if (redFlagFilterToggle) redFlagFilterToggle.checked = showOnlyRedFlag;
            if (blueFlagFilterToggle) blueFlagFilterToggle.checked = showOnlyBlueFlag;

            console.log('üîÑ [SETTINGS] Synced checkbox states with settings');
        }

        // Helper function to reset table settings to default (only called from console if needed)
        window.resetTableSettings = function() {
            console.log('üîÑ [SETTINGS] Resetting table settings to default...');
            localStorage.removeItem('spendTableSettings');
            showSpentColumn = true;
            showReceivedColumn = false;
            showOnlyRedFlag = false;
            showOnlyBlueFlag = false;
            document.getElementById('showSpentColumnToggle').checked = true;
            document.getElementById('showReceivedColumnToggle').checked = false;
            document.getElementById('showOnlyRedFlagToggle').checked = false;
            document.getElementById('showOnlyBlueFlagToggle').checked = false;
            saveDisplaySettings();
            applyColumnVisibility();
            renderTransactions();
            console.log('‚úÖ [SETTINGS] Reset complete! Spent column visible, Received column hidden, showing all entries.');
            showSimpleToast('‚úÖ Settings reset to defaults', 'success');
        }

        // Save settings to localStorage
        function saveDisplaySettings() {
            const settings = {
                showSpentColumn,
                showReceivedColumn,
                showOnlyRedFlag,
                showOnlyBlueFlag
            };
            localStorage.setItem('spendTableSettings', JSON.stringify(settings));
            console.log('üíæ [SETTINGS] Saved display settings:', settings);
        }

        // Apply column visibility based on settings
        function applyColumnVisibility() {
            // Use IDs for direct header access
            const spentHeader = document.getElementById('spentHeader');
            const spentExVatHeader = document.getElementById('spentExVatHeader');
            const receivedHeader = document.getElementById('receivedHeader');

            const spentCells = document.querySelectorAll('.amount-spent');
            const receivedCells = document.querySelectorAll('.amount-received');

            // Toggle spent column headers
            if (spentHeader) spentHeader.style.display = showSpentColumn ? '' : 'none';
            if (spentExVatHeader) spentExVatHeader.style.display = showSpentColumn ? '' : 'none';

            // Toggle received column header
            if (receivedHeader) receivedHeader.style.display = showReceivedColumn ? '' : 'none';

            // Toggle all spent column cells
            spentCells.forEach(cell => {
                cell.style.display = showSpentColumn ? '' : 'none';
            });

            // Toggle all received column cells
            receivedCells.forEach(cell => {
                cell.style.display = showReceivedColumn ? '' : 'none';
            });
        }

        // Toggle table settings menu visibility
        function toggleTableSettings() {
            const menu = document.getElementById('tableSettingsMenu');
            const isVisible = menu.style.display !== 'none';

            if (isVisible) {
                menu.style.display = 'none';
            } else {
                // Update checkbox states to match current settings
                document.getElementById('showSpentColumnToggle').checked = showSpentColumn;
                document.getElementById('showReceivedColumnToggle').checked = showReceivedColumn;

                menu.style.display = 'block';
            }
        }

        // Close settings menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('tableSettingsMenu');
            const btn = document.getElementById('tableSettingsBtn');

            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // Toggle spent column visibility
        function toggleSpentColumn() {
            showSpentColumn = document.getElementById('showSpentColumnToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle spent column:', showSpentColumn);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();
            applyColumnVisibility();

            const message = showSpentColumn ?
                '‚úÖ Showing spent column' :
                'üîí Hiding spent column';
            showToast(message, 'success', toastPosition);
        }

        // Toggle received column visibility
        function toggleReceivedColumn() {
            showReceivedColumn = document.getElementById('showReceivedColumnToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle received column:', showReceivedColumn);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();
            applyColumnVisibility();

            const message = showReceivedColumn ?
                '‚úÖ Showing received column' :
                'üîí Hiding received column';
            showToast(message, 'success', toastPosition);
        }

        // Toggle red flag filter
        function toggleRedFlagFilter() {
            showOnlyRedFlag = document.getElementById('showOnlyRedFlagToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle red flag filter:', showOnlyRedFlag);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();

            // Re-render transactions to apply filter
            renderTransactions();

            const message = showOnlyRedFlag ?
                'üö© Showing only red flagged entries' :
                '‚úÖ Showing all entries (red filter off)';
            showToast(message, 'success', toastPosition);
        }

        // Toggle blue flag filter
        function toggleBlueFlagFilter() {
            showOnlyBlueFlag = document.getElementById('showOnlyBlueFlagToggle').checked;
            console.log('üîÑ [SETTINGS] Toggle blue flag filter:', showOnlyBlueFlag);

            // Get settings button position for toast
            const settingsBtn = document.getElementById('tableSettingsBtn');
            const btnRect = settingsBtn?.getBoundingClientRect();
            const toastPosition = btnRect ? { x: btnRect.right, y: btnRect.top } : null;

            saveDisplaySettings();

            // Re-render transactions to apply filter
            renderTransactions();

            const message = showOnlyBlueFlag ?
                'üîµ Showing only blue flagged entries' :
                '‚úÖ Showing all entries (blue filter off)';
            showToast(message, 'success', toastPosition);
        }

        // ========================================
        // QUARTER CALCULATION HELPERS
        // ========================================

        /**
         * Calculate which quarter a transaction falls into based on project start date
         * @param {string} transactionDate - Date string from transaction (e.g., "15/03/2024")
         * @param {object} project - Project object with projectStartMonth, projectStartYear, projectDurationMonths
         * @returns {number} Quarter number (1-4) or null if cannot calculate
         */
        function calculateTransactionQuarter(transactionDate, project) {
            console.log('üìÖ [QUARTER CALC] Calculating quarter for transaction:', transactionDate);
            console.log('üìÖ [QUARTER CALC] Project structure:', {
                name: project.projectName,
                hasFinanceSummary: !!project.financeSummary,
                topLevelStartMonth: project.projectStartMonth,
                topLevelStartYear: project.projectStartYear,
                nestedStartMonth: project.financeSummary?.projectStartMonth,
                nestedStartYear: project.financeSummary?.projectStartYear
            });

            // Check for start dates in both locations (for backward compatibility)
            const startMonth = project.projectStartMonth || project.financeSummary?.projectStartMonth;
            const startYear = project.projectStartYear || project.financeSummary?.projectStartYear;

            if (!startMonth || !startYear) {
                console.error(`‚ö†Ô∏è [QUARTER CALC] Project "${project.projectName}" is missing start date!`, {
                    projectName: project.projectName,
                    projectId: project.projectId,
                    startMonth,
                    startYear,
                    hasFinanceSummary: !!project.financeSummary
                });
                console.error(`‚ùå [QUARTER CALC] Solution: Open grants.html ‚Üí Load project "${project.projectName}" ‚Üí Set "Project Start Date" in the Finance Summary section`);

                // Show user-friendly toast notification
                alert(`‚ö†Ô∏è Project Start Date Missing\n\nProject "${project.projectName}" doesn't have a start date set.\n\nTo assign transactions to quarters:\n1. Open grants.html\n2. Load project "${project.projectName}"\n3. Set the "Project Start Date" in the Finance Summary section\n4. Save the project\n5. Return to spend.html and refresh`);

                return null;
            }

            // Parse transaction date (handle DD/MM/YYYY, DD/MM/YY, etc.)
            const dateParts = transactionDate.split('/');
            if (dateParts.length !== 3) {
                console.warn('‚ö†Ô∏è [QUARTER CALC] Invalid date format:', transactionDate);
                return null;
            }

            const transDay = parseInt(dateParts[0]);
            const transMonth = parseInt(dateParts[1]);
            let transYear = parseInt(dateParts[2]);

            // Handle 2-digit years
            if (transYear < 100) {
                transYear += 2000;
            }

            console.log(`üìÖ [QUARTER CALC] Parsed transaction date: ${transDay}/${transMonth}/${transYear}`);

            // Calculate project start date
            const projectStart = new Date(startYear, startMonth - 1, 1);
            const transactionDateObj = new Date(transYear, transMonth - 1, transDay);

            console.log(`üìÖ [QUARTER CALC] Project start: ${projectStart.toISOString()}`);
            console.log(`üìÖ [QUARTER CALC] Transaction: ${transactionDateObj.toISOString()}`);

            // Calculate months since project start
            const monthsSinceStart = (transYear - startYear) * 12 + (transMonth - startMonth);

            console.log(`üìÖ [QUARTER CALC] Months since project start: ${monthsSinceStart}`);

            // Determine quarter (1-4)
            if (monthsSinceStart < 0) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const projectStartDisplay = `${monthNames[startMonth - 1]} ${startYear}`;
                const transactionDisplay = `${transDay}/${transMonth}/${transYear}`;

                console.warn(`‚ö†Ô∏è [QUARTER CALC] Transaction date (${transactionDisplay}) is before project start (${projectStartDisplay})!`);

                alert(`‚ö†Ô∏è Transaction Date Issue\n\nTransaction date: ${transactionDisplay}\nProject "${project.projectName}" starts: ${projectStartDisplay}\n\nThis transaction is ${Math.abs(monthsSinceStart)} month(s) before the project start date.\n\nTo fix this:\n1. Open grants.html\n2. Load project "${project.projectName}"\n3. Adjust the "Project Start Date" in Finance Summary\n4. Save and return to spend.html\n\nOR assign this transaction to a different project.`);

                return null;
            }

            // Calculate quarter dynamically (supports Q1, Q2, Q3, Q4, Q5, Q6, etc.)
            const quarter = Math.floor(monthsSinceStart / 3) + 1;
            console.log(`üìÖ [QUARTER CALC] Calculated quarter: Q${quarter} (month ${monthsSinceStart} of project)`);
            return quarter;
        }

        /**
         * Get quarter name for display
         */
        function getQuarterName(quarter) {
            return quarter ? `Q${quarter}` : 'Unknown';
        }

        // Voice recording variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        const MAX_RECORDING_TIME = 30000; // 30 seconds
        let recordingTimeout;
        let currentRecordingRowIndex = null; // Track which row is being recorded
        let microphoneStream = null; // Keep stream alive to avoid repeated permission requests

        // IndexedDB variables
        let db;
        const DB_NAME = 'PEBLGrantsBudgets';
        const DB_VERSION = 6; // Updated to match grants.html
        const STORE_NAME = 'projects';
        const CSV_STORE_NAME = 'csvFiles';
        const INVOICES_STORE_NAME = 'invoices';
        let allProjects = [];
        let currentProject = null; // Currently selected project
        let savedCSVFiles = []; // List of saved CSV files

        // Invoice search variables
        let currentInvoiceSearchIndex = null;

        // IndexedDB initialization
        async function initIndexedDB() {
            console.log(`üîÑ [INDEXEDDB] Initializing database: ${DB_NAME}, version: ${DB_VERSION}`);

            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('‚ùå [INDEXEDDB] Error opening database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    console.log(`‚úÖ [INDEXEDDB] Database opened successfully (version ${db.version})`);
                    console.log(`üìã [INDEXEDDB] Available object stores:`, Array.from(db.objectStoreNames));
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    console.log(`üîß [INDEXEDDB] Upgrading database from version ${event.oldVersion} to ${event.newVersion}`);
                    db = event.target.result;

                    // Create projects object store if it doesn't exist
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating projects object store: ${STORE_NAME}`);
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'projectId', autoIncrement: true });
                        objectStore.createIndex('projectName', 'projectName', { unique: false });
                        objectStore.createIndex('projectNumber', 'projectNumber', { unique: false });
                        objectStore.createIndex('lastModified', 'lastModified', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created projects object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] Projects object store already exists`);
                    }

                    // Create CSV files object store if it doesn't exist
                    if (!db.objectStoreNames.contains(CSV_STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating CSV files object store: ${CSV_STORE_NAME}`);
                        const csvStore = db.createObjectStore(CSV_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        csvStore.createIndex('fileName', 'fileName', { unique: false });
                        csvStore.createIndex('uploadDate', 'uploadDate', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created CSV files object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] CSV files object store already exists`);
                    }

                    // Create invoices object store if it doesn't exist
                    if (!db.objectStoreNames.contains(INVOICES_STORE_NAME)) {
                        console.log(`üîß [INDEXEDDB] Creating invoices object store: ${INVOICES_STORE_NAME}`);
                        const invoiceStore = db.createObjectStore(INVOICES_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        invoiceStore.createIndex('transactionIndex', 'transactionIndex', { unique: false });
                        invoiceStore.createIndex('filename', 'filename', { unique: false });
                        invoiceStore.createIndex('uploadDate', 'uploadDate', { unique: false });
                        invoiceStore.createIndex('messageId', 'gmailMessageId', { unique: false });
                        console.log(`‚úÖ [INDEXEDDB] Created invoices object store`);
                    } else {
                        console.log(`‚ÑπÔ∏è [INDEXEDDB] Invoices object store already exists`);
                    }
                };
            });
        }

        async function loadProjectsFromDB() {
            console.log('üîÑ [BUDGET LOAD] Starting loadProjectsFromDB...');

            if (!db) {
                console.log('üîÑ [BUDGET LOAD] Database not initialized, initializing...');
                await initIndexedDB();
            }

            try {
                console.log('üîÑ [BUDGET LOAD] Opening transaction to projects store...');
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    allProjects = request.result || [];
                    console.log('‚úÖ [BUDGET LOAD] Successfully loaded projects from DB');
                    console.log(`üìä [BUDGET LOAD] Number of projects: ${allProjects.length}`);

                    if (allProjects.length > 0) {
                        console.log('üìã [BUDGET LOAD] Project details:');
                        allProjects.forEach((project, index) => {
                            console.log(`   Project ${index + 1}:`, {
                                projectId: project.projectId,
                                projectName: project.projectName,
                                projectNumber: project.projectNumber,
                                fundingBody: project.fundingBody,
                                hasLabour: !!project.labour,
                                hasOverheads: !!project.overheads,
                                hasMaterials: !!project.materials,
                                hasCapitalUsage: !!project.capitalUsage,
                                hasSubcontracting: !!project.subcontracting,
                                hasTravel: !!project.travel,
                                hasOtherCosts: !!project.otherCosts,
                                hasWelshGovData: !!project.welshGovData,
                                hasFinanceSummary: !!project.financeSummary,
                                lastModified: project.lastModified
                            });

                            // Log finance summary details
                            if (project.financeSummary) {
                                console.log(`      Finance Summary (FULL):`, project.financeSummary);
                                console.log(`      Finance Summary (Parsed):`, {
                                    startMonth: project.financeSummary.projectStartMonth,
                                    startYear: project.financeSummary.projectStartYear,
                                    duration: project.financeSummary.projectDurationMonths,
                                    durationString: project.financeSummary.projectDuration,
                                    totalCosts: project.financeSummary.totalCosts
                                });
                            }

                            // Log category details
                            if (project.labour) {
                                console.log(`      Labour: ${project.labour.staff?.length || 0} staff, total ¬£${project.labour.totalCost || 0}`);
                            }
                            if (project.overheads) {
                                console.log(`      Overheads: total ¬£${project.overheads.totalCost || 0}`);
                            }
                            if (project.materials) {
                                console.log(`      Materials: ${project.materials.items?.length || 0} items, total ¬£${project.materials.totalCost || 0}`);
                            }
                            if (project.capitalUsage) {
                                console.log(`      Capital Usage: ${project.capitalUsage.items?.length || 0} items, total ¬£${project.capitalUsage.totalCost || 0}`);
                            }
                            if (project.subcontracting) {
                                console.log(`      Subcontracting: ${project.subcontracting.contractors?.length || 0} contractors, total ¬£${project.subcontracting.totalCost || 0}`);
                            }
                            if (project.travel) {
                                console.log(`      Travel: ${project.travel.trips?.length || 0} trips, total ¬£${project.travel.totalCost || 0}`);
                            }
                            if (project.otherCosts) {
                                console.log(`      Other Costs: ${project.otherCosts.items?.length || 0} items, total ¬£${project.otherCosts.totalCost || 0}`);
                            }

                            // Special logging for Welsh Gov projects
                            if (project.welshGovData) {
                                console.log(`      ‚ö†Ô∏è WELSH GOV DATA DETECTED - This project uses welshGovData structure`);
                                console.log(`      Welsh Gov Sections:`, Object.keys(project.welshGovData.sections || {}));
                            }

                            // If no categories detected, log full project structure for debugging
                            if (!project.labour && !project.materials && !project.capitalUsage &&
                                !project.subcontracting && !project.travel && !project.otherCosts && !project.welshGovData) {
                                console.warn(`      ‚ö†Ô∏è NO CATEGORIES DETECTED - Full project structure:`, project);
                            }
                        });
                    } else {
                        console.log('‚ö†Ô∏è [BUDGET LOAD] No projects found in database');
                    }

                    console.log('üîÑ [BUDGET LOAD] Calling updateBudgetInfo()...');
                    updateBudgetInfo();
                };

                request.onerror = () => {
                    console.error('‚ùå [BUDGET LOAD] Failed to load projects:', request.error);
                    document.getElementById('loadedBudgetsInfo').innerHTML =
                        '‚ùå Failed to load projects from database.';
                };
            } catch (error) {
                console.error('‚ùå [BUDGET LOAD] Error loading projects:', error);
                document.getElementById('loadedBudgetsInfo').innerHTML =
                    '‚ùå Error accessing database.';
            }
        }

        // Auto-load and activate ALL projects (no selection needed)
        let activeProjects = [];

        async function loadSavedCSVFiles() {
            console.log('üìÇ [LOAD CSV FILES] Starting loadSavedCSVFiles...');
            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    savedCSVFiles = request.result || [];
                    console.log('‚úÖ [LOAD CSV FILES] Loaded saved CSV files from IndexedDB:', savedCSVFiles.length, 'files');

                    savedCSVFiles.forEach((file, idx) => {
                        console.log(`üìÑ [LOAD CSV FILES] File ${idx + 1}:`, {
                            id: file.id,
                            fileName: file.fileName,
                            bank: file.bank,
                            transactionCount: file.transactionCount,
                            uploadDate: file.uploadDate,
                            hasTransactions: !!file.transactions,
                            firstTransaction: file.transactions?.[0]
                        });
                    });

                    // Update CSV summary to show saved files
                    updateCSVSummary();

                    // Auto-load all saved CSV files
                    if (savedCSVFiles.length > 0) {
                        console.log('üîÑ [LOAD CSV FILES] Triggering autoLoadSavedCSVs...');
                        autoLoadSavedCSVs();
                    } else {
                        console.log('‚ÑπÔ∏è [LOAD CSV FILES] No saved CSV files found');
                    }
                };

                request.onerror = () => {
                    console.error('‚ùå [LOAD CSV FILES] Failed to load CSV files:', request.error);
                };
            } catch (error) {
                console.error('‚ùå [LOAD CSV FILES] Error loading CSV files:', error);
            }
        }

        // Auto-load all saved CSV files from IndexedDB
        let isAutoLoadingCSVs = false; // Flag to prevent multiple simultaneous loads
        async function autoLoadSavedCSVs() {
            // Prevent multiple simultaneous loads
            if (isAutoLoadingCSVs) {
                console.warn('‚ö†Ô∏è [AUTO-LOAD CSV] Already loading CSVs, skipping duplicate call');
                return;
            }

            isAutoLoadingCSVs = true;
            console.log('üîÑ [AUTO-LOAD CSV] Starting autoLoadSavedCSVs...');
            console.log(`üìÇ [AUTO-LOAD CSV] savedCSVFiles.length: ${savedCSVFiles.length}`);
            console.log(`üìä [AUTO-LOAD CSV] allTransactions.length BEFORE clear: ${allTransactions.length}`);

            // Clear existing transactions before loading (prevent duplicates on multiple calls)
            allTransactions = [];
            console.log(`üßπ [AUTO-LOAD CSV] Cleared allTransactions array`);

            let totalLoaded = 0;

            for (const csvFile of savedCSVFiles) {
                console.log(`üìÑ [AUTO-LOAD CSV] Processing CSV file:`, {
                    fileName: csvFile.fileName,
                    bank: csvFile.bank,
                    transactionCount: csvFile.transactionCount,
                    actualTransactionsLength: csvFile.transactions?.length,
                    uploadDate: csvFile.uploadDate
                });

                // Merge transactions from all saved CSV files
                const transactions = csvFile.transactions || [];
                console.log(`üí≥ [AUTO-LOAD CSV] Actual transactions array length: ${transactions.length}`);
                console.log(`üí≥ [AUTO-LOAD CSV] Stored transactionCount: ${csvFile.transactionCount}`);
                console.log(`‚ö†Ô∏è [AUTO-LOAD CSV] MISMATCH DETECTED: ${transactions.length} vs ${csvFile.transactionCount}` + (transactions.length !== csvFile.transactionCount ? ' ‚ùå' : ' ‚úÖ'));
                console.log(`üí≥ [AUTO-LOAD CSV] First transaction in this file:`, transactions[0]);
                console.log(`üí≥ [AUTO-LOAD CSV] Last transaction in this file:`, transactions[transactions.length - 1]);
                console.log(`üí≥ [AUTO-LOAD CSV] Transaction sample:`, transactions.slice(0, 3));

                allTransactions = allTransactions.concat(transactions);
                totalLoaded += transactions.length;
            }

            console.log(`‚úÖ [AUTO-LOAD CSV] Total loaded: ${totalLoaded} transactions`);
            console.log(`üìä [AUTO-LOAD CSV] allTransactions.length: ${allTransactions.length}`);
            console.log(`üîç [AUTO-LOAD CSV] First 3 transactions in allTransactions:`, allTransactions.slice(0, 3));

            // Log spent vs received breakdown
            const spentCount = allTransactions.filter(t => t.spent && t.spent.trim()).length;
            const receivedCount = allTransactions.filter(t => t.received && t.received.trim()).length;
            console.log(`üí∞ [AUTO-LOAD CSV] Breakdown: ${spentCount} spent, ${receivedCount} received`);

            if (totalLoaded > 0) {
                renderTransactions();
                updateSummary();

                // Show helpful message about what's being displayed
                const displayedCount = document.getElementById('tableBody').querySelectorAll('tr:not(.empty-state)').length;

                console.log(`üìä [AUTO-LOAD CSV] Display: ${displayedCount} visible of ${totalLoaded} loaded`);

                if (spentCount > 0) {
                    showSimpleToast(`‚úÖ Loaded ${spentCount} spent transaction${spentCount !== 1 ? 's' : ''} for budget allocation`, 'success');
                } else if (receivedCount > 0) {
                    showSimpleToast(`‚ö†Ô∏è Loaded ${receivedCount} received transaction${receivedCount !== 1 ? 's' : ''} (no spent transactions found)`, 'info');
                } else {
                    showSimpleToast(`‚úÖ Loaded ${totalLoaded} transaction${totalLoaded !== 1 ? 's' : ''}`, 'success');
                }
            } else {
                console.log('‚ÑπÔ∏è [AUTO-LOAD CSV] No transactions to load');
            }

            // Migrate existing assigned transactions to have transaction references
            if (allTransactions.length > 0) {
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üìù TRANSACTION REFERENCE MIGRATION');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                await migrateExistingTransactionRefs();
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            }

            isAutoLoadingCSVs = false;
            console.log('‚úÖ [AUTO-LOAD CSV] Auto-load complete, flag reset');
        }

        async function saveCSVFileToDB(fileName, transactions, bankIdentifier) {
            if (!db) {
                await initIndexedDB();
            }

            try {
                // Check if file with same name already exists
                const existing = savedCSVFiles.find(f => f.fileName === fileName);
                if (existing) {
                    console.log('CSV file already saved:', fileName);
                    return existing.id;
                }

                const csvFileData = {
                    fileName: fileName,
                    uploadDate: new Date().toISOString(),
                    transactions: transactions,
                    transactionCount: transactions.length,
                    bank: bankIdentifier
                };

                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.add(csvFileData);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        console.log('CSV file saved with ID:', request.result);
                        loadSavedCSVFiles(); // Refresh the list
                        resolve(request.result);
                    };

                    request.onerror = () => {
                        console.error('Failed to save CSV file:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('Error saving CSV file:', error);
                return null;
            }
        }

        async function loadCSVFromDB(csvId) {
            if (!csvId) {
                // If no CSV selected, clear the transactions
                allTransactions = [];
                renderTransactions();
                updateSummary();
                document.getElementById('loadedFiles').innerHTML = '';
                return;
            }

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.get(parseInt(csvId));

                request.onsuccess = () => {
                    if (request.result) {
                        const csvData = request.result;
                        allTransactions = csvData.transactions;
                        renderTransactions();
                        updateSummary();

                        // Update loaded files display
                        const uploadDate = new Date(csvData.uploadDate).toLocaleString();
                        document.getElementById('loadedFiles').innerHTML =
                            `<p style="margin-top: 10px; color: #666;">
                                Currently loaded: <strong>${csvData.fileName}</strong>
                                (${csvData.transactionCount} transactions, uploaded ${uploadDate})
                            </p>`;

                        console.log('Loaded CSV from database:', csvData.fileName);
                    }
                };

                request.onerror = () => {
                    console.error('Failed to load CSV from database:', request.error);
                    alert('Failed to load CSV file from database.');
                };
            } catch (error) {
                console.error('Error loading CSV from database:', error);
            }
        }

        async function deleteCSVFromDB(csvId) {
            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.delete(parseInt(csvId));

                request.onsuccess = () => {
                    console.log('CSV file deleted:', csvId);
                    loadSavedCSVFiles(); // Refresh the list
                    showSimpleToast('‚úÖ CSV file deleted successfully!', 'success');
                };

                request.onerror = () => {
                    console.error('Failed to delete CSV file:', request.error);
                    showSimpleToast('‚ùå Failed to delete CSV file', 'error');
                };
            } catch (error) {
                console.error('Error deleting CSV file:', error);
            }
        }

        function openCSVManager() {
            console.log('üìÇ [CSV MANAGER] Opening CSV manager...');
            const modal = document.getElementById('csvManagerModal');
            const listDiv = document.getElementById('csvFileList');

            if (savedCSVFiles.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No CSV files saved</p>';
            } else {
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                savedCSVFiles.forEach(file => {
                    const uploadDate = new Date(file.uploadDate).toLocaleString();
                    const bankIcon = file.bank === 'R' ? 'üü£' : file.bank === 'M' ? 'üîµ' : '‚ö™';
                    html += `
                        <div style="display: flex; align-items: center; padding: 10px; background: #f8f9fa; border-radius: 5px; gap: 10px;">
                            <span style="font-size: 20px;">${bankIcon}</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 13px;">${file.fileName}</div>
                                <div style="font-size: 11px; color: #666;">
                                    ${file.transactionCount} transactions ‚Ä¢ Uploaded ${uploadDate}
                                </div>
                            </div>
                            <button onclick="deleteCSVFile(${file.id})"
                                    style="padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">
                                Delete
                            </button>
                        </div>
                    `;
                });
                html += '</div>';
                listDiv.innerHTML = html;
            }

            modal.style.display = 'flex';
        }

        function closeCSVManager() {
            document.getElementById('csvManagerModal').style.display = 'none';
        }

        async function deleteCSVFile(fileId) {
            if (!confirm('Delete this CSV file? You can re-upload it later.')) {
                return;
            }

            console.log(`üóëÔ∏è [CSV MANAGER] Deleting file ID: ${fileId}`);
            await deleteCSVFromDB(fileId);

            // Reload the page data
            allTransactions = [];
            await loadSavedCSVFiles();
            renderTransactions();
            updateSummary();

            // Refresh the manager view
            openCSVManager();
            showSimpleToast('‚úÖ CSV file deleted', 'success');
        }

        async function deleteAllCSVFiles() {
            if (!confirm('‚ö†Ô∏è Delete ALL CSV files? This cannot be undone.\n\nYou will need to re-upload your CSV files.')) {
                return;
            }

            console.log('üóëÔ∏è [CSV MANAGER] Deleting all CSV files...');

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const request = objectStore.clear();

                request.onsuccess = async () => {
                    console.log('‚úÖ [CSV MANAGER] All CSV files deleted');
                    allTransactions = [];
                    savedCSVFiles = [];
                    await loadSavedCSVFiles();
                    renderTransactions();
                    updateSummary();
                    updateCSVSummary();
                    closeCSVManager();
                    showSimpleToast('‚úÖ All CSV files deleted', 'success');
                };

                request.onerror = () => {
                    console.error('‚ùå [CSV MANAGER] Failed to delete all files:', request.error);
                    showSimpleToast('‚ùå Failed to delete files', 'error');
                };
            } catch (error) {
                console.error('‚ùå [CSV MANAGER] Error:', error);
                showSimpleToast('‚ùå Error deleting files', 'error');
            }
        }

        function updateCSVSummary() {
            const contentDiv = document.getElementById('csvSummaryContent');

            // Show saved CSV files from IndexedDB (compact format)
            if (savedCSVFiles.length > 0) {
                const totalTrans = savedCSVFiles.reduce((sum, f) => sum + f.transactionCount, 0);
                contentDiv.innerHTML = `${savedCSVFiles.length} file${savedCSVFiles.length > 1 ? 's' : ''} (${totalTrans} trans.)`;
                return;
            }

            // If no saved files, show current loaded data summary
            if (allTransactions.length === 0) {
                contentDiv.innerHTML = 'No files loaded ‚Ä¢ Drop CSV files here';
                return;
            }

            // Group transactions by bank (compact format)
            const revolutTransactions = allTransactions.filter(t => t.bank === 'R');
            const metroTransactions = allTransactions.filter(t => t.bank === 'M');

            let summary = [];
            if (revolutTransactions.length > 0) summary.push(`R: ${revolutTransactions.length}`);
            if (metroTransactions.length > 0) summary.push(`M: ${metroTransactions.length}`);

            contentDiv.innerHTML = summary.length > 0 ? summary.join(', ') + ' trans.' : `${allTransactions.length} trans.`;
        }

        function clearAllTransactions(event) {
            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            if (confirm('Are you sure you want to clear all loaded transactions? This will not delete saved CSV files from the database.')) {
                allTransactions = [];
                renderTransactions();
                updateSummary();
                updateCSVSummary();
                document.getElementById('loadedFiles').innerHTML = '';
                showSimpleToast('‚úÖ All transactions cleared from view', 'success', toastPosition);
            }
        }

        /**
         * Fix duplicate transactions in IndexedDB
         */
        async function fixDuplicates(event) {
            console.log('üîß [FIX DUPLICATES] User clicked Fix DB button');

            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            // Show confirmation dialog
            const confirmed = confirm(
                '‚ö†Ô∏è Fix Database - Remove Duplicate Transactions\n\n' +
                'This will scan all saved CSV files and remove EXACT duplicate transactions.\n\n' +
                'A duplicate is identified when ALL of these match:\n' +
                '  ‚Ä¢ Date\n' +
                '  ‚Ä¢ Description\n' +
                '  ‚Ä¢ Spent amount\n' +
                '  ‚Ä¢ Received amount\n' +
                '  ‚Ä¢ From/To\n\n' +
                'Only exact duplicates will be removed. Your unique transactions will be preserved.\n\n' +
                'Do you want to continue?'
            );

            if (!confirmed) {
                console.log('üîß [FIX DUPLICATES] User cancelled operation');
                return;
            }

            console.log('üîß [FIX DUPLICATES] Starting duplicate fix...');

            if (!db) {
                await initIndexedDB();
            }

            try {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const getAllRequest = objectStore.getAll();

                getAllRequest.onsuccess = async () => {
                    const allCSVFiles = getAllRequest.result || [];
                    console.log(`üìÇ [FIX DUPLICATES] Found ${allCSVFiles.length} CSV files`);

                    let totalBefore = 0;
                    let totalAfter = 0;
                    let totalSpentBefore = 0;
                    let totalReceivedBefore = 0;
                    let totalSpentAfter = 0;
                    let totalReceivedAfter = 0;

                    for (const csvFile of allCSVFiles) {
                        const before = csvFile.transactions?.length || 0;
                        totalBefore += before;

                        console.log(`üìÑ [FIX DUPLICATES] Processing: ${csvFile.fileName} (${before} transactions)`);

                        // Count before deduplication
                        const spentBeforeCount = csvFile.transactions.filter(t => t.spent && t.spent.trim()).length;
                        const receivedBeforeCount = csvFile.transactions.filter(t => t.received && t.received.trim()).length;
                        totalSpentBefore += spentBeforeCount;
                        totalReceivedBefore += receivedBeforeCount;

                        console.log(`   üìä BEFORE: ${spentBeforeCount} spent, ${receivedBeforeCount} received`);
                        console.log(`   üîç Sample transactions BEFORE:`, csvFile.transactions.slice(0, 3));

                        // Deduplicate transactions using date + description + amount as unique key
                        const uniqueTransactions = [];
                        const seen = new Set();
                        let duplicatesRemoved = 0;

                        for (const trans of csvFile.transactions || []) {
                            // Create unique key using ALL important fields to identify EXACT duplicates only
                            const key = `${trans.date}|${trans.description}|${trans.spent}|${trans.received}|${trans.fromTo}`;

                            if (!seen.has(key)) {
                                seen.add(key);
                                uniqueTransactions.push(trans);
                            } else {
                                duplicatesRemoved++;
                                console.log(`   üóëÔ∏è Removing EXACT duplicate:`, {
                                    date: trans.date,
                                    description: trans.description.substring(0, 30) + '...',
                                    spent: trans.spent,
                                    received: trans.received,
                                    fromTo: trans.fromTo,
                                    uniqueKey: key
                                });
                            }
                        }

                        console.log(`   ‚ÑπÔ∏è [FIX DUPLICATES] Deduplication complete for ${csvFile.fileName}`);
                        console.log(`   üìä Unique transactions found: ${uniqueTransactions.length}`);
                        console.log(`   üóëÔ∏è Exact duplicates removed: ${duplicatesRemoved}`);

                        const after = uniqueTransactions.length;
                        totalAfter += after;
                        const removed = before - after;

                        // Log spent vs received breakdown after deduplication
                        const spentCount = uniqueTransactions.filter(t => t.spent && t.spent.trim()).length;
                        const receivedCount = uniqueTransactions.filter(t => t.received && t.received.trim()).length;
                        totalSpentAfter += spentCount;
                        totalReceivedAfter += receivedCount;

                        console.log(`‚úÖ [FIX DUPLICATES] ${csvFile.fileName}: ${before} ‚Üí ${after} (removed ${removed} duplicates)`);
                        console.log(`   üìä BEFORE: ${spentBeforeCount} spent, ${receivedBeforeCount} received`);
                        console.log(`   üìä AFTER:  ${spentCount} spent, ${receivedCount} received`);
                        console.log(`   üîç Sample transactions AFTER:`, uniqueTransactions.slice(0, 3));

                        // Safety check: Verify no data type was completely wiped out
                        if (spentBeforeCount > 0 && spentCount === 0) {
                            console.error(`   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING: All ${spentBeforeCount} SPENT transactions were removed! Skipping save for this file.`);
                            continue; // Skip saving this file
                        }
                        if (receivedBeforeCount > 0 && receivedCount === 0) {
                            console.error(`   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL WARNING: All ${receivedBeforeCount} RECEIVED transactions were removed! Skipping save for this file.`);
                            continue; // Skip saving this file
                        }

                        // Update the CSV file with deduplicated transactions
                        csvFile.transactions = uniqueTransactions;
                        csvFile.transactionCount = after;

                        // Save back to IndexedDB
                        const updateTransaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                        const updateStore = updateTransaction.objectStore(CSV_STORE_NAME);
                        await new Promise((resolve, reject) => {
                            const updateRequest = updateStore.put(csvFile);
                            updateRequest.onsuccess = () => resolve();
                            updateRequest.onerror = () => reject(updateRequest.error);
                        });
                    }

                    console.log(`\nüéâ [FIX DUPLICATES] === SUMMARY ===`);
                    console.log(`üìä [FIX DUPLICATES] Total transactions: ${totalBefore} ‚Üí ${totalAfter} (removed ${totalBefore - totalAfter} exact duplicates)`);
                    console.log(`üí≥ [FIX DUPLICATES] SPENT transactions: ${totalSpentBefore} ‚Üí ${totalSpentAfter} (${totalSpentBefore - totalSpentAfter} removed)`);
                    console.log(`üí∞ [FIX DUPLICATES] RECEIVED transactions: ${totalReceivedBefore} ‚Üí ${totalReceivedAfter} (${totalReceivedBefore - totalReceivedAfter} removed)`);

                    // Verify data integrity
                    const spentLoss = totalSpentBefore > 0 ? ((totalSpentBefore - totalSpentAfter) / totalSpentBefore * 100).toFixed(1) : 0;
                    const receivedLoss = totalReceivedBefore > 0 ? ((totalReceivedBefore - totalReceivedAfter) / totalReceivedBefore * 100).toFixed(1) : 0;

                    console.log(`üìà [FIX DUPLICATES] SPENT loss: ${spentLoss}% | RECEIVED loss: ${receivedLoss}%`);

                    if (totalSpentBefore > 0 && totalSpentAfter === 0) {
                        console.error(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [FIX DUPLICATES] CRITICAL ERROR: ALL SPENT TRANSACTIONS WERE REMOVED! This is likely a bug!`);
                        alert('‚ö†Ô∏è ERROR: All spent transactions were removed during deduplication. The operation was aborted to prevent data loss. Please check the console for details.');
                        return;
                    }

                    if (totalReceivedBefore > 0 && totalReceivedAfter === 0) {
                        console.error(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è [FIX DUPLICATES] CRITICAL ERROR: ALL RECEIVED transactions were removed! This is likely a bug!`);
                        alert('‚ö†Ô∏è ERROR: All received transactions were removed during deduplication. The operation was aborted to prevent data loss. Please check the console for details.');
                        return;
                    }

                    const message = `‚úÖ Fixed! Removed ${totalBefore - totalAfter} exact duplicate transactions.\nSpent: ${totalSpentBefore} ‚Üí ${totalSpentAfter} | Received: ${totalReceivedBefore} ‚Üí ${totalReceivedAfter}`;
                    showToast(message, 'success', toastPosition);

                    // Reload the page to show clean data
                    setTimeout(() => location.reload(), 1500);
                };

                getAllRequest.onerror = () => {
                    console.error('‚ùå [FIX DUPLICATES] Failed to load CSV files:', getAllRequest.error);
                    showSimpleToast('‚ùå Failed to fix duplicates', 'error', toastPosition);
                };
            } catch (error) {
                console.error('‚ùå [FIX DUPLICATES] Error:', error);
                showSimpleToast('‚ùå Error fixing duplicates', 'error', toastPosition);
            }
        }

        /**
         * Clear CSV files and transactions only (preserve project budgets)
         */
        async function clearAndRefreshDatabase(event) {
            console.log('üîÑ [RESET CSV] User clicked Reset DB button');

            // Get button position for toast placement
            const buttonRect = event?.target?.getBoundingClientRect();
            const toastPosition = buttonRect ? { x: buttonRect.right, y: buttonRect.top } : null;

            // Show confirmation dialog
            const confirmed = confirm(
                '‚ö†Ô∏è RESET CSV DATA\n\n' +
                'This will delete:\n' +
                '  ‚Ä¢ All saved CSV files\n' +
                '  ‚Ä¢ All transactions\n' +
                '  ‚Ä¢ All transaction assignments\n\n' +
                '‚úÖ This will PRESERVE:\n' +
                '  ‚Ä¢ Your project budgets\n' +
                '  ‚Ä¢ Your project settings\n' +
                '  ‚Ä¢ Your invoices\n\n' +
                'After reset, you will need to re-upload your CSV files.\n\n' +
                'Continue?'
            );

            if (!confirmed) {
                console.log('üîÑ [RESET CSV] User cancelled operation');
                return;
            }

            console.log('üîÑ [RESET CSV] Starting CSV data reset...');
            showSimpleToast('üîÑ Clearing CSV data...', 'info', toastPosition);

            try {
                if (!db) {
                    await initIndexedDB();
                }

                // Clear only the csvFiles object store (preserve projects and invoices)
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);
                const clearRequest = objectStore.clear();

                clearRequest.onsuccess = () => {
                    console.log('‚úÖ [RESET CSV] CSV files cleared successfully');

                    // Clear in-memory transaction data
                    allTransactions = [];
                    savedCSVFiles = [];

                    showSimpleToast('‚úÖ CSV data cleared! Reloading...', 'success', toastPosition);

                    // Reload the page after a short delay
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                };

                clearRequest.onerror = (event) => {
                    console.error('‚ùå [RESET CSV] Failed to clear CSV files:', event);
                    showSimpleToast('‚ùå Failed to clear CSV data', 'error', toastPosition);
                };

            } catch (error) {
                console.error('‚ùå [RESET CSV] Error:', error);
                showSimpleToast('‚ùå Error clearing CSV data', 'error', toastPosition);
            }
        }

        // Download currently displayed table as CSV
        function downloadCurrentTableAsCSV() {
            console.log('üì• [CSV EXPORT] Starting CSV export...');

            if (allTransactions.length === 0) {
                showSimpleToast('‚ö†Ô∏è No transactions to export', 'warning');
                return;
            }

            // Apply same filters as renderTransactions
            let transactionsWithIndices = allTransactions.map((transaction, originalIndex) => ({
                transaction,
                originalIndex
            }));

            // Filter by completion mode
            transactionsWithIndices = transactionsWithIndices.filter(item => {
                const isCompleted = item.transaction.completed === true;
                return completionMode === 'complete' ? isCompleted : !isCompleted;
            });

            // Filter by flagged status if enabled
            if (showOnlyRedFlag || showOnlyBlueFlag) {
                transactionsWithIndices = transactionsWithIndices.filter(item => {
                    const transaction = item.transaction;
                    // If both filters are enabled, show both red and blue flagged items
                    if (showOnlyRedFlag && showOnlyBlueFlag) {
                        return transaction.flagged === 'red' || transaction.flagged === 'blue' || transaction.flagged === true; // Include legacy boolean true
                    }
                    // If only red flag filter is enabled
                    if (showOnlyRedFlag) {
                        return transaction.flagged === 'red' || transaction.flagged === true; // Include legacy boolean true
                    }
                    // If only blue flag filter is enabled
                    if (showOnlyBlueFlag) {
                        return transaction.flagged === 'blue';
                    }
                    return false;
                });
            }

            // Apply project/category filters
            if (currentFilterProject || currentFilterCategory) {
                transactionsWithIndices = transactionsWithIndices.filter(item => {
                    const transaction = item.transaction;
                    if (!transaction.assignments || transaction.assignments.length === 0) {
                        return false;
                    }
                    return transaction.assignments.some(assignment => {
                        let projectMatch = true;
                        let categoryMatch = true;
                        if (currentFilterProject) {
                            projectMatch = assignment.projectId == currentFilterProject;
                        }
                        if (currentFilterCategory) {
                            categoryMatch = assignment.category === currentFilterCategory;
                        }
                        return projectMatch && categoryMatch;
                    });
                });
            }

            if (transactionsWithIndices.length === 0) {
                showSimpleToast('‚ö†Ô∏è No transactions match current filters', 'warning');
                return;
            }

            console.log(`üì• [CSV EXPORT] Exporting ${transactionsWithIndices.length} transactions`);

            // CSV Headers
            const headers = [
                'Bank',
                'Date',
                'Description',
                'Detail',
                'From/To',
                'Spent',
                'Spent (ex. VAT)',
                'Received',
                'Notes',
                'Assigned To',
                'Category',
                'Project',
                'Quarter',
                'Invoice Attached',
                'Completed',
                'Flagged'
            ];

            // Build CSV rows
            const csvRows = [headers.join(',')];

            transactionsWithIndices.forEach(item => {
                const t = item.transaction;

                // Helper to escape CSV fields
                const escapeCSV = (field) => {
                    if (field === null || field === undefined) return '';
                    const str = String(field);
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return str;
                };

                // Check if invoice is attached
                const invoiceAttached = (t.invoices && t.invoices.length > 0) || t.invoiceId ? 'Yes' : 'No';

                // Calculate VAT-exclusive amount
                const spentAmount = parseFloat(t.spent?.replace(/[¬£,]/g, '') || 0);
                let spentExVAT = '';

                // Check if 0% VAT is applied or if spent_ex_vat is manually set
                if (t.zeroVAT || t.spent_ex_vat) {
                    const exVatAmount = parseFloat(t.spent_ex_vat?.toString().replace(/[¬£,]/g, '') || t.spent?.replace(/[¬£,]/g, '') || 0);
                    spentExVAT = exVatAmount > 0 ? exVatAmount.toFixed(2) : '';
                } else {
                    // Default: calculate with 20% VAT
                    spentExVAT = spentAmount > 0 ? (spentAmount / 1.2).toFixed(2) : '';
                }

                // Build assignment info (handle multiple assignments)
                let assignedTo = '';
                let assignedCategory = '';
                let assignedProject = '';
                let assignedQuarter = '';

                if (t.assignments && t.assignments.length > 0) {
                    // For multiple assignments, join with semicolon
                    assignedTo = t.assignments.map(a => {
                        const percentage = a.percentage === 100 ? '' : ` (${a.percentage}%)`;
                        return `${a.itemName}${percentage}`;
                    }).join('; ');
                    assignedCategory = t.assignments.map(a => a.category).join('; ');
                    assignedProject = t.assignments.map(a => a.projectName || 'Unknown').join('; ');
                    assignedQuarter = t.assignments.map(a => a.quarter ? `Q${a.quarter}` : '').join('; ');
                } else if (t.assignedItemName) {
                    // Legacy single assignment
                    assignedTo = t.assignedItemName;
                    assignedCategory = t.assignedCategory || '';
                    assignedProject = t.assignedProjectName || '';
                }

                const row = [
                    escapeCSV(t.bank || ''),
                    escapeCSV(t.date || ''),
                    escapeCSV(t.description || ''),
                    escapeCSV(t.detail || t.manualDescription || ''),
                    escapeCSV(t.fromTo || ''),
                    escapeCSV(t.spent || ''),
                    escapeCSV(spentExVAT),
                    escapeCSV(t.received || ''),
                    escapeCSV(t.voiceNotes || ''),
                    escapeCSV(assignedTo),
                    escapeCSV(assignedCategory),
                    escapeCSV(assignedProject),
                    escapeCSV(assignedQuarter),
                    escapeCSV(invoiceAttached),
                    escapeCSV(t.completed ? 'Yes' : 'No'),
                    escapeCSV(t.flagged ? 'Yes' : 'No')
                ];

                csvRows.push(row.join(','));
            });

            // Create CSV content
            const csvContent = csvRows.join('\n');

            // Create blob and download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            // Generate filename with timestamp and filter info
            const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const modeLabel = completionMode === 'complete' ? 'completed' : 'incomplete';
            const filterLabel = showOnlyFlagged ? '_flagged' : '';
            const filename = `spend_export_${modeLabel}${filterLabel}_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`‚úÖ [CSV EXPORT] Downloaded ${transactionsWithIndices.length} transactions as ${filename}`);
            showSimpleToast(`üì• Downloaded ${transactionsWithIndices.length} transactions`, 'success');
        }

        // Initialize on page load
        let isPageInitialized = false;
        document.addEventListener('DOMContentLoaded', async () => {
            if (isPageInitialized) {
                console.warn('‚ö†Ô∏è [PAGE LOAD] Page already initialized, skipping duplicate initialization');
                return;
            }

            console.log('üöÄ [PAGE LOAD] Spend page initializing...');

            try {
                loadDisplaySettings();
                await initIndexedDB();
                await loadProjectsFromDB();
                await loadSavedCSVFiles();
                updateAPIKeyStatus(); // Update API key status display

                // Auto-configure OpenExchangeRates App ID if not already set
                if (!localStorage.getItem('exchangeRateApiKey')) {
                    localStorage.setItem('exchangeRateApiKey', 'e30981c5ed1f418fb5cac0faf1dccfe4');
                }

                updateExchangeRateStatus(); // Update exchange rate API status display
                loadGmailAccountsFromStorage(); // Restore saved Gmail accounts
                updateGmailStatus(); // Update UI to show restored accounts

                // Note: Transaction reference migration now happens AFTER CSV files are loaded
                // See autoLoadSavedCSVs() function for the migration call

                // Final summary
                console.log(`‚úÖ [PAGE LOAD] Complete! Database initialized, CSV files will load next.`);

                // Populate project filter dropdown
                populateProjectFilter();

                // Initialize completion mode UI
                console.log('‚úÖ [PAGE LOAD] Initializing completion mode...');
                const toggle = document.getElementById('completionModeToggle');
                if (toggle) {
                    toggle.checked = completionMode === 'complete';
                    updateCompletionModeUI();
                }

                isPageInitialized = true;
            } catch (error) {
                console.error('‚ùå [PAGE LOAD] Initialization failed:', error);
                showSimpleToast('‚ùå Failed to initialize page. Please refresh.', 'error');
            }
        });

        // Drag and drop removed - using compact file input button in Bank Feed card

        // File upload handler
        document.getElementById('csvFileInput').addEventListener('change', async function(e) {
            const files = e.target.files;
            if (files.length === 0) return;

            for (let file of files) {
                await loadAndSaveCSVFile(file);
            }

            renderTransactions();
            updateSummary();
            updateCSVSummary();
            // Reset file input to allow reloading same file
            e.target.value = '';
        });

        // ========================================
        // DRAG AND DROP FOR CSV FILES
        // ========================================

        const dropZone = document.getElementById('bankFeedDropZone');

        // Prevent default drag behaviors on the entire page
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // Highlight drop zone when dragging over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, function() {
                dropZone.style.background = 'linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%)';
                dropZone.style.border = '2px dashed #3AAFA9';
                dropZone.style.transform = 'scale(1.02)';
            }, false);
        });

        // Remove highlight when leaving drop zone
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, function() {
                dropZone.style.background = '';
                dropZone.style.border = '';
                dropZone.style.transform = '';
            }, false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', async function(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length === 0) return;

            // Filter for CSV files only
            const csvFiles = Array.from(files).filter(file =>
                file.name.toLowerCase().endsWith('.csv')
            );

            if (csvFiles.length === 0) {
                showSimpleToast('‚ö†Ô∏è Please drop CSV files only', 'error');
                return;
            }

            // Process each CSV file
            for (let file of csvFiles) {
                await loadAndSaveCSVFile(file);
            }

            renderTransactions();
            updateSummary();
            updateCSVSummary();

            showSimpleToast(`‚úÖ Loaded ${csvFiles.length} CSV file(s)`, 'success');
        }, false);

        function updateBudgetInfo() {
            console.log('üîÑ [BUDGET INFO] Starting updateBudgetInfo...');
            const infoDiv = document.getElementById('loadedBudgetsInfo');

            console.log(`üìä [BUDGET INFO] allProjects.length: ${allProjects.length}`);

            if (allProjects.length === 0) {
                console.log('‚ö†Ô∏è [BUDGET INFO] No projects to display');
                infoDiv.innerHTML = 'No budgets found';
                return;
            }

            // Automatically activate ALL projects
            activeProjects = allProjects;
            console.log(`‚úÖ [BUDGET INFO] Activated ${activeProjects.length} projects`);

            // Build compact summary
            let totalBudget = 0;
            console.log('üí∞ [BUDGET INFO] Calculating total budget...');

            allProjects.forEach((project, index) => {
                const labour = project.labour?.totalCost || 0;
                const overheads = project.overheads?.totalCost || 0;
                const materials = project.materials?.totalCost || 0;
                const capital = project.capitalUsage?.totalCost || 0;
                const subcontracting = project.subcontracting?.totalCost || 0;
                const travel = project.travel?.totalCost || 0;
                const other = project.otherCosts?.totalCost || 0;

                const projectTotal = labour + overheads + materials + capital + subcontracting + travel + other;

                console.log(`   Project ${index + 1} (${project.projectName || 'Unnamed'}):`, {
                    labour: `¬£${labour}`,
                    overheads: `¬£${overheads}`,
                    materials: `¬£${materials}`,
                    capital: `¬£${capital}`,
                    subcontracting: `¬£${subcontracting}`,
                    travel: `¬£${travel}`,
                    other: `¬£${other}`,
                    projectTotal: `¬£${projectTotal}`
                });

                totalBudget += projectTotal;
            });

            console.log(`üí∞ [BUDGET INFO] Total budget across all projects: ¬£${totalBudget.toLocaleString()}`);

            const displayText = `${allProjects.length} project${allProjects.length > 1 ? 's' : ''} (¬£${totalBudget.toLocaleString()})`;
            console.log(`‚úÖ [BUDGET INFO] Setting display text: "${displayText}"`);
            infoDiv.innerHTML = displayText;

            // Update the project filter dropdown with all loaded projects
            console.log('üîÑ [BUDGET INFO] Calling populateProjectFilter()...');
            populateProjectFilter();

            console.log('‚úÖ [BUDGET INFO] updateBudgetInfo complete');
        }


        async function loadCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const transactions = parseCSV(content);
                    allTransactions.push(...transactions);
                    resolve();
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function loadAndSaveCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const content = e.target.result;

                    // Detect bank from filename
                    const bankIdentifier = detectBank(file.name);

                    const transactions = parseCSV(content, bankIdentifier);

                    // APPEND transactions instead of replacing
                    allTransactions.push(...transactions);

                    // Save to IndexedDB
                    await saveCSVFileToDB(file.name, transactions, bankIdentifier);

                    resolve();
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function detectBank(fileName) {
            const nameLower = fileName.toLowerCase();
            if (nameLower.includes('revolut')) {
                return 'R';
            } else if (nameLower.includes('metro')) {
                return 'M';
            }
            return '?'; // Unknown bank
        }

        function parseCSV(csvText, bankIdentifier = '?') {
            console.log('üìù [PARSE CSV] Starting CSV parsing...');
            console.log(`üìè [PARSE CSV] CSV text length: ${csvText.length} characters`);
            console.log(`üè¶ [PARSE CSV] Bank identifier: "${bankIdentifier}"`);

            const lines = csvText.split('\n');
            console.log(`üìÑ [PARSE CSV] Total lines: ${lines.length}`);
            console.log(`üìÑ [PARSE CSV] Header line: "${lines[0]}"`);

            const transactions = [];

            // Parse header row to identify column indices
            const headerLine = lines[0].trim();
            const headerFields = parseCSVLine(headerLine);
            console.log(`üìã [PARSE CSV] Header fields:`, headerFields);

            // Detect column indices based on header names
            const columnMap = {
                date: -1,
                description: -1,
                spent: -1,
                received: -1,
                fromTo: -1,
                transactionPosted: -1
            };

            headerFields.forEach((header, index) => {
                const lowerHeader = header.toLowerCase().trim();

                // Date column
                if (lowerHeader.includes('date') && columnMap.date === -1) {
                    columnMap.date = index;
                }
                // Description column
                else if ((lowerHeader.includes('description') || lowerHeader.includes('details') ||
                         lowerHeader.includes('narrative')) && columnMap.description === -1) {
                    columnMap.description = index;
                }
                // Spent/Debit/Money Out column
                else if ((lowerHeader.includes('spent') || lowerHeader.includes('debit') ||
                         lowerHeader.includes('money out') || lowerHeader.includes('paid out') ||
                         lowerHeader.includes('withdrawal')) && columnMap.spent === -1) {
                    columnMap.spent = index;
                }
                // Received/Credit/Money In column
                else if ((lowerHeader.includes('received') || lowerHeader.includes('credit') ||
                         lowerHeader.includes('money in') || lowerHeader.includes('paid in') ||
                         lowerHeader.includes('deposit')) && columnMap.received === -1) {
                    columnMap.received = index;
                }
                // From/To column
                else if ((lowerHeader.includes('from') || lowerHeader.includes('to') ||
                         lowerHeader.includes('payee')) && columnMap.fromTo === -1) {
                    columnMap.fromTo = index;
                }
                // Transaction Posted column
                else if (lowerHeader.includes('posted') && columnMap.transactionPosted === -1) {
                    columnMap.transactionPosted = index;
                }
            });

            console.log(`üó∫Ô∏è [PARSE CSV] Column mapping:`, columnMap);
            console.log(`   üìÖ Date: column ${columnMap.date}`);
            console.log(`   üìù Description: column ${columnMap.description}`);
            console.log(`   üí∏ Spent: column ${columnMap.spent}`);
            console.log(`   üí∞ Received: column ${columnMap.received}`);
            console.log(`   üë§ From/To: column ${columnMap.fromTo}`);

            // If column detection failed, fall back to default indices
            if (columnMap.date === -1) columnMap.date = 0;
            if (columnMap.description === -1) columnMap.description = 1;
            if (columnMap.spent === -1) columnMap.spent = 2;
            if (columnMap.received === -1) columnMap.received = 3;
            if (columnMap.fromTo === -1) columnMap.fromTo = 4;
            if (columnMap.transactionPosted === -1) columnMap.transactionPosted = 5;

            for (let i = 1; i < lines.length; i++) { // Skip header row
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);

                if (fields.length >= 4) {
                    const transaction = {
                        bank: bankIdentifier,
                        date: fields[columnMap.date] || '',
                        description: fields[columnMap.description] || '',
                        spent: fields[columnMap.spent] || '',
                        received: fields[columnMap.received] || '',
                        fromTo: fields[columnMap.fromTo] || '',
                        transactionPosted: fields[columnMap.transactionPosted] || ''
                    };
                    transactions.push(transaction);

                    // Log first 3 transactions for debugging
                    if (i <= 3) {
                        console.log(`üí≥ [PARSE CSV] Transaction ${i}:`, transaction);
                    }
                }
            }

            console.log(`‚úÖ [PARSE CSV] Parsed ${transactions.length} transactions`);

            // Log spent vs received breakdown
            const spentCount = transactions.filter(t => t.spent && t.spent.trim()).length;
            const receivedCount = transactions.filter(t => t.received && t.received.trim()).length;
            console.log(`üí∞ [PARSE CSV] Breakdown: ${spentCount} spent, ${receivedCount} received`);

            // Log first few spent and received transactions for verification
            const sampleSpent = transactions.filter(t => t.spent && t.spent.trim()).slice(0, 3);
            const sampleReceived = transactions.filter(t => t.received && t.received.trim()).slice(0, 3);
            if (sampleSpent.length > 0) {
                console.log(`üì§ [PARSE CSV] Sample SPENT transactions:`, sampleSpent);
            }
            if (sampleReceived.length > 0) {
                console.log(`üì• [PARSE CSV] Sample RECEIVED transactions:`, sampleReceived);
            }

            return transactions;
        }

        // Helper function to parse a single CSV line (handles quoted fields)
        function parseCSVLine(line) {
            const fields = [];
            let currentField = '';
            let inQuotes = false;

            for (let j = 0; j < line.length; j++) {
                const char = line[j];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    fields.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            fields.push(currentField); // Add last field

            return fields;
        }

        // ========================================
        // FILTERING FUNCTIONALITY
        // ========================================

        let currentFilterProject = '';
        let currentFilterCategory = '';

        function populateProjectFilter() {
            const filterSelect = document.getElementById('filterProject');
            if (!filterSelect) {
                console.warn('‚ö†Ô∏è [POPULATE FILTER] filterProject element not found');
                return;
            }

            console.log('üìã [POPULATE FILTER] Starting to populate project filter...');
            console.log('üìä [POPULATE FILTER] Active projects loaded:', activeProjects.length);

            // Clear and rebuild options
            filterSelect.innerHTML = '<option value="">All Projects</option>';

            // Add General Expenses first
            filterSelect.innerHTML += '<option value="GENERAL_EXPENSES">PEBL General Expenses</option>';

            // Add all loaded projects (from grants) sorted by name
            if (activeProjects && activeProjects.length > 0) {
                const sortedProjects = [...activeProjects].sort((a, b) => {
                    const nameA = a.projectName || a.projectNumber || '';
                    const nameB = b.projectName || b.projectNumber || '';
                    return nameA.localeCompare(nameB);
                });

                sortedProjects.forEach(proj => {
                    const projectName = proj.projectName || proj.projectNumber || `Project ${proj.projectId}`;
                    console.log('üîç [POPULATE FILTER] Adding project to dropdown:', proj.projectId, '-', projectName);
                    filterSelect.innerHTML += `<option value="${proj.projectId}">${escapeHtml(projectName)}</option>`;
                });

                console.log('‚úÖ [POPULATE FILTER] Added', sortedProjects.length, 'projects to dropdown');
            } else {
                console.warn('‚ö†Ô∏è [POPULATE FILTER] No active projects found');
            }
        }

        function handleProjectFilterChange() {
            const filterSelect = document.getElementById('filterProject');
            const categorySelect = document.getElementById('filterCategory');
            const statusDiv = document.getElementById('filterStatus');

            currentFilterProject = filterSelect.value;

            console.log('üîç [FILTER] Project filter changed:', currentFilterProject);

            // Reset category filter
            categorySelect.innerHTML = '<option value="">All Categories</option>';
            currentFilterCategory = '';

            if (currentFilterProject) {
                // Enable category filter and populate with categories from selected project
                categorySelect.disabled = false;

                const categories = new Set();
                allTransactions.forEach(trans => {
                    if (trans.assignments && trans.assignments.length > 0) {
                        trans.assignments.forEach(assignment => {
                            if (assignment.projectId == currentFilterProject && assignment.category) {
                                categories.add(assignment.category);
                            }
                        });
                    }
                });

                console.log('üìã [FILTER] Found', categories.size, 'categories for project');

                Array.from(categories).sort().forEach(cat => {
                    categorySelect.innerHTML += `<option value="${escapeHtml(cat)}">${escapeHtml(cat)}</option>`;
                });
            } else {
                categorySelect.disabled = true;
            }

            applyFilters();
        }

        function applyFilters() {
            const categorySelect = document.getElementById('filterCategory');
            const statusDiv = document.getElementById('filterStatus');

            currentFilterCategory = categorySelect.value;

            renderTransactions();

            // Update status message
            let statusMsg = '';
            if (currentFilterProject) {
                const projectSelect = document.getElementById('filterProject');
                const projectName = projectSelect.options[projectSelect.selectedIndex].text;
                statusMsg = `Showing: ${projectName}`;
                if (currentFilterCategory) {
                    statusMsg += ` ‚Üí ${currentFilterCategory}`;
                }
            } else {
                statusMsg = 'Showing: All transactions';
            }
            statusDiv.textContent = statusMsg;
        }

        function clearFilters() {
            currentFilterProject = '';
            currentFilterCategory = '';
            document.getElementById('filterProject').value = '';
            document.getElementById('filterCategory').value = '';
            document.getElementById('filterCategory').disabled = true;
            document.getElementById('filterCategory').innerHTML = '<option value="">All Categories</option>';
            document.getElementById('filterStatus').textContent = 'Showing: All transactions';
            renderTransactions();
        }

        function jumpToTopUnassigned() {
            console.log('üéØ [JUMP] Searching for first unassigned transaction...');

            // Clear filters to show all transactions
            clearFilters();

            // Find the first unassigned transaction
            const firstUnassignedIndex = allTransactions.findIndex(transaction => {
                // Check if transaction has no assignments
                const hasNoAssignments = (!transaction.assignments || transaction.assignments.length === 0) &&
                                        !transaction.assignedItemName;
                return hasNoAssignments;
            });

            if (firstUnassignedIndex === -1) {
                // No unassigned transactions found
                alert('üéâ No unassigned transactions found! All expenses have been assigned.');
                console.log('‚úÖ [JUMP] All transactions are assigned');
                return;
            }

            console.log(`üéØ [JUMP] Found unassigned transaction at index ${firstUnassignedIndex}`);

            // Select the row
            selectedRowIndex = firstUnassignedIndex;
            renderTransactions();

            // Wait for render to complete, then scroll to it
            setTimeout(() => {
                scrollRowIntoView(firstUnassignedIndex);

                // Focus on the row for keyboard shortcuts
                const row = document.querySelector(`tr[data-row-index="${firstUnassignedIndex}"]`);
                if (row) {
                    row.focus();
                    console.log('‚úÖ [JUMP] Row focused and ready for keyboard shortcuts');
                }
            }, 100);
        }

        function renderTransactions() {
            console.log('üé® [RENDER] Starting renderTransactions...');
            console.log(`üìä [RENDER] allTransactions.length: ${allTransactions.length}`);
            if (allTransactions.length > 0) {
                console.log(`üîç [RENDER] First transaction:`, allTransactions[0]);
                console.log(`üîç [RENDER] Transaction keys:`, Object.keys(allTransactions[0]));
                console.log(`üë§ [RENDER] First transaction fromTo:`, allTransactions[0].fromTo);
                console.log(`üîç [RENDER] Sample transactions:`, allTransactions.slice(0, 3));
            }

            const tbody = document.getElementById('tableBody');

            if (allTransactions.length === 0) {
                console.log('‚ö†Ô∏è [RENDER] No transactions to render');
                tbody.innerHTML = '<tr class="empty-state"><td colspan="11">No transactions loaded. Please upload a CSV file.</td></tr>';
                return;
            }

            // Apply filters
            // First, map transactions with their original indices
            let transactionsWithIndices = allTransactions.map((transaction, originalIndex) => ({
                transaction,
                originalIndex
            }));

            // Filter by completion mode
            transactionsWithIndices = transactionsWithIndices.filter(item => {
                const isCompleted = item.transaction.completed === true;
                return completionMode === 'complete' ? isCompleted : !isCompleted;
            });

            // Filter by flagged status if enabled
            if (showOnlyRedFlag || showOnlyBlueFlag) {
                transactionsWithIndices = transactionsWithIndices.filter(item => {
                    const transaction = item.transaction;
                    // If both filters are enabled, show both red and blue flagged items
                    if (showOnlyRedFlag && showOnlyBlueFlag) {
                        return transaction.flagged === 'red' || transaction.flagged === 'blue' || transaction.flagged === true; // Include legacy boolean true
                    }
                    // If only red flag filter is enabled
                    if (showOnlyRedFlag) {
                        return transaction.flagged === 'red' || transaction.flagged === true; // Include legacy boolean true
                    }
                    // If only blue flag filter is enabled
                    if (showOnlyBlueFlag) {
                        return transaction.flagged === 'blue';
                    }
                    return false;
                });
            }

            // Then apply project/category filters
            if (currentFilterProject || currentFilterCategory) {
                const beforeCount = transactionsWithIndices.length;

                transactionsWithIndices = transactionsWithIndices.filter(item => {
                    const transaction = item.transaction;
                    // Check if transaction has assignments matching the filter
                    if (!transaction.assignments || transaction.assignments.length === 0) {
                        return false; // Don't show unassigned transactions when filtering
                    }

                    return transaction.assignments.some(assignment => {
                        let projectMatch = true;
                        let categoryMatch = true;

                        if (currentFilterProject) {
                            projectMatch = assignment.projectId == currentFilterProject;
                        }

                        if (currentFilterCategory) {
                            categoryMatch = assignment.category === currentFilterCategory;
                        }

                        return projectMatch && categoryMatch;
                    });
                });

                console.log(`üîç [RENDER FILTER] Filtered to ${transactionsWithIndices.length} of ${beforeCount} transactions`);
            }

            console.log(`‚úÖ [RENDER] Rendering ${transactionsWithIndices.length} of ${allTransactions.length} transactions...`);
            tbody.innerHTML = transactionsWithIndices.map((item, filteredIndex) => {
                const transaction = item.transaction;
                const index = item.originalIndex;

                // Debug first transaction
                if (filteredIndex === 0) {
                    console.log(`üë§ [RENDER ROW 0] fromTo value: "${transaction.fromTo}"`);
                    console.log(`üë§ [RENDER ROW 0] Has fromTo field: ${transaction.hasOwnProperty('fromTo')}`);
                    console.log(`üë§ [RENDER ROW 0] Original index: ${index}`);
                }

                // Helper function to truncate text with popup
                const truncateWithPopup = (text, maxLength, fieldName, rowIndex) => {
                    if (!text || text.length <= maxLength) {
                        return escapeHtml(text);
                    }
                    const truncated = text.substring(0, maxLength) + '...';
                    return `<span onclick="showTextPopup('${fieldName}', ${rowIndex}); event.stopPropagation();" style="cursor: pointer; text-decoration: underline dotted;" title="Click to view full text">${escapeHtml(truncated)}</span>`;
                };

                // Description column - always show original bank description (unchanged)
                const descriptionText = transaction.description || '';
                // Use high maxLength to let CSS line-clamp handle visual truncation
                const descriptionHtml = `<span style="font-size: 11px; color: #64748b;">${truncateWithPopup(descriptionText, 500, 'description', index)}</span>`;

                // Detail column - show manual description, voice notes, or AI-generated detail
                let detailHtml = '';
                if (transaction.detail) {
                    // AI-generated or manually set detail
                    const detailText = transaction.detail;
                    // Use high maxLength to let CSS line-clamp handle visual truncation
                    detailHtml = `<span style="font-size: 11px; color: #1e293b; font-weight: 500;">${truncateWithPopup(detailText, 500, 'detail', index)}</span>`;
                } else if (transaction.manualDescription) {
                    // Legacy field - migrate to detail
                    const detailText = transaction.manualDescription;
                    detailHtml = `<span style="font-size: 11px; color: #1e293b; font-weight: 500;">${truncateWithPopup(detailText, 500, 'detail', index)}</span>`;
                } else {
                    detailHtml = `<span style="font-size: 10px; color: #94a3b8; font-style: italic;">-</span>`;
                }

                // Handle both old single assignment format and new split assignments array - COMPACT VERSION
                let categoryBadges = '';
                if (transaction.assignments && transaction.assignments.length > 0) {
                    // New format: array of assignments - compact single-line badges with √ó button
                    categoryBadges = transaction.assignments.map((assignment, assignmentIndex) => {
                        const quarter = assignment.quarter ? ` Q${assignment.quarter}` : '';
                        const icon = assignment.icon ? `${assignment.icon} ` : '';
                        const isGeneral = assignment.projectId === 'GENERAL_EXPENSES';
                        const badgeStyle = isGeneral ? 'background-color: #fef3c7; border: 1px solid #fbbf24;' : '';

                        // Tooltip with full details
                        const tooltipInfo = `${icon}${escapeHtml(assignment.itemName)} ‚Ä¢ ${escapeHtml(assignment.category)} ‚Ä¢ ${escapeHtml(assignment.projectName || 'Project')}${quarter}`;

                        // Badge display: show full details with percentage tag
                        const displayText = `${icon}${escapeHtml(assignment.itemName)} ‚Ä¢ ${escapeHtml(assignment.category)} ‚Ä¢ ${escapeHtml(assignment.projectName || 'Project')}${quarter}`;
                        const percentageTag = `<span style="background-color: #3b82f6; color: white; padding: 2px 5px; border-radius: 3px; margin-left: 4px; font-size: 9px; font-weight: 600;">${assignment.percentage}%</span>`;

                        return `<span class="assigned-category" title="${tooltipInfo}" style="position: relative; padding: 3px 18px 3px 6px; ${badgeStyle} display: inline-flex; align-items: center; margin: 2px 2px 2px 0; white-space: normal; word-wrap: break-word;">
                            <span style="font-size: 10px; font-weight: 500; line-height: 1.3;">${displayText}${percentageTag}</span>
                            <button onclick="handleUnassign(${index}, ${assignmentIndex}); event.stopPropagation();"
                                    style="position: absolute; top: 2px; right: 2px; background: #dc2626; border: none; border-radius: 2px; width: 14px; height: 14px; cursor: pointer; font-size: 10px; line-height: 1; padding: 0; color: white; transition: all 0.15s; font-weight: bold;"
                                    onmouseover="this.style.background='#b91c1c'; this.style.transform='scale(1.1)';"
                                    onmouseout="this.style.background='#dc2626'; this.style.transform='scale(1)';"
                                    title="Remove assignment">√ó</button>
                        </span>`;
                    }).join('');
                } else if (transaction.assignedItemName) {
                    // Old format: single assignment (backward compatibility) - compact version with √ó button
                    const isGeneral = transaction.assignedProject === 'GENERAL_EXPENSES';
                    const badgeStyle = isGeneral ? 'background-color: #fef3c7; border: 1px solid #fbbf24;' : '';
                    const tooltipInfo = `${escapeHtml(transaction.assignedItemName)} ‚Ä¢ ${escapeHtml(transaction.assignedCategory)}`;
                    const displayText = `${escapeHtml(transaction.assignedItemName)} ‚Ä¢ ${escapeHtml(transaction.assignedCategory)}`;
                    const percentageTag = `<span style="background-color: #3b82f6; color: white; padding: 2px 5px; border-radius: 3px; margin-left: 4px; font-size: 9px; font-weight: 600;">100%</span>`;
                    categoryBadges = `<span class="assigned-category" title="${tooltipInfo}" style="position: relative; padding: 3px 18px 3px 6px; ${badgeStyle} display: inline-flex; align-items: center; margin: 2px 2px 2px 0; white-space: normal; word-wrap: break-word;">
                        <span style="font-size: 10px; font-weight: 500; line-height: 1.3;">${displayText}${percentageTag}</span>
                        <button onclick="handleUnassign(${index}); event.stopPropagation();"
                                style="position: absolute; top: 2px; right: 2px; background: #dc2626; border: none; border-radius: 2px; width: 14px; height: 14px; cursor: pointer; font-size: 10px; line-height: 1; padding: 0; color: white; transition: all 0.15s; font-weight: bold;"
                                onmouseover="this.style.background='#b91c1c'; this.style.transform='scale(1.1)';"
                                onmouseout="this.style.background='#dc2626'; this.style.transform='scale(1)';"
                                title="Remove assignment">√ó</button>
                    </span>`;
                }

                // Notes column - show voice notes if available
                const notesContent = transaction.voiceNotes ? escapeHtml(transaction.voiceNotes) : '';

                // Determine assign button appearance
                const hasAssignments = (transaction.assignments && transaction.assignments.length > 0) || transaction.assignedItemName;
                const assignBtnTitle = hasAssignments ? 'Reassign / Add Split' : 'Assign to Budget';
                const assignBtnIcon = hasAssignments ? '‚û°Ô∏è' : '‚û°Ô∏è';

                // Calculate VAT-exclusive amount (divide by 1.2 for UK 20% VAT)
                const spentAmount = parseAmount(transaction.spent);
                let spentExVAT = '';

                // Check if 0% VAT is applied or if spent_ex_vat is manually set
                if (transaction.zeroVAT || transaction.spent_ex_vat) {
                    const exVatAmount = parseAmount(transaction.spent_ex_vat || transaction.spent);
                    spentExVAT = exVatAmount > 0 ? exVatAmount.toFixed(2) : '';
                } else {
                    // Default: calculate with 20% VAT
                    spentExVAT = spentAmount > 0 ? (spentAmount / 1.2).toFixed(2) : '';
                }

                // Display converted currency amount if available
                let spentDisplay = escapeHtml(transaction.spent);
                let receivedDisplay = escapeHtml(transaction.received);

                if (transaction.convertedCurrency && transaction.convertedAmount) {
                    const convertedAmountStr = transaction.convertedAmount.toFixed(2);
                    if (transaction.spent) {
                        const originalGBP = transaction.spent.replace(/¬£/g, '');
                        spentDisplay = `<div style="display: flex; flex-direction: column; align-items: flex-end;">
                            <span style="color: #10b981; font-weight: 600;">$${convertedAmountStr}</span>
                            <span style="font-size: 10px; color: #64748b;">¬£${escapeHtml(originalGBP)}</span>
                        </div>`;
                    } else if (transaction.received) {
                        const originalGBP = transaction.received.replace(/¬£/g, '');
                        receivedDisplay = `<div style="display: flex; flex-direction: column; align-items: flex-end;">
                            <span style="color: #10b981; font-weight: 600;">$${convertedAmountStr}</span>
                            <span style="font-size: 10px; color: #64748b;">¬£${escapeHtml(originalGBP)}</span>
                        </div>`;
                    }
                }

                // Add flagged class if transaction is flagged
                const rowClasses = [];
                if (selectedRowIndex === index) rowClasses.push('row-selected');
                if (transaction.flagged === 'red') rowClasses.push('row-flagged-red');
                else if (transaction.flagged === 'blue') rowClasses.push('row-flagged-blue');
                else if (transaction.flagged === true) rowClasses.push('row-flagged-red'); // Legacy support
                const rowClass = rowClasses.join(' ');

                return `
                <tr class="${rowClass}" onclick="selectRow(${index}, event)" data-row-index="${index}" tabindex="0">
                    <td style="text-align: center; font-weight: 600; color: ${transaction.bank === 'R' ? '#3AAFA9' : '#2B7A78'};">${transaction.bank || '?'}</td>
                    <td>${escapeHtml(transaction.date)}</td>
                    <td class="description-detail-cell" colspan="2">
                        <div class="description-cell">${descriptionHtml}</div>
                        <div class="detail-cell">${detailHtml}</div>
                    </td>
                    <td class="fromto-cell">${escapeHtml(transaction.fromTo || '')}</td>
                    <td class="amount-spent">${spentDisplay}</td>
                    <td class="amount-spent" style="color: #059669; font-weight: 500;">${spentExVAT}</td>
                    <td class="amount-received">${receivedDisplay}</td>
                    <td class="notes-cell">${notesContent}</td>
                    <td class="action-buttons">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 4px; min-width: 250px;">
                            <div style="display: flex; gap: 5px; white-space: nowrap;">
                                <button class="action-btn edit-btn" onclick="handleManualEdit(${index}); event.stopPropagation();" title="Add Expense Detail${selectedRowIndex === index ? ' (T)' : ''}" style="position: relative;">
                                    ‚úèÔ∏è
                                    ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #3b82f6; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">T</span>' : ''}
                                </button>
                                <button class="action-btn mic-btn" id="micBtn${index}" onclick="toggleRowVoiceRecording(${index}); event.stopPropagation();" title="Voice Note${selectedRowIndex === index ? ' (V)' : ''}" style="position: relative;">
                                    üé§
                                    ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #8b5cf6; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">V</span>' : ''}
                                </button>
                                ${(transaction.invoices && transaction.invoices.length > 0) || transaction.invoiceId ?
                                    `<button class="action-btn pdf-btn" onclick="openAttachedInvoiceManager(${index}); event.stopPropagation();" title="${(transaction.invoices && transaction.invoices.length > 1) ? `View ${transaction.invoices.length} Attached Invoices` : `View Attached Invoice: ${escapeHtml((transaction.invoices && transaction.invoices[0] && transaction.invoices[0].filename) || transaction.invoiceFilename || 'invoice.pdf')}`}" style="background: #22c55e; position: relative;">
                                        üìÑ${(transaction.invoices && transaction.invoices.length > 1) ? `<span style="position: absolute; top: -2px; right: -2px; background: #059669; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 8px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">${transaction.invoices.length}</span>` : ''}
                                        ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #059669; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">E</span>' : ''}
                                    </button>` :
                                    `<button class="action-btn invoice-btn" id="invoiceBtn${index}" onclick="handleInvoiceFetch(${index}, event); event.stopPropagation();" title="Find Invoice (Shift+Click for modal view)${selectedRowIndex === index ? ' (E)' : ''}" style="position: relative;">
                                        üìß
                                        ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #f59e0b; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">E</span>' : ''}
                                    </button>`
                                }
                                <button class="action-btn flag-btn" onclick="toggleFlag(${index}); event.stopPropagation();" title="${transaction.flagged === 'red' ? 'Red Flag - Click for Blue' : transaction.flagged === 'blue' ? 'Blue Flag - Click to Remove' : 'Click to Flag'}${selectedRowIndex === index ? ' (F)' : ''}" style="position: relative; background: ${transaction.flagged === 'red' ? '#ef4444' : transaction.flagged === 'blue' ? '#3b82f6' : 'transparent'}; transition: all 0.2s;">
                                    üö©
                                    ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #7c3aed; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">F</span>' : ''}
                                </button>
                                <button class="action-btn currency-btn" id="currencyBtn${index}" onclick="convertTransactionCurrency(${index}); event.stopPropagation();" title="${transaction.convertedCurrency ? `Converted to ${transaction.convertedCurrency} ${transaction.convertedAmount.toFixed(2)} (Click to revert)` : 'Convert GBP to USD'}" style="position: relative; background: ${transaction.convertedCurrency ? '#10b981' : 'transparent'}; transition: all 0.2s;">
                                    üí±
                                </button>
                                <button class="action-btn vat-btn" onclick="toggleZeroVAT(${index}); event.stopPropagation();" title="${transaction.zeroVAT ? 'Click to revert to original VAT calculation' : 'Set to 0% VAT (no tax)'}" style="position: relative; background: ${transaction.zeroVAT ? '#f59e0b' : 'transparent'}; transition: all 0.2s; font-size: 10px; font-weight: 600; color: ${transaction.zeroVAT ? 'white' : '#64748b'};">
                                    0%
                                </button>
                                <button class="action-btn delete-btn ${hasAssignments ? 'has-assignment' : ''}" onclick="handleAssign(${index}); event.stopPropagation();" oncontextmenu="handleUnassign(${index}); return false;" title="${assignBtnTitle}${selectedRowIndex === index ? ' (1)' : ''}" id="assignBtn${index}" style="position: relative;">
                                    ${assignBtnIcon}
                                    ${selectedRowIndex === index ? '<span style="position: absolute; top: -4px; right: -4px; background: #ef4444; color: white; border-radius: 50%; width: 14px; height: 14px; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">1</span>' : ''}
                                </button>
                            </div>
                            ${categoryBadges ? `<div style="display: flex; flex-wrap: wrap; justify-content: center; width: 100%; margin-top: 2px; gap: 2px;">${categoryBadges}</div>` : ''}
                        </div>
                    </td>
                    <td class="complete-checkbox-cell" style="text-align: center; padding: 8px; width: 60px; min-width: 60px;">
                        <input type="checkbox"
                               onclick="event.stopPropagation();"
                               onchange="markAsComplete(${index})"
                               style="width: 18px; height: 18px; cursor: pointer; accent-color: #10b981;"
                               title="Mark as complete"
                               ${transaction.completed ? 'checked' : ''}>
                    </td>
                </tr>
            `;
            }).join('');

            // Apply column visibility after rendering
            applyColumnVisibility();

            // Update completion mode UI (show/hide checkbox column)
            updateCompletionModeUI();

            // Debug: Log table headers
            console.log('üîç [RENDER] Checking table headers...');
            const headers = document.querySelectorAll('#transactionsTable th');
            console.log(`üìä [RENDER] Total headers: ${headers.length}`);
            headers.forEach((h, i) => console.log(`   Header ${i}: "${h.textContent.trim()}" (display: ${h.style.display || 'default'})`));
        }

        function updateSummary() {
            document.getElementById('totalTransactions').textContent = allTransactions.length;

            let totalSpent = 0;
            let totalReceived = 0;

            allTransactions.forEach(t => {
                const spent = parseAmount(t.spent);
                const received = parseAmount(t.received);
                totalSpent += spent;
                totalReceived += received;
            });

            document.getElementById('totalSpent').textContent = totalSpent.toFixed(2);
            document.getElementById('totalReceived').textContent = totalReceived.toFixed(2);
        }

        function parseAmount(amountStr) {
            if (!amountStr) return 0;
            // Remove currency symbols and commas
            const cleaned = amountStr.replace(/[¬£$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        /**
         * Get the ex VAT amount for a transaction
         * This calculates the amount excluding VAT for budget assignments
         */
        function getTransactionExVatAmount(transaction) {
            // Always use GBP amounts for assignments, even if transaction shows USD conversion
            // The USD amount is just for display/reference purposes

            // Handle received transactions (no VAT calculation needed)
            if (transaction.received && !transaction.spent) {
                return parseAmount(transaction.received);
            }

            const spentAmount = parseAmount(transaction.spent);

            // If 0% VAT is applied or spent_ex_vat is manually set, use that value
            if (transaction.zeroVAT || transaction.spent_ex_vat) {
                return parseAmount(transaction.spent_ex_vat || transaction.spent);
            }

            // Default: calculate ex VAT by dividing by 1.2 (20% UK VAT)
            return spentAmount / 1.2;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape string for use in JavaScript (for onclick attributes)
        function escapeJs(text) {
            if (!text) return '';
            return text
                .replace(/\\/g, '\\\\')  // Escape backslashes first
                .replace(/'/g, "\\'")     // Escape single quotes
                .replace(/"/g, '\\"')     // Escape double quotes
                .replace(/\n/g, '\\n')    // Escape newlines
                .replace(/\r/g, '\\r');   // Escape carriage returns
        }

        // Completion Mode Functions
        let completionMode = localStorage.getItem('completionViewMode') || 'incomplete';

        function toggleCompletionMode() {
            const toggle = document.getElementById('completionModeToggle');
            completionMode = toggle.checked ? 'complete' : 'incomplete';

            // Save to localStorage
            localStorage.setItem('completionViewMode', completionMode);

            // Update UI
            updateCompletionModeUI();

            // Re-render transactions
            renderTransactions();

            console.log(`‚úÖ [COMPLETION] Switched to ${completionMode} mode`);
        }

        function updateCompletionModeUI() {
            const incompleteIcon = document.getElementById('incompleteModeIcon');
            const completeIcon = document.getElementById('completeModeIcon');
            const completeHeader = document.getElementById('completeColumnHeader');

            if (completionMode === 'incomplete') {
                incompleteIcon.style.opacity = '1';
                incompleteIcon.style.fontWeight = 'bold';
                completeIcon.style.opacity = '0.4';
                completeIcon.style.fontWeight = 'normal';
            } else {
                incompleteIcon.style.opacity = '0.4';
                incompleteIcon.style.fontWeight = 'normal';
                completeIcon.style.opacity = '1';
                completeIcon.style.fontWeight = 'bold';
            }

            // Always show checkbox column in both modes (users can uncheck in complete mode to move back)
            const checkboxCells = document.querySelectorAll('.complete-checkbox-cell');
            checkboxCells.forEach(cell => {
                cell.style.display = 'table-cell';
            });

            if (completeHeader) {
                completeHeader.style.display = 'table-cell';
            }
        }

        function markAsComplete(index) {
            console.log(`üîç [COMPLETION] markAsComplete called with index: ${index}`);

            const transaction = allTransactions[index];

            if (!transaction) {
                console.error(`‚ùå [COMPLETION] Transaction not found at index ${index}`);
                showSimpleToast('‚ùå Error: Transaction not found', 'error');
                return;
            }

            console.log(`üìã [COMPLETION] Transaction before toggle:`, transaction);

            // Toggle completion status
            transaction.completed = !transaction.completed;

            console.log(`‚úÖ [COMPLETION] Transaction ${index} marked as ${transaction.completed ? 'complete' : 'incomplete'}`);

            // Show toast notification
            if (transaction.completed) {
                showSimpleToast('‚úÖ Item marked as complete', 'success');
            } else {
                showSimpleToast('üîÑ Item marked as incomplete', 'info');
            }

            // Save to storage
            saveTransactionsToStorage();

            // Re-render with smooth fade out when moving between modes
            const shouldFadeOut =
                (transaction.completed && completionMode === 'incomplete') ||
                (!transaction.completed && completionMode === 'complete');

            if (shouldFadeOut) {
                const row = document.querySelector(`tr[data-row-index="${index}"]`);
                if (row) {
                    row.style.transition = 'opacity 0.3s ease-out';
                    row.style.opacity = '0';
                    setTimeout(() => {
                        renderTransactions();
                    }, 300);
                } else {
                    renderTransactions();
                }
            } else {
                renderTransactions();
            }
        }

        // Action button handlers
        function handleManualEdit(index) {
            const transaction = allTransactions[index];
            currentEditingIndex = index;

            // Find the detail cell for this row (not description - that's from bank CSV)
            const row = document.querySelector(`tr[data-row-index="${index}"]`);
            if (!row) return;

            const detailCell = row.querySelector('.detail-cell');
            if (!detailCell) return;

            // Create inline input box - read from detail field (or legacy manualDescription)
            const currentValue = transaction.detail || transaction.manualDescription || '';
            detailCell.innerHTML = `
                <div style="display: flex; align-items: center; gap: 4px;">
                    <input type="text"
                           id="inline-edit-${index}"
                           value="${escapeHtml(currentValue)}"
                           placeholder="Add Expense Detail..."
                           style="flex: 1; padding: 4px 6px; border: 2px solid #3b82f6; border-radius: 4px; font-size: 11px; outline: none; background: #eff6ff;"
                           onkeydown="handleInlineEditKeydown(event, ${index})"
                           onblur="cancelInlineEdit(${index})">
                    <span style="font-size: 9px; color: #94a3b8;">Press Enter ‚Üµ</span>
                </div>
            `;

            // Focus the input
            setTimeout(() => {
                const input = document.getElementById(`inline-edit-${index}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        // Handle keyboard input in inline editor
        function handleInlineEditKeydown(event, index) {
            if (event.key === 'Enter') {
                event.preventDefault();
                saveInlineEdit(index);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelInlineEdit(index);
            }
        }

        // Save inline edit
        async function saveInlineEdit(index) {
            const input = document.getElementById(`inline-edit-${index}`);
            if (!input) return;

            const newValue = input.value.trim();

            // Save to transaction detail field
            allTransactions[index].detail = newValue;

            // Save to storage
            await saveTransactionsToStorage();

            // Re-render to show the detail
            renderTransactions();

            // Show success toast
            if (newValue) {
                showSimpleToast('‚úÖ Expense Detail saved', 'success');
            } else {
                showSimpleToast('‚úÖ Expense Detail cleared', 'success');
            }

            currentEditingIndex = null;
        }

        // Cancel inline edit
        function cancelInlineEdit(index) {
            // Just re-render to restore original state
            setTimeout(() => {
                // Check if we're still in edit mode (not saved)
                const input = document.getElementById(`inline-edit-${index}`);
                if (input) {
                    renderTransactions();
                    currentEditingIndex = null;
                }
            }, 200); // Delay to allow click on other elements
        }

        // Toggle flag on transaction
        async function toggleFlag(index) {
            const transaction = allTransactions[index];

            // Cycle through three states: null ‚Üí 'red' ‚Üí 'blue' ‚Üí null
            if (!transaction.flagged || transaction.flagged === null) {
                // No flag ‚Üí Red flag
                transaction.flagged = 'red';
                showToast({
                    icon: 'üö©',
                    title: 'Red Flag',
                    message: 'Transaction flagged for attention',
                    bgColor: '#ef4444'
                });
                console.log('üö© [FLAG] Red flag added:', index);
            } else if (transaction.flagged === 'red') {
                // Red flag ‚Üí Blue flag
                transaction.flagged = 'blue';
                showToast({
                    icon: 'üîµ',
                    title: 'Blue Flag',
                    message: 'Transaction marked with blue flag',
                    bgColor: '#3b82f6'
                });
                console.log('üîµ [FLAG] Blue flag added:', index);
            } else if (transaction.flagged === 'blue') {
                // Blue flag ‚Üí No flag
                transaction.flagged = null;
                showToast({
                    icon: '‚úÖ',
                    title: 'Flag Removed',
                    message: 'Transaction flag removed',
                    bgColor: '#10b981'
                });
                console.log('‚úÖ [FLAG] Flag removed:', index);
            } else {
                // Handle legacy boolean true values ‚Üí convert to red
                transaction.flagged = 'red';
                showToast({
                    icon: 'üö©',
                    title: 'Red Flag',
                    message: 'Transaction flagged for attention',
                    bgColor: '#ef4444'
                });
                console.log('üö© [FLAG] Legacy flag converted to red:', index);
            }

            // Save to storage
            await saveTransactionsToStorage();

            // Re-render to show flag state
            renderTransactions();
        }

        // Toggle 0% VAT (set ex-VAT amount equal to with-VAT amount)
        async function toggleZeroVAT(index) {
            const transaction = allTransactions[index];

            if (transaction.zeroVAT) {
                // Revert to original VAT calculation
                if (transaction.originalSpentExVAT !== undefined) {
                    transaction.spent_ex_vat = transaction.originalSpentExVAT;
                    delete transaction.originalSpentExVAT;
                }
                transaction.zeroVAT = false;

                showToast({
                    icon: '‚úÖ',
                    title: 'VAT Restored',
                    message: 'Reverted to original VAT calculation',
                    bgColor: '#10b981'
                });
                console.log('‚úÖ [VAT] Reverted to original VAT:', index);
            } else {
                // Store original ex-VAT value if we're modifying it
                if (!transaction.originalSpentExVAT && transaction.spent_ex_vat) {
                    transaction.originalSpentExVAT = transaction.spent_ex_vat;
                }

                // Set ex-VAT amount equal to with-VAT amount (0% VAT)
                const spentAmount = transaction.spent || '0';
                const spentStr = spentAmount.toString().replace(/¬£/g, '').replace(/,/g, '').trim();
                transaction.spent_ex_vat = spentStr;
                transaction.zeroVAT = true;

                showToast({
                    icon: 'üí∞',
                    title: '0% VAT Applied',
                    message: 'Ex-VAT amount set to match with-VAT amount',
                    bgColor: '#f59e0b'
                });
                console.log('üí∞ [VAT] Applied 0% VAT:', index, 'Amount:', transaction.spent_ex_vat);
            }

            // Save to storage
            await saveTransactionsToStorage();

            // Re-render to show updated amounts
            renderTransactions();
        }

        // Convert transaction currency (GBP <-> USD)
        async function convertTransactionCurrency(index) {
            console.log('üí± [CURRENCY] Button clicked for index:', index);

            const transaction = allTransactions[index];
            const btn = document.getElementById(`currencyBtn${index}`);

            // If already converted, revert back to GBP
            if (transaction.convertedCurrency) {
                console.log('üí± [CURRENCY] Reverting transaction back to GBP:', index);

                // Remove conversion data
                delete transaction.convertedCurrency;
                delete transaction.convertedAmount;
                delete transaction.conversionRate;
                delete transaction.conversionDate;

                // Save and re-render
                await saveTransactionsToStorage();
                renderTransactions();

                showToast({
                    icon: '‚úÖ',
                    title: 'Reverted to GBP',
                    message: 'Transaction amount restored to GBP',
                    bgColor: '#10b981'
                });
                return;
            }

            // Convert GBP to USD
            try {
                // Get the transaction date and amount - strip ¬£ symbol and commas
                const transactionDate = parseTransactionDate(transaction.date);
                const amountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, '').trim();
                const gbpAmount = parseFloat(amountStr);

                console.log('üí± [CURRENCY] Amount parsing:', {
                    original: transaction.spent || transaction.received,
                    cleaned: amountStr,
                    parsed: gbpAmount
                });

                if (isNaN(gbpAmount) || gbpAmount === 0) {
                    showToast({
                        icon: '‚ùå',
                        title: 'Invalid Amount',
                        message: 'Could not parse transaction amount',
                        bgColor: '#ef4444'
                    });
                    return;
                }

                console.log(`üí± [CURRENCY] Converting GBP ${gbpAmount.toFixed(2)} to USD for transaction on ${transactionDate.toLocaleDateString()}`);

                // Get exchange rate (GBP to USD)
                const exchangeRate = await getExchangeRate('GBP', 'USD', transactionDate);
                const usdAmount = gbpAmount * exchangeRate;

                // Store conversion data on transaction
                transaction.convertedCurrency = 'USD';
                transaction.convertedAmount = usdAmount;
                transaction.conversionRate = exchangeRate;
                transaction.conversionDate = transactionDate.toLocaleDateString('en-GB');

                console.log(`‚úÖ [CURRENCY] Converted: GBP ¬£${gbpAmount.toFixed(2)} ‚Üí USD $${usdAmount.toFixed(2)} @ ${exchangeRate.toFixed(4)}`);

                // Save and re-render
                await saveTransactionsToStorage();
                renderTransactions();

                showToast({
                    icon: '‚úÖ',
                    title: 'Converted to USD',
                    message: `GBP ¬£${gbpAmount.toFixed(2)} ‚Üí USD $${usdAmount.toFixed(2)} @ ${exchangeRate.toFixed(4)}`,
                    bgColor: '#10b981'
                });

            } catch (error) {
                console.error('‚ùå [CURRENCY] Conversion failed:', error);
                showToast({
                    icon: '‚ùå',
                    title: 'Conversion Failed',
                    message: error.message || 'Could not convert currency',
                    bgColor: '#ef4444'
                });
            }
        }

        function closeEditModal() {
            document.getElementById('editDescriptionModal').classList.remove('active');
            currentEditingIndex = null;
            document.getElementById('modalManualDescription').value = '';
            document.getElementById('modalVoiceNotes').value = '';
        }

        function saveManualDescription() {
            if (currentEditingIndex === null) return;

            const manualDescription = document.getElementById('modalManualDescription').value.trim();
            const voiceNotes = document.getElementById('modalVoiceNotes').value.trim();

            // Save manual description to the detail field (not description - that's from bank CSV)
            allTransactions[currentEditingIndex].detail = manualDescription;
            allTransactions[currentEditingIndex].voiceNotes = voiceNotes;

            // Re-render the table to show changes
            renderTransactions();

            // Close modal
            closeEditModal();

            // Show success feedback
            showSimpleToast('‚úÖ Transaction updated successfully!', 'success');
        }

        // Close modal when clicking outside
        document.getElementById('editDescriptionModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditModal();
            }
        });

        function handleApplyRule(index) {
            const transaction = allTransactions[index];
            alert(`Apply Rule: ${transaction.description}\n\nThis feature will allow you to apply automated categorization rules.`);
        }

        /**
         * Calculate total claimed costs for a category (sum of all quarterly costs)
         */
        function getCategoryClaimed(category) {
            let total = 0;
            const items = category.items || category.staff || category.contractors || category.trips || [];

            items.forEach(item => {
                if (item.quarterlyCosts) {
                    total += (item.quarterlyCosts.q1 || 0) + (item.quarterlyCosts.q2 || 0) +
                             (item.quarterlyCosts.q3 || 0) + (item.quarterlyCosts.q4 || 0);
                }
            });

            return total;
        }

        /**
         * Calculate claimed costs for a specific item
         */
        function getItemClaimed(item) {
            if (!item.quarterlyCosts) return 0;
            return (item.quarterlyCosts.q1 || 0) + (item.quarterlyCosts.q2 || 0) +
                   (item.quarterlyCosts.q3 || 0) + (item.quarterlyCosts.q4 || 0);
        }

        /**
         * STEP 1: Show project selection
         */
        function showProjectSelection() {
            console.log('üìã [MODAL DEBUG] showProjectSelection called');
            console.log('üìã [MODAL DEBUG] currentEditingIndex:', currentEditingIndex);
            console.log('üìã [MODAL DEBUG] allTransactions.length:', allTransactions.length);

            assignmentStep = 1;
            selectedProject = null;
            selectedCategoryName = null;
            selectedCategory = null;

            const transaction = allTransactions[currentEditingIndex];
            console.log('üìã [MODAL DEBUG] Transaction:', transaction);

            // Initialize newSplitPercentage based on remaining allocation
            if (transaction.assignments && transaction.assignments.length > 0) {
                const totalPercentage = transaction.assignments.reduce((sum, a) => sum + (a.percentage || 0), 0);
                newSplitPercentage = Math.max(0, 100 - totalPercentage);
            } else {
                newSplitPercentage = 100;
            }
            console.log(`üìä [MODAL DEBUG] Initialized newSplitPercentage to ${newSplitPercentage}%`);

            let content = `
                <div style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 11px; color: #666;">Transaction</div>
                        <div style="font-size: 12px; font-weight: 600;">${escapeHtml(transaction.description)}</div>
                        <div style="font-size: 10px; color: #888;">${transaction.date} ‚Ä¢ ¬£${transaction.spent || transaction.received}</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.75); color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px;">
                        ‚å®Ô∏è Press 1-9 to select ‚Ä¢ ‚Üë‚Üì Navigate ‚Ä¢ ‚Üê Back ‚Ä¢ Enter to confirm
                    </div>
                </div>
            `;

            // Check if transaction has existing assignments - show split assignment editor
            if (transaction.assignments && transaction.assignments.length > 0) {
                const totalPercentage = transaction.assignments.reduce((sum, a) => sum + (a.percentage || 0), 0);
                const percentageColor = totalPercentage === 100 ? '#10b981' : totalPercentage > 100 ? '#ef4444' : '#f59e0b';

                content += `
                    <div style="margin-bottom: 12px; padding: 10px; background: #dbeafe; border: 1px solid #3b82f6; border-radius: 4px;">
                        <div style="font-size: 12px; color: #1e40af; margin-bottom: 8px; font-weight: 600; display: flex; justify-content: space-between; align-items: center;">
                            <span>Current Split Assignments</span>
                            <span style="background: ${percentageColor}; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px;">Total: ${totalPercentage}%</span>
                        </div>
                `;

                transaction.assignments.forEach((assignment, assignIdx) => {
                    const projectName = assignment.projectName || 'Project';
                    const quarter = assignment.quarter ? ` Q${assignment.quarter}` : '';
                    const icon = assignment.icon || 'üìÅ';

                    content += `
                        <div style="margin-bottom: 6px; padding: 6px; background: white; border-radius: 4px; display: flex; align-items: center; gap: 8px; border: 1px solid #e5e7eb;">
                            <span style="font-size: 14px;">${icon}</span>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 10px; font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(assignment.itemName || assignment.category)}
                                </div>
                                <div style="font-size: 9px; color: #666;">
                                    ${escapeHtml(projectName)}${quarter}
                                </div>
                            </div>
                            <input type="number"
                                   value="${assignment.percentage}"
                                   min="0"
                                   max="100"
                                   style="width: 50px; padding: 4px; border: 1px solid #cbd5e1; border-radius: 3px; text-align: center; font-size: 11px;"
                                   onchange="updateAssignmentPercentage(${currentEditingIndex}, ${assignIdx}, this.value)">
                            <span style="font-size: 10px; color: #666;">%</span>
                            <button onclick="removeAssignment(${currentEditingIndex}, ${assignIdx}); event.stopPropagation();"
                                    style="background: #dc2626; color: white; border: none; border-radius: 3px; width: 24px; height: 24px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.15s;"
                                    onmouseover="this.style.background='#b91c1c'"
                                    onmouseout="this.style.background='#dc2626'"
                                    title="Remove assignment">√ó</button>
                        </div>
                    `;
                });

                content += `
                        <button onclick="viewAssignment(${currentEditingIndex})" style="width: 100%; background: #6366f1; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; margin-top: 6px;">
                            View in Grants Page
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 8px; padding: 6px; background: #f1f5f9; border-radius: 4px;">
                        üí° You can edit percentages above or add another split assignment below
                    </div>
                `;

                // Add percentage input for new split assignment
                const remainingPercentage = 100 - totalPercentage;
                content += `
                    <div style="margin-bottom: 12px; padding: 10px; background: #f0fdf4; border: 1px solid #86efac; border-radius: 4px;">
                        <div style="font-size: 12px; color: #166534; margin-bottom: 6px; font-weight: 600;">
                            New Split Percentage
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="number"
                                   id="newSplitPercentageInput"
                                   value="${remainingPercentage > 0 ? remainingPercentage : 0}"
                                   min="0"
                                   max="100"
                                   style="flex: 1; padding: 6px 10px; border: 1px solid #86efac; border-radius: 4px; font-size: 12px; text-align: center;"
                                   oninput="updateNewSplitPercentage(this.value)">
                            <span style="font-size: 12px; color: #166534; font-weight: 600;">%</span>
                            <span style="font-size: 10px; color: #15803d; background: white; padding: 4px 8px; border-radius: 3px; white-space: nowrap;">
                                Remaining: ${remainingPercentage}%
                            </span>
                        </div>
                        <div style="font-size: 10px; color: #15803d; margin-top: 4px;">
                            Enter the percentage to allocate to the next project you select
                        </div>
                    </div>
                `;
            }

            content += `
                <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px; color: #333;">Step 1: Select Project</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            // Add PEBL General Expenses option
            content += `
                <div class="category-option" onclick="selectGeneralExpenses()" style="cursor: pointer; padding: 8px 12px; margin-bottom: 4px; border: 2px solid #f59e0b; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 4px; transition: all 0.2s; display: flex; align-items: center; gap: 10px;">
                    <span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #f59e0b; color: white; border-radius: 4px; font-weight: 700; font-size: 13px;">1</span>
                    <span style="font-size: 16px;">üè¢</span>
                    <div style="flex: 1;">
                        <span style="font-size: 12px; font-weight: 600; color: #92400e;">PEBL General Expenses</span>
                        <span style="font-size: 10px; color: #78350f; margin-left: 8px;">Non-project business expenses</span>
                    </div>
                </div>
                <div style="border-bottom: 1px solid #e5e7eb; margin: 8px 0; padding-bottom: 4px;">
                    <div style="font-size: 10px; color: #6b7280; font-weight: 600;">PROJECT BUDGETS</div>
                </div>
            `;

            activeProjects.forEach((project, idx) => {
                const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;
                const number = idx + 2; // Start from 2 (1 is PEBL General)

                content += `
                    <div class="category-option" onclick="selectProjectStep('${project.projectId}')" style="cursor: pointer; padding: 8px 12px; margin-bottom: 4px; border: 1px solid #e0e0e0; border-radius: 4px; transition: all 0.2s; display: flex; align-items: center; gap: 10px;">
                        <span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px;">${number}</span>
                        <span>üìÅ</span>
                        <span style="font-size: 12px; font-weight: 600; color: #333;">${escapeHtml(projectName)}</span>
                        <span style="font-size: 10px; color: #999; margin-left: auto;">ID: ${project.projectId}</span>
                    </div>
                `;
            });

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;

            console.log('üìã [MODAL DEBUG] Modal content HTML set, length:', content.length);

            // Numbers are already added in HTML generation above
            // addNumbersToOptions(); // Removed to prevent duplication

            console.log('‚úÖ [MODAL DEBUG] showProjectSelection completed successfully');
        }

        /**
         * Add number badges to all category options
         */
        function addNumbersToOptions() {
            const options = document.querySelectorAll('.category-option');
            options.forEach((option, idx) => {
                // Skip if already has a number badge
                if (option.querySelector('[data-number-badge]')) return;

                const number = idx + 1;
                if (number > 9) return; // Only show numbers 1-9

                // Create number badge
                const badge = document.createElement('span');
                badge.setAttribute('data-number-badge', 'true');
                badge.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;';
                badge.textContent = number;

                // Insert at the beginning
                option.insertBefore(badge, option.firstChild);
            });
        }

        /**
         * Handle PEBL General Expenses selection - assigns directly
         */
        async function selectGeneralExpenses() {
            if (currentEditingIndex === null) return;

            const transaction = allTransactions[currentEditingIndex];
            const transAmount = parseAmount(transaction.spent || transaction.received);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Calculate amount using newSplitPercentage
            const amountToAssign = (transAmount * newSplitPercentage) / 100;

            console.log(`üí∞ [ASSIGN GENERAL] Using ${newSplitPercentage}% of ¬£${transAmount} = ¬£${amountToAssign}`);

            // Create new assignment object
            const newAssignment = {
                projectId: 'GENERAL_EXPENSES',
                projectName: 'PEBL General Expenses',
                category: 'PEBL General Expenses',
                itemKey: 'general-expense',
                itemName: 'PEBL General Expenses',
                icon: 'üè¢',
                quarter: null,
                percentage: newSplitPercentage,
                amount: amountToAssign,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] General expense assignment created:', newAssignment);

            // Keep old format for backward compatibility
            transaction.assignedCategory = 'PEBL General Expenses';
            transaction.assignedItem = 'general-expense';
            transaction.assignedItemName = 'PEBL General Expenses';
            transaction.assignedProject = 'GENERAL_EXPENSES';

            // Re-render the table
            renderTransactions();

            // Save to storage
            await saveTransactionsToStorage();

            // Close modal
            closeAssignModal();

            // Show success message
            showSimpleToast(`‚úÖ Assigned to PEBL General Expenses - Saved to local storage`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        /**
         * STEP 2: Show category selection for chosen project
         */
        function showCategorySelection() {
            assignmentStep = 2;

            const project = activeProjects.find(p => p.projectId == selectedProject);
            if (!project) return;

            const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;

            let content = `
                <div style="margin-bottom: 15px;">
                    <button onclick="showProjectSelection()" style="background: none; border: none; color: #3AAFA9; cursor: pointer; font-size: 12px; padding: 0;">
                        ‚Üê Back to Projects
                    </button>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">Selected: <strong>${escapeHtml(projectName)}</strong></div>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #333;">Step 2: Select Category</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            let categoryNumber = 1; // Counter for keyboard shortcuts

            // Materials
            if (project.materials && (project.materials.items?.length > 0 || (project.materials.totalCost && project.materials.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.materials);
                const budget = project.materials.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.materials.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Materials')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üîß Materials</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Capital Usage
            if (project.capitalUsage && (project.capitalUsage.items?.length > 0 || (project.capitalUsage.totalCost && project.capitalUsage.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.capitalUsage);
                const budget = project.capitalUsage.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.capitalUsage.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Capital Usage')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üíº Capital Usage</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Subcontracting
            if (project.subcontracting && (project.subcontracting.contractors?.length > 0 || (project.subcontracting.totalCost && project.subcontracting.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.subcontracting);
                const budget = project.subcontracting.totalCost || 0;
                const remaining = budget - claimed;
                const contractorCount = project.subcontracting.contractors?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Subcontracting')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">ü§ù Subcontracting</span>
                                <span style="font-size: 11px; color: #666;">${contractorCount} contractor${contractorCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Travel
            if (project.travel && (project.travel.trips?.length > 0 || (project.travel.totalCost && project.travel.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.travel);
                const budget = project.travel.totalCost || 0;
                const remaining = budget - claimed;
                const tripCount = project.travel.trips?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Travel')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">‚úàÔ∏è Travel</span>
                                <span style="font-size: 11px; color: #666;">${tripCount} trip${tripCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // Other Costs
            if (project.otherCosts && (project.otherCosts.items?.length > 0 || (project.otherCosts.totalCost && project.otherCosts.totalCost > 0))) {
                const claimed = getCategoryClaimed(project.otherCosts);
                const budget = project.otherCosts.totalCost || 0;
                const remaining = budget - claimed;
                const itemCount = project.otherCosts.items?.length || 0;

                content += `
                    <div class="category-option" onclick="selectCategoryStep('Other Costs')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                        ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Other Costs</span>
                                <span style="font-size: 11px; color: #666;">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
                            </div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${budget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
                categoryNumber++;
            }

            // WELSH GOV CATEGORIES
            if (project.welshGovData?.sections) {
                const sections = project.welshGovData.sections;

                // Capital - Non Standard Costs
                if (sections.capital?.nonStandard?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.capital.nonStandard });
                    const budget = sections.totals?.totalCapitalNonStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Capital Non-Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üèóÔ∏è Capital - Non Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.capital.nonStandard.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Revenue - Non Standard Costs
                if (sections.revenue?.nonStandard?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.revenue.nonStandard });
                    const budget = sections.totals?.totalRevenueNonStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Revenue Non-Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üí∞ Revenue - Non Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.revenue.nonStandard.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Revenue - Standard Costs
                if (sections.revenue?.standardCosts?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.revenue.standardCosts });
                    const budget = sections.totals?.totalRevenueStandard || 0;
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Revenue Standard')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üë• Revenue - Standard</span>
                                    <span style="font-size: 11px; color: #666;">${sections.revenue.standardCosts.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Item Breakdown - Capital
                if (sections.itemBreakdown?.capital?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.itemBreakdown.capital });
                    let budget = 0;
                    sections.itemBreakdown.capital.forEach(item => {
                        budget += parseFloat(item.maxGrantApproved || item.totalCost || 0);
                    });
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Item Breakdown Capital')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Item Breakdown - Capital</span>
                                    <span style="font-size: 11px; color: #666;">${sections.itemBreakdown.capital.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }

                // Item Breakdown - Revenue
                if (sections.itemBreakdown?.revenue?.length > 0) {
                    const claimed = getCategoryClaimed({ items: sections.itemBreakdown.revenue });
                    let budget = 0;
                    sections.itemBreakdown.revenue.forEach(item => {
                        budget += parseFloat(item.maxGrantApproved || item.totalCost || 0);
                    });
                    const remaining = budget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryStep('Item Breakdown Revenue')" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px; display: flex; align-items: center; gap: 10px;">
                            ${categoryNumber <= 9 ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: #3b82f6; color: white; border-radius: 4px; font-weight: 700; font-size: 13px; flex-shrink: 0;">${categoryNumber}</span>` : ''}
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-size: 12px; font-weight: 600; color: #333;">üìã Item Breakdown - Revenue</span>
                                    <span style="font-size: 11px; color: #666;">${sections.itemBreakdown.revenue.length} items</span>
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                    <span>Budget: ¬£${budget.toLocaleString()}</span>
                                    <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                    <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                    categoryNumber++;
                }
            }

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;
        }

        /**
         * STEP 3: Show item selection for chosen category
         */
        function showItemSelection() {
            assignmentStep = 3;

            const project = activeProjects.find(p => p.projectId == selectedProject);
            if (!project) return;

            const category = getCategoryObject(project, selectedCategoryName);
            if (!category) return;

            const projectName = project.projectName || project.projectNumber || `Project #${project.projectId}`;

            let content = `
                <div style="margin-bottom: 15px;">
                    <button onclick="showCategorySelection()" style="background: none; border: none; color: #3AAFA9; cursor: pointer; font-size: 12px; padding: 0;">
                        ‚Üê Back to Categories
                    </button>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">${escapeHtml(projectName)} ‚Ä¢ ${selectedCategoryName}</div>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #333;">Step 3: Select Item</div>
                <div style="max-height: 400px; overflow-y: auto;">
            `;

            // Get items based on category
            let items = [];
            let itemPrefix = '';

            // IUK Categories
            if (selectedCategoryName === 'Materials' && category.items) {
                items = category.items;
                itemPrefix = 'materials';
            } else if (selectedCategoryName === 'Capital Usage' && category.items) {
                items = category.items;
                itemPrefix = 'capitalUsage';
            } else if (selectedCategoryName === 'Subcontracting' && category.contractors) {
                items = category.contractors;
                itemPrefix = 'subcontracting';
            } else if (selectedCategoryName === 'Travel' && category.trips) {
                items = category.trips;
                itemPrefix = 'travel';
            } else if (selectedCategoryName === 'Other Costs' && category.items) {
                items = category.items;
                itemPrefix = 'otherCosts';
            }
            // Welsh Gov Categories
            else if (selectedCategoryName === 'Capital Non-Standard' && category.items) {
                items = category.items;
                itemPrefix = 'capitalNonStandard';
            } else if (selectedCategoryName === 'Revenue Non-Standard' && category.items) {
                items = category.items;
                itemPrefix = 'revenueNonStandard';
            } else if (selectedCategoryName === 'Revenue Standard' && category.items) {
                items = category.items;
                itemPrefix = 'revenueStandard';
            } else if (selectedCategoryName === 'Item Breakdown Capital' && category.items) {
                items = category.items;
                itemPrefix = 'itemBreakdownCapital';
            } else if (selectedCategoryName === 'Item Breakdown Revenue' && category.items) {
                items = category.items;
                itemPrefix = 'itemBreakdownRevenue';
            }

            // If category has items, show them
            if (items && items.length > 0) {
                items.forEach((item, idx) => {
                    const itemKey = `${itemPrefix}-${idx}`;
                    const claimed = getItemClaimed(item);

                    // Get item name and budget
                    let itemName = '';
                    let itemBudget = 0;

                    // IUK Categories
                    if (selectedCategoryName === 'Materials') {
                        itemName = item.item;
                        itemBudget = item.total || 0;
                    } else if (selectedCategoryName === 'Capital Usage') {
                        itemName = item.description;
                        itemBudget = item.netCost || 0;
                    } else if (selectedCategoryName === 'Subcontracting') {
                        itemName = item.name;
                        itemBudget = item.cost || 0;
                    } else if (selectedCategoryName === 'Travel') {
                        itemName = item.purpose;
                        itemBudget = item.total || 0;
                    } else if (selectedCategoryName === 'Other Costs') {
                        itemName = item.description;
                        itemBudget = item.estimatedCost || 0;
                    }
                    // Welsh Gov Categories
                    else if (selectedCategoryName === 'Capital Non-Standard' || selectedCategoryName === 'Revenue Non-Standard') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantValue || item.totalCost || 0;
                    } else if (selectedCategoryName === 'Revenue Standard') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantValue || 0;
                    } else if (selectedCategoryName === 'Item Breakdown Capital' || selectedCategoryName === 'Item Breakdown Revenue') {
                        itemName = `${item.itemCode} - ${item.description}`;
                        itemBudget = item.maxGrantApproved || item.totalCost || 0;
                    }

                    const remaining = itemBudget - claimed;

                    content += `
                        <div class="category-option" onclick="selectCategoryItem('${selectedCategoryName}', '${itemKey}', '${escapeHtml(itemName)}', ${selectedProject})" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 6px;">
                            <div style="font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">${escapeHtml(itemName)}</div>
                            <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                                <span>Budget: ¬£${itemBudget.toLocaleString()}</span>
                                <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                                <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                            </div>
                        </div>
                    `;
                });
            } else {
                // No line items - create a "General" option for category-level assignment
                const claimed = getCategoryClaimed(category);
                const budget = category.totalCost || 0;
                const remaining = budget - claimed;
                const generalItemKey = `${itemPrefix}-general`;
                const generalItemName = `General ${selectedCategoryName}`;

                content += `
                    <div style="padding: 12px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; margin-bottom: 12px;">
                        <p style="font-size: 11px; color: #92400e; margin: 0;">‚ÑπÔ∏è This category has no individual line items. Expenses will be assigned to the category as a whole.</p>
                    </div>
                    <div class="category-option" onclick="selectCategoryItem('${selectedCategoryName}', '${generalItemKey}', '${escapeHtml(generalItemName)}', ${selectedProject})" style="cursor: pointer; padding: 10px; margin-bottom: 8px; border: 2px solid #3b82f6; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-radius: 6px;">
                        <div style="font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">üíº ${escapeHtml(generalItemName)}</div>
                        <div style="font-size: 10px; color: #666; display: flex; gap: 12px;">
                            <span>Budget: ¬£${budget.toLocaleString()}</span>
                            <span>Claimed: ¬£${claimed.toLocaleString()}</span>
                            <span style="color: ${remaining < 0 ? '#dc2626' : '#059669'}; font-weight: 600;">Remaining: ¬£${remaining.toLocaleString()}</span>
                        </div>
                    </div>
                `;
            }

            content += '</div>';
            document.getElementById('assignModalContent').innerHTML = content;
        }

        /**
         * Handle project selection in step 1
         */
        function selectProjectStep(projectId) {
            selectedProject = projectId;
            showCategorySelection();
        }

        /**
         * Handle category selection in step 2
         */
        function selectCategoryStep(categoryName) {
            selectedCategoryName = categoryName;
            showItemSelection();
        }

        /**
         * Main entry point - open assignment modal
         */
        function handleAssign(index) {
            // Use the positioning handler for dropdown behavior
            handleAssignWithPosition(index);
        }

        async function selectCategoryItem(category, itemKey, itemName, projectId) {
            if (currentEditingIndex === null) return;

            const transaction = allTransactions[currentEditingIndex];
            const project = activeProjects.find(p => p.projectId === projectId);

            if (!project) {
                alert('‚ùå Project not found');
                return;
            }

            // Calculate quarter from transaction date
            const quarter = calculateTransactionQuarter(transaction.date, project);

            if (!quarter) {
                alert('‚ö†Ô∏è Cannot calculate quarter. Check project start date or transaction date.');
                return;
            }

            console.log(`üìÖ [ASSIGN] Calculated quarter: Q${quarter}`);

            // Calculate amount to assign using newSplitPercentage - use ex-VAT amount
            const transAmount = getTransactionExVatAmount(transaction);
            const percentage = newSplitPercentage;
            const amountToAssign = (transAmount * percentage) / 100;

            console.log(`üí∞ [ASSIGN] Amount to assign: ¬£${amountToAssign} (${percentage}% of ¬£${transAmount} ex-VAT)`);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Create new assignment object
            const newAssignment = {
                projectId: projectId,
                projectName: project.projectName || project.projectNumber || `Project ${project.projectId}`,
                category: category,
                itemKey: itemKey,
                itemName: itemName,
                quarter: quarter,
                percentage: percentage,
                amount: amountToAssign,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] New assignment created:', newAssignment);

            // Update project quarterly costs in database
            try {
                await updateProjectQuarterlyCosts(project, { category, itemKey, itemName, projectId }, quarter, amountToAssign);
                console.log('‚úÖ [ASSIGN] Project quarterly costs updated');
            } catch (error) {
                console.error('‚ùå [ASSIGN] Failed to update project:', error);
                alert('‚ö†Ô∏è Assignment saved locally but failed to update project budget. Check console for details.');
            }

            // Keep old format for backward compatibility
            transaction.assignedCategory = category;
            transaction.assignedItem = itemKey;
            transaction.assignedItemName = itemName;
            transaction.assignedProject = projectId;

            // Save values for toast message
            const projectName = project.projectName || 'Unknown Project';

            // Re-render the table
            renderTransactions();

            // Update filter dropdown to include newly assigned project
            populateProjectFilter();

            // Save to storage
            await saveTransactionsToStorage();

            // Close modal
            closeAssignModal();

            // Show success message
            showSimpleToast(`‚úÖ Assigned to ${itemName} (${category}) - Q${quarter} - ${projectName} - Saved`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        function closeAssignModal() {
            console.log('‚ùå [MODAL DEBUG] closeAssignModal called');
            console.trace('‚ùå [MODAL DEBUG] Call stack:');

            const modal = document.getElementById('assignCategoryModal');
            const modalContent = modal.querySelector('.modal-content');

            modal.classList.remove('active', 'positioned');
            currentEditingIndex = null;
            selectedCategory = null;
            modalKeyboardIndex = -1;
            keyboardBuffer = '';

            // Reset modal positioning to center
            modalContent.style.position = '';
            modalContent.style.top = '';
            modalContent.style.left = '';
            modalContent.style.width = '';
            modalContent.style.margin = '';
            modalContent.style.maxHeight = '';
            modalContent.style.overflowY = '';
            modalContent.style.opacity = '';
            modalContent.style.transition = '';

            console.log('‚úÖ [MODAL DEBUG] Modal closed');
        }

        /**
         * View assignment in grants page - navigates to grants.html and highlights the transaction
         */
        function viewAssignment(index) {
            const transaction = allTransactions[index];

            if (!transaction || !transaction.assignments || transaction.assignments.length === 0) {
                alert('No assignments found for this transaction');
                return;
            }

            // Get the first assignment (or you could let user choose if multiple)
            const assignment = transaction.assignments[0];

            // Create URL parameters to pass to grants.html
            const params = new URLSearchParams({
                projectId: assignment.projectId,
                category: assignment.category,
                itemKey: assignment.itemKey,
                transactionDate: transaction.date,
                transactionDescription: transaction.description,
                highlightTransaction: 'true'
            });

            // Close the modal
            closeAssignModal();

            // Navigate to grants.html with parameters
            window.location.href = `grants.html?${params.toString()}`;
        }

        /**
         * Save all transactions to IndexedDB
         */
        async function saveTransactionsToStorage() {
            if (!db) {
                await initIndexedDB();
            }

            try {
                console.log('üíæ [SAVE] Saving transactions to storage...');

                // Group transactions by their source CSV file
                const transactionsByFile = {};

                savedCSVFiles.forEach(csvFile => {
                    // Find transactions that belong to this CSV file
                    const fileTransactions = allTransactions.filter(t => {
                        // Match transactions by date, bank, and description (robust matching)
                        return csvFile.transactions.some(ct =>
                            ct.date === t.date &&
                            ct.bank === t.bank &&
                            ct.description === t.description
                        );
                    });

                    if (fileTransactions.length > 0) {
                        transactionsByFile[csvFile.id] = {
                            csvFile: csvFile,
                            transactions: fileTransactions
                        };
                    }
                });

                // Update each CSV file with its transactions
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(CSV_STORE_NAME);

                for (const [id, data] of Object.entries(transactionsByFile)) {
                    const updatedCSVFile = {
                        ...data.csvFile,
                        transactions: data.transactions,
                        lastModified: new Date().toISOString()
                    };

                    await new Promise((resolve, reject) => {
                        const request = objectStore.put(updatedCSVFile);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }

                // Don't reload CSV files - just save changes without triggering toast notifications
                // await loadSavedCSVFiles(); // Refresh the list
                console.log('‚úÖ [SAVE] Transactions saved successfully');

            } catch (error) {
                console.error('‚ùå [SAVE] Failed to save transactions:', error);
            }
        }

        /**
         * Migrate existing assigned transactions to have transaction references
         * This is called automatically on page load to add references to transactions
         * that were assigned before the feature was implemented
         */
        async function migrateExistingTransactionRefs() {
            let migratedCount = 0;
            let alreadyHaveRef = 0;
            let totalAssigned = 0;
            const allRefs = new Set(); // Track all references to check uniqueness
            const duplicates = []; // Track any duplicate references

            allTransactions.forEach(transaction => {
                // Check if transaction is assigned (has assignments array or old format)
                const isAssigned = (transaction.assignments && transaction.assignments.length > 0) || transaction.assignedItemName;

                if (isAssigned) {
                    totalAssigned++;

                    if (!transaction.transactionRef) {
                        // Generate reference for this transaction
                        transaction.transactionRef = generateTransactionRef(transaction, allTransactions);
                        migratedCount++;

                        // Check for duplicates
                        if (allRefs.has(transaction.transactionRef)) {
                            duplicates.push({
                                ref: transaction.transactionRef,
                                date: transaction.date,
                                description: transaction.description?.substring(0, 40)
                            });
                        }
                        allRefs.add(transaction.transactionRef);

                        // Only log first 5 and last one
                        if (migratedCount <= 5 || migratedCount === totalAssigned) {
                            console.log(`  ‚úÖ ${transaction.transactionRef} ‚Üí ${transaction.date} - ${transaction.description?.substring(0, 40)}`);
                        } else if (migratedCount === 6) {
                            console.log(`  ... generating references for ${totalAssigned - 5} more transactions ...`);
                        }
                    } else {
                        alreadyHaveRef++;
                        // Also check existing references for duplicates
                        if (allRefs.has(transaction.transactionRef)) {
                            duplicates.push({
                                ref: transaction.transactionRef,
                                date: transaction.date,
                                description: transaction.description?.substring(0, 40)
                            });
                        }
                        allRefs.add(transaction.transactionRef);
                    }
                }
            });

            console.log('');
            console.log(`üìä SUMMARY:`);
            console.log(`   ‚Ä¢ Total assigned transactions: ${totalAssigned}`);
            console.log(`   ‚Ä¢ Already had references: ${alreadyHaveRef}`);
            console.log(`   ‚Ä¢ Newly generated: ${migratedCount}`);
            console.log(`   ‚Ä¢ Unique references: ${allRefs.size}`);

            // Check uniqueness
            if (duplicates.length > 0) {
                console.log('');
                console.log(`‚ùå DUPLICATE REFERENCES DETECTED (${duplicates.length}):`);
                duplicates.forEach(dup => {
                    console.log(`   ‚ö†Ô∏è ${dup.ref} ‚Üí ${dup.date} - ${dup.description}`);
                });
            } else if (totalAssigned > 0) {
                console.log(`   ‚úÖ All references are unique!`);
            }

            // Save to database if any were migrated
            if (migratedCount > 0) {
                console.log('');
                console.log('üíæ Saving to database...');
                await saveTransactionsToStorage();
                console.log('‚úÖ MIGRATION COMPLETE! Transaction references saved.');
                showSimpleToast(`‚úÖ Generated ${migratedCount} transaction references`, 'success');
            } else {
                console.log('‚úÖ All transactions already have references - no migration needed');
            }
        }

        /**
         * Generate transaction reference number: A + MMDD + sequential counter (01-99)
         * Example: A092301 for the first transaction on September 23
         *
         * @param {Object} transaction - The transaction object
         * @param {Array} allTransactions - All transactions array for counter calculation
         * @returns {string} Transaction reference like "A092301"
         */
        function generateTransactionRef(transaction, allTransactions) {
            // Parse the transaction date to extract month and day
            const dateStr = transaction.date || '';
            let month = '00';
            let day = '00';

            // Try different date formats
            if (dateStr.includes('/')) {
                // DD/MM/YYYY or MM/DD/YYYY format
                const parts = dateStr.split('/');
                if (parts.length >= 2) {
                    // Assume DD/MM/YYYY (UK format used in CSV)
                    day = parts[0].padStart(2, '0');
                    month = parts[1].padStart(2, '0');
                }
            } else if (dateStr.includes('-')) {
                // YYYY-MM-DD or similar
                try {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        month = String(date.getMonth() + 1).padStart(2, '0');
                        day = String(date.getDate()).padStart(2, '0');
                    }
                } catch (e) {
                    console.error('Error parsing date:', e);
                }
            }

            // Find the global index of this transaction in allTransactions
            const globalIndex = allTransactions.indexOf(transaction);

            // Find all transactions on the same date that appear BEFORE or AT this transaction
            // This ensures each transaction gets a unique sequential number based on its position
            let positionInDate = 0;
            for (let i = 0; i <= globalIndex && i < allTransactions.length; i++) {
                if (allTransactions[i].date === transaction.date) {
                    positionInDate++;
                }
            }

            // Sequential counter (1-based, padded to 2 digits, max 99)
            const counter = String(Math.min(positionInDate, 99)).padStart(2, '0');

            // Format: A + MMDD + counter
            const ref = `A${month}${day}${counter}`;

            return ref;
        }

        /**
         * Regenerate all transaction references
         * Clears existing references and generates new ones for all assigned transactions
         */
        async function regenerateTransactionRefs(event) {
            if (event) event.preventDefault();

            if (!confirm('üîÑ Regenerate Transaction References\n\nThis will:\n1. Clear all existing transaction references\n2. Generate new unique references for all assigned transactions\n3. Save to database\n\nContinue?')) {
                return;
            }

            console.log('üîÑ Clearing existing transaction references...');
            let clearedCount = 0;
            allTransactions.forEach(t => {
                if (t.transactionRef) {
                    delete t.transactionRef;
                    clearedCount++;
                }
            });

            console.log(`‚úÖ Cleared ${clearedCount} existing references`);

            // Trigger migration to regenerate all references
            console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìù TRANSACTION REFERENCE REGENERATION');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            await migrateExistingTransactionRefs();
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            showSimpleToast('‚úÖ Transaction references regenerated successfully', 'success');

            // Optionally reload page to refresh display
            // setTimeout(() => location.reload(), 1500);
        }

        async function saveAssignment() {
            if (currentEditingIndex === null) return;

            if (!selectedCategory) {
                alert('‚ö†Ô∏è Please select a budget item first.');
                return;
            }

            const transaction = allTransactions[currentEditingIndex];
            const project = activeProjects.find(p => p.projectId === selectedCategory.projectId);

            if (!project) {
                alert('‚ùå Project not found');
                return;
            }

            // Generate transaction reference if it doesn't exist
            if (!transaction.transactionRef) {
                transaction.transactionRef = generateTransactionRef(transaction, allTransactions);
            }

            // Calculate quarter from transaction date
            const quarter = calculateTransactionQuarter(transaction.date, project);

            if (!quarter) {
                alert('‚ö†Ô∏è Cannot calculate quarter. Check project start date or transaction date.');
                return;
            }

            console.log(`üìÖ [ASSIGN] Calculated quarter: Q${quarter}`);

            // Calculate amount to assign (default 100%) - use ex-VAT amount
            const transAmount = getTransactionExVatAmount(transaction);
            const percentage = 100; // TODO: Add split allocation UI
            const amountToAssign = (transAmount * percentage) / 100;

            console.log(`üí∞ [ASSIGN] Amount to assign: ¬£${amountToAssign} (${percentage}% of ¬£${transAmount} ex-VAT)`);

            // Initialize assignments array if needed
            if (!transaction.assignments) {
                transaction.assignments = [];
            }

            // Create new assignment object
            const newAssignment = {
                projectId: selectedCategory.projectId,
                projectName: project.projectName || project.projectNumber || `Project ${project.projectId}`,
                category: selectedCategory.category,
                itemKey: selectedCategory.itemKey,
                itemName: selectedCategory.itemName,
                quarter: quarter,
                percentage: percentage,
                amount: amountToAssign,
                assignedDate: new Date().toISOString()
            };

            // Add to assignments array
            transaction.assignments.push(newAssignment);

            console.log('‚úÖ [ASSIGN] New assignment created:', newAssignment);

            // Update project quarterly costs in database
            try {
                await updateProjectQuarterlyCosts(project, selectedCategory, quarter, amountToAssign);
                console.log('‚úÖ [ASSIGN] Project quarterly costs updated');
            } catch (error) {
                console.error('‚ùå [ASSIGN] Failed to update project:', error);
                alert('‚ö†Ô∏è Assignment saved locally but failed to update project budget. Check console for details.');
            }

            // Keep old format for backward compatibility
            transaction.assignedCategory = selectedCategory.category;
            transaction.assignedItem = selectedCategory.itemKey;
            transaction.assignedItemName = selectedCategory.itemName;
            transaction.assignedProject = selectedCategory.projectId;

            // Save values for toast message BEFORE closing modal (which nulls selectedCategory)
            const projectName = project.projectName || 'Unknown Project';
            const itemName = selectedCategory.itemName;
            const categoryName = selectedCategory.category;

            // Re-render the table
            renderTransactions();

            // Save transactions to database (including the new transaction reference)
            await saveTransactionsToStorage();

            // Close modal (this will set selectedCategory = null)
            closeAssignModal();

            // Show success message
            showSimpleToast(`‚úÖ Assigned to ${itemName} (${categoryName}) - Q${quarter} - ${projectName}`, 'success');

            // Auto-advance to next row
            advanceToNextRow();
        }

        /**
         * Update project's quarterly costs in IndexedDB
         */
        async function updateProjectQuarterlyCosts(project, selection, quarter, amount) {
            console.log('üîÑ [UPDATE COSTS] Updating quarterly costs...');
            console.log(`   Project: ${project.projectName || project.projectId}`);
            console.log(`   Category: ${selection.category}`);
            console.log(`   Item: ${selection.itemName}`);
            console.log(`   Quarter: Q${quarter}`);
            console.log(`   Amount: ¬£${amount}`);

            // Load fresh copy from DB to avoid conflicts
            if (!db) await initIndexedDB();

            const freshProject = await new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(project.projectId);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            if (!freshProject) {
                throw new Error('Project not found in database');
            }

            // Get category and item
            const category = getCategoryObject(freshProject, selection.category);
            const item = findItemInCategory(category, selection.itemKey);

            if (!item) {
                throw new Error(`Item not found: ${selection.itemKey}`);
            }

            // Initialize quarterlyCosts if it doesn't exist
            if (!item.quarterlyCosts) {
                item.quarterlyCosts = {q1: 0, q2: 0, q3: 0, q4: 0};
                console.log('üìä [UPDATE COSTS] Initialized quarterly costs for item');
            }

            // Add amount to the correct quarter
            const quarterKey = `q${quarter}`;
            const previousAmount = item.quarterlyCosts[quarterKey] || 0;
            item.quarterlyCosts[quarterKey] = previousAmount + amount;

            console.log(`‚úÖ [UPDATE COSTS] ${quarterKey}: ¬£${previousAmount} ‚Üí ¬£${item.quarterlyCosts[quarterKey]}`);

            // Update lastModified
            freshProject.lastModified = new Date().toISOString();

            // Save back to database
            await saveProjectToDB(freshProject);

            // Update in-memory activeProjects array
            const activeIndex = activeProjects.findIndex(p => p.projectId === freshProject.projectId);
            if (activeIndex !== -1) {
                activeProjects[activeIndex] = freshProject;
            }

            console.log('‚úÖ [UPDATE COSTS] Project saved successfully');
        }

        // ========================================
        // QUARTER RECALCULATION SYSTEM
        // ========================================

        /**
         * Recalculate all transaction quarters based on current project start dates
         * This comprehensive function:
         * - Creates backup before making changes
         * - Recalculates quarters for all assigned transactions
         * - Rebuilds project quarterly costs from scratch
         * - Provides detailed progress tracking and logging
         * - Supports rollback if something goes wrong
         */
        async function recalculateAllQuarters() {
            console.log('üîÑ [RECALC] Starting comprehensive quarter recalculation...');

            if (!confirm('üîÑ Recalculate All Quarters\n\nThis will:\n1. Create a backup of your current data\n2. Recalculate quarters for ALL assigned transactions\n3. Rebuild project quarterly costs\n\nYour project start dates must be correctly set in grants.html.\n\nContinue?')) {
                return;
            }

            const startTime = Date.now();
            const changeLog = [];
            let totalProcessed = 0;
            let totalChanged = 0;
            let errors = [];

            try {
                // Step 1: Create backup
                console.log('üíæ [RECALC] Creating backup...');
                await createQuarterBackup();
                showSimpleToast('üíæ Backup created successfully', 'info');

                // Step 2: Load all data
                console.log('üìÇ [RECALC] Loading all transactions and projects...');
                if (!db) await initIndexedDB();

                const csvFiles = await loadAllCSVFilesFromDB();
                const projects = await loadAllProjectsFromDB();

                console.log(`üìä [RECALC] Loaded ${csvFiles.length} CSV files, ${projects.length} projects`);

                // Step 3: Recalculate quarters for each transaction
                console.log('üî¢ [RECALC] Recalculating transaction quarters...');
                let fileIndex = 0;

                for (const csvFile of csvFiles) {
                    fileIndex++;
                    console.log(`üìÑ [RECALC] Processing file ${fileIndex}/${csvFiles.length}: ${csvFile.fileName}`);

                    let fileChanged = false;

                    for (const transaction of csvFile.transactions || []) {
                        if (!transaction.assignments || transaction.assignments.length === 0) {
                            continue;
                        }

                        totalProcessed++;

                        for (const assignment of transaction.assignments) {
                            const project = projects.find(p => p.projectId === assignment.projectId);

                            if (!project) {
                                errors.push(`Project ${assignment.projectId} not found for transaction "${transaction.description}"`);
                                continue;
                            }

                            // Log project details for first few transactions
                            if (totalProcessed === 1) {
                                const startMonth = project.projectStartMonth || project.financeSummary?.projectStartMonth;
                                const startYear = project.projectStartYear || project.financeSummary?.projectStartYear;
                                console.log(`üìä [RECALC] Project: ${project.projectName || assignment.projectName}`);
                                console.log(`   Start Date: ${startMonth}/${startYear}`);
                                console.log(`   Transaction Date: ${transaction.date}`);
                            }

                            // Recalculate quarter
                            const oldQuarter = assignment.quarter;
                            const newQuarter = calculateTransactionQuarter(transaction.date, project);

                            if (!newQuarter) {
                                errors.push(`Cannot calculate quarter for transaction "${transaction.description}" in project "${project.projectName || project.projectId}"`);
                                continue;
                            }

                            if (oldQuarter !== newQuarter) {
                                console.log(`üîÑ [RECALC] "${transaction.description.substring(0, 40)}..." (${transaction.date}): Q${oldQuarter} ‚Üí Q${newQuarter}`);
                                assignment.quarter = newQuarter;
                                fileChanged = true;
                                totalChanged++;

                                changeLog.push({
                                    date: transaction.date,
                                    description: transaction.description.substring(0, 50),
                                    project: project.projectName || `Project ${project.projectId}`,
                                    oldQuarter: oldQuarter,
                                    newQuarter: newQuarter,
                                    amount: `¬£${assignment.amount.toFixed(2)}`
                                });
                            } else {
                                // Log unchanged quarters for debugging
                                if (totalProcessed <= 5) {
                                    console.log(`‚úì [RECALC] "${transaction.description.substring(0, 40)}..." (${transaction.date}): Q${oldQuarter} (no change)`);
                                }
                            }
                        }
                    }

                    // Save updated CSV file if changed
                    if (fileChanged) {
                        await saveCSVFileToDB_Direct(csvFile);
                        console.log(`‚úÖ [RECALC] Saved ${csvFile.fileName} with updated quarters`);
                    }

                    // Update progress
                    if (fileIndex % 5 === 0 || fileIndex === csvFiles.length) {
                        showSimpleToast(`Processing... ${fileIndex}/${csvFiles.length} files`, 'info');
                    }
                }

                // Step 4: Rebuild all project quarterly costs
                console.log('üìä [RECALC] Rebuilding project quarterly costs...');
                showSimpleToast('üìä Rebuilding project costs...', 'info');

                for (const project of projects) {
                    await rebuildProjectQuarterlyCosts(project);
                }

                // Step 5: Reload data to reflect changes
                console.log('üîÑ [RECALC] Reloading data...');
                await loadSavedCSVFiles();
                await loadProjectsFromDB();

                // Show completion summary
                const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                const summary = `‚úÖ Quarter Recalculation Complete!\n\n` +
                    `üìä Processed: ${totalProcessed} transactions\n` +
                    `üîÑ Changed: ${totalChanged} quarters\n` +
                    `‚è±Ô∏è Time: ${duration}s\n` +
                    `${errors.length > 0 ? `\n‚ö†Ô∏è Errors: ${errors.length} (see console)` : ''}`;

                console.log('‚úÖ [RECALC] COMPLETE!');
                console.log(`   Processed: ${totalProcessed} transactions`);
                console.log(`   Changed: ${totalChanged} quarters`);
                console.log(`   Duration: ${duration}s`);

                if (changeLog.length > 0) {
                    console.log('\nüìä [RECALC] CHANGE LOG:');
                    console.table(changeLog);
                }

                if (errors.length > 0) {
                    console.error('‚ö†Ô∏è [RECALC] Errors encountered:', errors);
                }

                // Show detailed summary with next steps
                const detailedSummary = summary +
                    `\n\nüí° Next Steps:\n` +
                    `1. Switch to grants.html tab\n` +
                    `2. Click "üîÑ Sync Spend Data" if needed\n` +
                    `3. Check Q5 (2507-2509) for your transactions`;

                alert(detailedSummary);
                showSimpleToast('‚úÖ Quarter recalculation complete! Check grants.html', 'success');

            } catch (error) {
                console.error('‚ùå [RECALC] Fatal error:', error);
                alert(`‚ùå Recalculation Failed\n\n${error.message}\n\nYour data has been preserved. Check console for details.`);
                showSimpleToast('‚ùå Recalculation failed', 'destructive');
            }
        }

        /**
         * Helper: Load all CSV files directly from IndexedDB
         */
        async function loadAllCSVFilesFromDB() {
            if (!db) await initIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CSV_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CSV_STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Helper: Load all projects directly from IndexedDB
         */
        async function loadAllProjectsFromDB() {
            if (!db) await initIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Helper: Save CSV file directly to IndexedDB
         */
        async function saveCSVFileToDB_Direct(csvFile) {
            if (!db) await initIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CSV_STORE_NAME);
                const request = store.put(csvFile);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Rebuild quarterly costs for a project from scratch
         * This recalculates totals based on actual transaction assignments
         */
        async function rebuildProjectQuarterlyCosts(project) {
            console.log(`üìä [REBUILD] Rebuilding costs for: ${project.projectName || project.projectId}`);

            // Load fresh project from DB
            if (!db) await initIndexedDB();
            const freshProject = await new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(project.projectId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            if (!freshProject) {
                console.error(`‚ùå [REBUILD] Project ${project.projectId} not found`);
                return;
            }

            // Reset all quarterly costs to zero
            const categories = ['labour', 'overheads', 'materials', 'capitalUsage', 'subcontracting', 'travel', 'otherCosts'];

            for (const categoryName of categories) {
                const category = getCategoryObject(freshProject, categoryName);
                if (!category) continue;

                const items = getAllItemsFromCategory(category, categoryName);
                for (const item of items) {
                    // Initialize with all possible quarters (Q1-Q12)
                    item.quarterlyCosts = {q1: 0, q2: 0, q3: 0, q4: 0, q5: 0, q6: 0, q7: 0, q8: 0, q9: 0, q10: 0, q11: 0, q12: 0};
                }
            }

            // Recalculate from transaction assignments
            const csvFiles = await loadAllCSVFilesFromDB();

            for (const csvFile of csvFiles) {
                for (const transaction of csvFile.transactions || []) {
                    if (!transaction.assignments) continue;

                    for (const assignment of transaction.assignments) {
                        if (assignment.projectId !== freshProject.projectId) continue;

                        const category = getCategoryObject(freshProject, assignment.category);
                        const item = findItemInCategory(category, assignment.itemKey);

                        if (item && assignment.quarter) {
                            const quarterKey = `q${assignment.quarter}`;
                            if (!item.quarterlyCosts) {
                                item.quarterlyCosts = {q1: 0, q2: 0, q3: 0, q4: 0, q5: 0, q6: 0, q7: 0, q8: 0, q9: 0, q10: 0, q11: 0, q12: 0};
                            }
                            item.quarterlyCosts[quarterKey] = (item.quarterlyCosts[quarterKey] || 0) + assignment.amount;
                        }
                    }
                }
            }

            // Save updated project
            freshProject.lastModified = new Date().toISOString();
            await saveProjectToDB(freshProject);

            console.log(`‚úÖ [REBUILD] Completed: ${freshProject.projectName || freshProject.projectId}`);
        }

        /**
         * Create backup of current transaction and project data
         */
        async function createQuarterBackup() {
            if (!db) await initIndexedDB();

            const csvFiles = await loadAllCSVFilesFromDB();
            const projects = await loadAllProjectsFromDB();

            const backup = {
                timestamp: new Date().toISOString(),
                csvFiles: csvFiles,
                projects: projects
            };

            // Store backup in IndexedDB
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CSV_STORE_NAME);

                const backupEntry = {
                    id: 'quarter_backup_' + Date.now(),
                    fileName: '__QUARTER_BACKUP__',
                    uploadDate: new Date().toISOString(),
                    backup: backup,
                    transactions: [],
                    transactionCount: 0
                };

                const request = store.put(backupEntry);
                request.onsuccess = () => {
                    console.log('üíæ [BACKUP] Created with ID:', backupEntry.id);
                    resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Restore from most recent backup
         */
        async function restoreFromQuarterBackup() {
            if (!confirm('‚ö†Ô∏è Restore from Backup\n\nThis will restore all transactions and projects to their state before the last recalculation.\n\nContinue?')) {
                return;
            }

            try {
                if (!db) await initIndexedDB();

                // Find most recent backup
                const allFiles = await loadAllCSVFilesFromDB();
                const backups = allFiles.filter(f => f.fileName === '__QUARTER_BACKUP__').sort((a, b) =>
                    new Date(b.uploadDate) - new Date(a.uploadDate)
                );

                if (backups.length === 0) {
                    alert('‚ùå No backup found');
                    return;
                }

                const backup = backups[0].backup;
                console.log('üì• [RESTORE] Restoring backup from:', backup.timestamp);

                // Restore CSV files
                const csvTransaction = db.transaction([CSV_STORE_NAME], 'readwrite');
                const csvStore = csvTransaction.objectStore(CSV_STORE_NAME);

                for (const csvFile of backup.csvFiles) {
                    await new Promise((resolve, reject) => {
                        const request = csvStore.put(csvFile);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }

                // Restore projects
                const projTransaction = db.transaction([STORE_NAME], 'readwrite');
                const projStore = projTransaction.objectStore(STORE_NAME);

                for (const project of backup.projects) {
                    await new Promise((resolve, reject) => {
                        const request = projStore.put(project);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }

                // Reload data
                await loadSavedCSVFiles();
                await loadProjectsFromDB();

                alert(`‚úÖ Restore Complete!\n\nRestored from backup created at:\n${new Date(backup.timestamp).toLocaleString()}`);
                showSimpleToast('‚úÖ Backup restored successfully', 'success');

            } catch (error) {
                console.error('‚ùå [RESTORE] Error:', error);
                alert(`‚ùå Restore Failed\n\n${error.message}`);
            }
        }

        // Close modal when clicking outside
        document.getElementById('assignCategoryModal').addEventListener('click', function(e) {
            console.log('üñ±Ô∏è [MODAL DEBUG] Click on modal overlay detected');
            console.log('üñ±Ô∏è [MODAL DEBUG] e.target:', e.target);
            console.log('üñ±Ô∏è [MODAL DEBUG] this:', this);
            console.log('üñ±Ô∏è [MODAL DEBUG] Are they equal?', e.target === this);

            if (e.target === this) {
                console.log('‚ö†Ô∏è [MODAL DEBUG] Click outside modal content - closing modal');
                closeAssignModal();
            } else {
                console.log('‚úÖ [MODAL DEBUG] Click inside modal content - keeping modal open');
            }
        });

        // ========================================
        // KEYBOARD NAVIGATION
        // ========================================

        /**
         * Select a row for keyboard navigation
         */
        function selectRow(index, event) {
            if (event && event.target.tagName === 'BUTTON') {
                return; // Don't select row when clicking buttons
            }
            selectedRowIndex = index;
            renderTransactions();
        }

        /**
         * Advance to the next unassigned row after successful assignment
         */
        function advanceToNextRow() {
            if (selectedRowIndex === null) return;

            console.log('üìç [NAV] Advancing to next row from index:', selectedRowIndex);

            // Find the next row in the filtered/displayed transactions
            let nextIndex = selectedRowIndex + 1;

            // Wrap around if we're at the end
            if (nextIndex >= allTransactions.length) {
                nextIndex = 0;
            }

            selectedRowIndex = nextIndex;
            renderTransactions();
            scrollRowIntoView(selectedRowIndex);

            console.log('‚úÖ [NAV] Advanced to row:', selectedRowIndex);
        }

        /**
         * Handle keyboard shortcuts for table navigation and assignment
         */
        document.addEventListener('keydown', function(e) {
            // IMPORTANT: Ignore hotkeys when user is typing in input fields
            if (e.target.tagName === 'INPUT' ||
                e.target.tagName === 'TEXTAREA' ||
                e.target.isContentEditable) {
                console.log('‚å®Ô∏è [HOTKEY] Ignoring hotkey - user is typing in input field');
                return; // Let the user type normally without triggering hotkeys
            }

            const modalOpen = document.getElementById('assignCategoryModal').classList.contains('active');
            console.log('‚å®Ô∏è [MODAL DEBUG] Keydown event:', e.key, 'Modal open:', modalOpen);

            // Modal is closed - table navigation
            if (!modalOpen) {
                console.log('‚å®Ô∏è [MODAL DEBUG] Processing key in table navigation mode');
                // Arrow Down - select next row
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (selectedRowIndex === null) {
                        selectedRowIndex = 0;
                    } else if (selectedRowIndex < allTransactions.length - 1) {
                        selectedRowIndex++;
                    }
                    renderTransactions();
                    scrollRowIntoView(selectedRowIndex);
                }
                // Arrow Up - select previous row
                else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (selectedRowIndex === null) {
                        selectedRowIndex = allTransactions.length - 1;
                    } else if (selectedRowIndex > 0) {
                        selectedRowIndex--;
                    }
                    renderTransactions();
                    scrollRowIntoView(selectedRowIndex);
                }
                // '1' key - open assign dialog for selected row
                else if (e.key === '1' && selectedRowIndex !== null) {
                    e.preventDefault();
                    console.log('‚å®Ô∏è [MODAL DEBUG] Opening assign modal for row:', selectedRowIndex);
                    handleAssignWithPosition(selectedRowIndex);
                }
                // 'T' key - Manual text edit for selected row
                else if ((e.key === 't' || e.key === 'T') && selectedRowIndex !== null) {
                    e.preventDefault();
                    console.log('‚å®Ô∏è [SHORTCUT] Opening text editor for row:', selectedRowIndex);
                    handleManualEdit(selectedRowIndex);
                }
                // 'V' key - Voice input for selected row
                else if ((e.key === 'v' || e.key === 'V') && selectedRowIndex !== null) {
                    e.preventDefault();
                    console.log('‚å®Ô∏è [SHORTCUT] Starting voice recording for row:', selectedRowIndex);
                    toggleRowVoiceRecording(selectedRowIndex);
                }
                // 'E' key - Email invoice fetch for selected row
                else if ((e.key === 'e' || e.key === 'E') && selectedRowIndex !== null) {
                    e.preventDefault();
                    console.log('‚å®Ô∏è [SHORTCUT] Opening invoice search for row:', selectedRowIndex);
                    handleInvoiceFetch(selectedRowIndex, e);
                }
            }
            // Modal is open - number-based navigation
            else {
                console.log('‚å®Ô∏è [MODAL DEBUG] Processing key in modal navigation mode');
                // Escape - close modal
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeAssignModal();
                }
                // Number keys (1-9) - direct selection
                else if (e.key >= '1' && e.key <= '9') {
                    e.preventDefault();
                    const optionIndex = parseInt(e.key) - 1;
                    selectModalOptionByIndex(optionIndex);
                }
                // Arrow keys in modal
                else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    handleModalArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);
                }
                // Back arrow - go to previous step
                else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (assignmentStep === 3) {
                        // From item selection back to category selection
                        showCategorySelection();
                    } else if (assignmentStep === 2) {
                        // From category selection back to project selection
                        showProjectSelection();
                    } else if (assignmentStep === 1) {
                        // From project selection, close modal
                        closeAssignModal();
                    }
                }
                // Enter - select highlighted option
                else if (e.key === 'Enter') {
                    e.preventDefault();
                    selectHighlightedModalOption();
                }
            }
        });

        /**
         * Scroll row into view
         */
        function scrollRowIntoView(index) {
            const row = document.querySelector(`tr[data-row-index="${index}"]`);
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Handle assign with dropdown positioning
         */
        function handleAssignWithPosition(index) {
            console.log('üîç [MODAL DEBUG] handleAssignWithPosition called for index:', index);

            const assignBtn = document.getElementById(`assignBtn${index}`);
            if (!assignBtn) {
                console.log('‚ö†Ô∏è [MODAL DEBUG] No assign button found, calling handleAssign directly');
                handleAssign(index);
                return;
            }

            // Get button position
            const rect = assignBtn.getBoundingClientRect();
            const modal = document.getElementById('assignCategoryModal');
            const modalContent = modal.querySelector('.modal-content');

            console.log('‚úÖ [MODAL DEBUG] Opening modal - preparing to position');

            // Hide modal initially to prevent flash
            modalContent.style.opacity = '0';
            modalContent.style.transition = 'none';

            // Position modal as dropdown below the button
            modal.classList.add('active', 'positioned');

            console.log('üîç [MODAL DEBUG] Modal active class added, classList:', modal.classList.toString());

            // Use setTimeout to ensure modal is rendered before positioning
            setTimeout(() => {
                console.log('üìê [MODAL DEBUG] Positioning modal');

                // Calculate available space and modal dimensions
                // NOTE: rect is viewport-relative, and modal-overlay is position:fixed,
                // so we use viewport coordinates (no scrollY/scrollX needed)
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const modalWidth = Math.min(500, viewportWidth - 40);

                // Calculate max height based on available space (with padding)
                const spaceBelow = viewportHeight - rect.bottom - 20;
                const spaceAbove = rect.top - 20;
                const maxModalHeight = Math.min(viewportHeight * 0.7, Math.max(spaceBelow, spaceAbove));

                // Set max height first so we can get accurate offsetHeight
                modalContent.style.maxHeight = maxModalHeight + 'px';
                modalContent.style.overflowY = 'auto';

                // Force layout recalculation
                const modalHeight = modalContent.offsetHeight;

                let top, left;

                // Try to position below the button first
                if (spaceBelow >= modalHeight || spaceBelow >= spaceAbove) {
                    // Position below button (viewport coordinates)
                    top = rect.bottom + 5;

                    // Ensure it doesn't go off bottom of viewport
                    if (top + modalHeight > viewportHeight - 20) {
                        top = viewportHeight - modalHeight - 20;
                    }
                } else {
                    // Position above button (viewport coordinates)
                    top = rect.top - modalHeight - 5;

                    // Ensure it doesn't go off top of viewport
                    if (top < 10) {
                        top = 10;
                    }
                }

                // Position horizontally (align right edge with button)
                left = rect.right - modalWidth;

                // Adjust if modal goes off-screen horizontally
                if (left < 10) left = 10;
                if (left + modalWidth > viewportWidth - 10) {
                    left = viewportWidth - modalWidth - 10;
                }

                modalContent.style.position = 'absolute';
                modalContent.style.top = top + 'px';
                modalContent.style.left = left + 'px';
                modalContent.style.width = modalWidth + 'px';
                modalContent.style.margin = '0';

                // Show modal after positioning
                modalContent.style.opacity = '1';
                modalContent.style.transition = 'opacity 0.15s ease-in-out';

                console.log('‚úÖ [MODAL DEBUG] Modal positioned at:', {
                    top,
                    left,
                    modalHeight,
                    spaceBelow,
                    spaceAbove,
                    buttonRect: { top: rect.top, bottom: rect.bottom, left: rect.left, right: rect.right },
                    viewport: { width: viewportWidth, height: viewportHeight }
                });
            }, 10);

            // Now proceed with normal assignment flow
            currentEditingIndex = index;
            console.log('üîç [MODAL DEBUG] Active projects count:', activeProjects.length);

            if (activeProjects.length === 0) {
                console.log('‚ùå [MODAL DEBUG] No projects loaded, closing modal');
                alert('‚ö†Ô∏è No projects loaded. Please create a budget in the Grants page first.');
                closeAssignModal();
                return;
            }

            console.log('‚úÖ [MODAL DEBUG] Calling showProjectSelection()');
            showProjectSelection();
            modalKeyboardIndex = -1;
            console.log('‚úÖ [MODAL DEBUG] Modal setup complete');
        }

        /**
         * Select modal option by number key (1-9)
         */
        function selectModalOptionByIndex(index) {
            const options = document.querySelectorAll('.category-option');
            if (index >= 0 && index < options.length) {
                options[index].click();
            }
        }

        /**
         * Handle arrow navigation in modal
         */
        function handleModalArrowNavigation(direction) {
            const options = document.querySelectorAll('.category-option');
            if (options.length === 0) return;

            if (modalKeyboardIndex === -1) {
                modalKeyboardIndex = direction > 0 ? 0 : options.length - 1;
            } else {
                modalKeyboardIndex += direction;
                if (modalKeyboardIndex < 0) modalKeyboardIndex = 0;
                if (modalKeyboardIndex >= options.length) modalKeyboardIndex = options.length - 1;
            }

            updateModalHighlight();
            options[modalKeyboardIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        /**
         * Update modal option highlight
         */
        function updateModalHighlight() {
            const options = document.querySelectorAll('.category-option');
            options.forEach((opt, idx) => {
                opt.classList.remove('keyboard-selected');
                if (idx === modalKeyboardIndex) {
                    opt.classList.add('keyboard-selected');
                }
            });
        }

        /**
         * Select highlighted modal option
         */
        function selectHighlightedModalOption() {
            if (modalKeyboardIndex === -1) return;
            const options = document.querySelectorAll('.category-option');
            if (options[modalKeyboardIndex]) {
                options[modalKeyboardIndex].click();
            }
        }

        // ========================================
        // PROJECT UPDATE HELPERS
        // ========================================

        /**
         * Get category object from project by name
         */
        function getCategoryObject(project, categoryName) {
            // IUK Categories
            const categoryMap = {
                'Labour': project.labour,
                'Overheads': project.overheads,
                'Materials': project.materials,
                'Capital Usage': project.capitalUsage,
                'Subcontracting': project.subcontracting,
                'Travel': project.travel,
                'Other Costs': project.otherCosts
            };

            if (categoryMap[categoryName]) {
                return categoryMap[categoryName];
            }

            // Welsh Gov Categories
            if (project.welshGovData?.sections) {
                const sections = project.welshGovData.sections;
                const welshCategoryMap = {
                    'Capital Non-Standard': { items: sections.capital?.nonStandard || [] },
                    'Revenue Non-Standard': { items: sections.revenue?.nonStandard || [] },
                    'Revenue Standard': { items: sections.revenue?.standardCosts || [] },
                    'Item Breakdown Capital': { items: sections.itemBreakdown?.capital || [] },
                    'Item Breakdown Revenue': { items: sections.itemBreakdown?.revenue || [] }
                };

                return welshCategoryMap[categoryName];
            }

            return null;
        }

        /**
         * Find specific item in category by itemKey (e.g., "materials-2")
         */
        function findItemInCategory(category, itemKey) {
            if (!category) return null;

            const [catName, indexStr] = itemKey.split('-');

            // Handle "general" item keys for categories without line items
            if (indexStr === 'general') {
                console.log('üì¶ [FIND ITEM] General category assignment - returning category object');
                return category; // Return the category itself for general assignments
            }

            const index = parseInt(indexStr);

            // IUK categories
            if (catName === 'labour' && category.staff) return category.staff[index];
            if (catName === 'overheads') return category; // Overheads is single object
            if (catName === 'materials' && category.items) return category.items[index];
            if (catName === 'capitalUsage' && category.items) return category.items[index];
            if (catName === 'subcontracting' && category.contractors) return category.contractors[index];
            if (catName === 'travel' && category.trips) return category.trips[index];
            if (catName === 'otherCosts' && category.items) return category.items[index];

            // Welsh Gov categories (all use .items array)
            if (catName === 'capitalNonStandard' && category.items) return category.items[index];
            if (catName === 'revenueNonStandard' && category.items) return category.items[index];
            if (catName === 'revenueStandard' && category.items) return category.items[index];
            if (catName === 'itemBreakdownCapital' && category.items) return category.items[index];
            if (catName === 'itemBreakdownRevenue' && category.items) return category.items[index];

            return null;
        }

        /**
         * Save project back to IndexedDB
         */
        async function saveProjectToDB(project) {
            if (!db) await initIndexedDB();

            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(project);

                request.onsuccess = () => {
                    console.log('‚úÖ [DB] Project saved:', project.projectId);
                    resolve();
                };

                request.onerror = () => {
                    console.error('‚ùå [DB] Error saving project:', request.error);
                    reject(request.error);
                };
            });
        }

        // ========================================
        // UNASSIGNMENT FUNCTIONALITY
        // ========================================

        /**
         * Handle unassignment (right-click on assign button)
         */
        /**
         * Update the percentage of a specific assignment in a split transaction
         */
        async function updateAssignmentPercentage(transactionIndex, assignmentIndex, newPercentage) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.assignments || assignmentIndex >= transaction.assignments.length) {
                showSimpleToast('‚ö†Ô∏è Assignment not found', 'error');
                return;
            }

            const assignment = transaction.assignments[assignmentIndex];
            const oldPercentage = assignment.percentage;
            const newPercentageNum = parseFloat(newPercentage);

            if (isNaN(newPercentageNum) || newPercentageNum < 0 || newPercentageNum > 100) {
                showSimpleToast('‚ö†Ô∏è Percentage must be between 0 and 100', 'error');
                // Re-render to reset the input
                showProjectSelection();
                return;
            }

            console.log(`üìä [UPDATE %] Changing assignment ${assignmentIndex} from ${oldPercentage}% to ${newPercentageNum}%`);

            // Calculate old and new amounts - use ex-VAT amount
            const transAmount = getTransactionExVatAmount(transaction);
            const oldAmount = (transAmount * oldPercentage) / 100;
            const newAmount = (transAmount * newPercentageNum) / 100;
            const amountDiff = newAmount - oldAmount;

            // Update the assignment
            assignment.percentage = newPercentageNum;
            assignment.amount = newAmount;

            // Update project quarterly costs
            try {
                const project = activeProjects.find(p => p.projectId === assignment.projectId);
                if (project) {
                    // Adjust the project cost by the difference
                    await updateProjectQuarterlyCosts(
                        project,
                        { category: assignment.category, itemKey: assignment.itemKey, itemName: assignment.itemName, projectId: assignment.projectId },
                        assignment.quarter,
                        amountDiff
                    );
                    console.log(`‚úÖ [UPDATE %] Project costs adjusted by ¬£${amountDiff.toFixed(2)}`);
                }
            } catch (error) {
                console.error('‚ùå [UPDATE %] Failed to update project:', error);
                showSimpleToast('‚ö†Ô∏è Percentage updated locally but failed to sync with project', 'warning');
            }

            // Save and re-render
            await saveTransactionsToStorage();
            showProjectSelection(); // Refresh the modal view
            renderTransactions(); // Refresh the main table
            showSimpleToast(`‚úÖ Percentage updated to ${newPercentageNum}%`, 'success');
        }

        /**
         * Update the percentage for the new split assignment being added
         */
        function updateNewSplitPercentage(value) {
            const percentage = parseFloat(value);
            if (isNaN(percentage) || percentage < 0 || percentage > 100) {
                newSplitPercentage = 0;
            } else {
                newSplitPercentage = percentage;
            }
            console.log(`üìä [NEW SPLIT %] Set to ${newSplitPercentage}%`);
        }

        /**
         * Remove a specific assignment from a split transaction
         */
        async function removeAssignment(transactionIndex, assignmentIndex) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.assignments || assignmentIndex >= transaction.assignments.length) {
                showSimpleToast('‚ö†Ô∏è Assignment not found', 'error');
                return;
            }

            const assignment = transaction.assignments[assignmentIndex];

            console.log(`üóëÔ∏è [REMOVE] Removing assignment ${assignmentIndex}:`, assignment);

            // Remove from project costs
            await removeAssignmentFromProject(transaction, assignment);

            // Remove from array
            transaction.assignments.splice(assignmentIndex, 1);

            // Save and re-render
            await saveTransactionsToStorage();
            showProjectSelection(); // Refresh the modal view
            renderTransactions(); // Refresh the main table
        }

        async function handleUnassign(transactionIndex, assignmentIndex = null) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.assignments || transaction.assignments.length === 0) {
                if (!transaction.assignedItemName) {
                    return;
                }

                // Old format - remove directly without confirmation
                delete transaction.assignedCategory;
                delete transaction.assignedItem;
                delete transaction.assignedItemName;
                delete transaction.assignedProject;

                renderTransactions();
                await saveTransactionsToStorage();
                return;
            }

            // If specific assignment index provided, remove that one directly
            if (assignmentIndex !== null && assignmentIndex >= 0 && assignmentIndex < transaction.assignments.length) {
                const assignment = transaction.assignments[assignmentIndex];
                await removeAssignmentFromProject(transaction, assignment);
                transaction.assignments.splice(assignmentIndex, 1);
                renderTransactions();
                await saveTransactionsToStorage();
                return;
            }

            // Fallback for old behavior (no assignment index provided)
            // New format - remove first assignment if only one exists
            if (transaction.assignments.length === 1) {
                await removeAssignmentFromProject(transaction, transaction.assignments[0]);
                transaction.assignments = [];
                renderTransactions();
                await saveTransactionsToStorage();
            } else {
                // Multiple assignments - remove the first one (fallback behavior)
                await removeAssignmentFromProject(transaction, transaction.assignments[0]);
                transaction.assignments.splice(0, 1);
                renderTransactions();
                await saveTransactionsToStorage();
            }
        }

        /**
         * Remove assignment cost from project's quarterly costs
         */
        async function removeAssignmentFromProject(transaction, assignment) {
            console.log('üîÑ [UNASSIGN] Removing assignment from project:', assignment);

            try {
                // Load project from DB
                if (!db) await initIndexedDB();

                const project = await new Promise((resolve, reject) => {
                    const trans = db.transaction([STORE_NAME], 'readonly');
                    const store = trans.objectStore(STORE_NAME);
                    const request = store.get(assignment.projectId);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (!project) {
                    console.error('‚ùå [UNASSIGN] Project not found:', assignment.projectId);
                    return;
                }

                // Calculate amount to subtract
                const transAmount = parseAmount(transaction.spent || transaction.received);
                const amountToRemove = (transAmount * assignment.percentage) / 100;

                console.log(`üí∞ [UNASSIGN] Removing ¬£${amountToRemove} from ${assignment.category} - ${assignment.itemName} Q${assignment.quarter}`);

                // Find the item and update quarterly costs
                const category = getCategoryObject(project, assignment.category);
                const item = findItemInCategory(category, assignment.itemKey);

                if (item && item.quarterlyCosts) {
                    const quarterKey = `q${assignment.quarter}`;
                    item.quarterlyCosts[quarterKey] = (item.quarterlyCosts[quarterKey] || 0) - amountToRemove;

                    console.log(`‚úÖ [UNASSIGN] Updated ${quarterKey}:`, item.quarterlyCosts);

                    // Save project back to DB
                    project.lastModified = new Date().toISOString();
                    await saveProjectToDB(project);
                    console.log('‚úÖ [UNASSIGN] Project saved');
                }

            } catch (error) {
                console.error('‚ùå [UNASSIGN] Error removing assignment:', error);
            }
        }

        // ========================================
        // VOICE RECORDING FUNCTIONALITY
        // ========================================

        // Simple toast notification function (for voice recording and other simple messages)
        function showSimpleToast(message, type = 'info', position = null) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show';
            if (type) toast.classList.add(type);

            // Position toast near the button if coordinates provided
            if (position && position.x !== undefined && position.y !== undefined) {
                // Position toast near the click, offset slightly to the right and down
                const offsetX = 10;
                const offsetY = 10;

                // Calculate position, ensuring it stays within viewport
                let left = position.x + offsetX;
                let top = position.y + offsetY;

                // Adjust if toast would go off-screen (estimate toast width as 400px)
                if (left + 400 > window.innerWidth) {
                    left = position.x - 400 - offsetX; // Position to the left instead
                }
                if (top + 100 > window.innerHeight) {
                    top = position.y - 100 - offsetY; // Position above instead
                }

                // Ensure minimum margins
                left = Math.max(10, Math.min(left, window.innerWidth - 410));
                top = Math.max(10, Math.min(top, window.innerHeight - 110));

                toast.style.left = left + 'px';
                toast.style.top = top + 'px';
                toast.style.bottom = 'auto';
                toast.style.right = 'auto';
                toast.classList.add('positioned');
            } else {
                // Default position (bottom right)
                toast.style.left = '';
                toast.style.top = '';
                toast.style.bottom = '';
                toast.style.right = '';
                toast.classList.remove('positioned');
            }

            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        // Toggle voice recording for specific row
        async function toggleRowVoiceRecording(rowIndex) {
            if (isRecording && currentRecordingRowIndex === rowIndex) {
                stopRecording();
            } else {
                await startRowRecording(rowIndex);
            }
        }

        // Start recording for specific row
        async function startRowRecording(rowIndex) {
            // If already recording another row, stop it first
            if (isRecording) {
                stopRecording();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const micBtn = document.getElementById(`micBtn${rowIndex}`);
            if (!micBtn) return;

            try {
                // Reuse existing stream or create new one (permission requested only once)
                if (!microphoneStream) {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                const stream = microphoneStream;

                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                currentRecordingRowIndex = rowIndex;

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    // Keep stream alive - don't stop tracks
                    // stream.getTracks().forEach(track => track.stop());

                    micBtn.classList.remove('recording');
                    micBtn.textContent = 'üé§';

                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        await transcribeAudio(audioBlob);
                    } else {
                        currentRecordingRowIndex = null;
                    }
                };

                mediaRecorder.start();
                isRecording = true;

                micBtn.classList.add('recording');
                micBtn.textContent = '‚èπÔ∏è';

                showSimpleToast('üé§ Recording... Click again to stop', 'info');

                // Auto-stop after MAX_RECORDING_TIME
                recordingTimeout = setTimeout(() => {
                    if (isRecording) {
                        showSimpleToast('‚è±Ô∏è Max recording time reached (30s)', 'info');
                        stopRecording();
                    }
                }, MAX_RECORDING_TIME);

            } catch (error) {
                console.error('Microphone error:', error);
                showSimpleToast('‚ùå Microphone access denied. Please allow microphone access.', 'error');
                micBtn.classList.remove('recording');
                micBtn.textContent = 'üé§';
                currentRecordingRowIndex = null;
            }
        }

        // Stop recording
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                clearTimeout(recordingTimeout);
                mediaRecorder.stop();
                isRecording = false;
            }
        }

        // Transcribe audio using Whisper API
        async function transcribeAudio(audioBlob) {
            if (currentRecordingRowIndex === null) {
                showSimpleToast('‚ùå No row selected for voice note', 'error');
                return;
            }

            const micBtn = document.getElementById(`micBtn${currentRecordingRowIndex}`);
            if (!micBtn) return;

            // Check for API key
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                showSimpleToast('‚ùå OpenAI API Key required for voice transcription', 'error');
                micBtn.classList.remove('processing');
                micBtn.disabled = false;
                micBtn.textContent = 'üé§';
                currentRecordingRowIndex = null;
                return;
            }

            micBtn.classList.add('processing');
            micBtn.disabled = true;
            micBtn.textContent = '‚è≥';

            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');

                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Transcription failed: ${response.status}`);
                }

                const data = await response.json();
                const transcription = data.text;

                console.log('Transcription:', transcription);

                if (!transcription || transcription.trim().length === 0) {
                    showSimpleToast('‚ùå Could not understand audio. Please try again.', 'error');
                    micBtn.classList.remove('processing');
                    micBtn.disabled = false;
                    micBtn.textContent = 'üé§';
                    currentRecordingRowIndex = null;
                    return;
                }

                // Show transcription modal for review
                document.getElementById('transcriptionText').value = transcription;
                document.getElementById('transcriptionModal').classList.add('show');

            } catch (error) {
                console.error('Transcription error:', error);
                showSimpleToast('‚ùå Transcription failed. Please try again.', 'error');
                currentRecordingRowIndex = null;
            } finally {
                micBtn.classList.remove('processing');
                micBtn.disabled = false;
                micBtn.textContent = 'üé§';
            }
        }

        // Close transcription modal
        function closeTranscriptionModal() {
            document.getElementById('transcriptionModal').classList.remove('show');
            document.getElementById('transcriptionText').value = '';
            currentRecordingRowIndex = null; // Reset recording row
        }

        // Process transcription and save as voice note
        async function processTranscription() {
            const transcription = document.getElementById('transcriptionText').value.trim();

            if (!transcription) {
                showSimpleToast('‚ùå No transcription to process', 'error');
                return;
            }

            if (currentRecordingRowIndex === null) {
                showSimpleToast('‚ùå No row selected for voice note', 'error');
                closeTranscriptionModal();
                return;
            }

            // Save the transcription to the Detail column
            const rowIndex = currentRecordingRowIndex;
            allTransactions[rowIndex].detail = transcription;

            // Re-render to show the detail
            renderTransactions();
            updateSummary();

            showSimpleToast(`‚úÖ Voice note added to Detail column`, 'success');

            closeTranscriptionModal();
        }

        // ========================================
        // TEXT POPUP FOR LONG DESCRIPTIONS/DETAILS
        // ========================================

        let currentTextPopupField = null;
        let currentTextPopupRowIndex = null;

        function showTextPopup(fieldName, rowIndex) {
            const transaction = allTransactions[rowIndex];
            if (!transaction) return;

            // Store current editing context
            currentTextPopupField = fieldName;
            currentTextPopupRowIndex = rowIndex;

            const modal = document.getElementById('textPopupModal');
            const title = document.getElementById('textPopupTitle');
            const content = document.getElementById('textPopupContent');
            const editBox = document.getElementById('textPopupEdit');

            // Get the appropriate text based on field name
            let text = '';
            if (fieldName === 'description') {
                text = transaction.description || '';
                title.textContent = 'Full Description';
            } else if (fieldName === 'detail') {
                text = transaction.detail || transaction.manualDescription || '';
                title.textContent = 'Full Detail';
            }

            content.textContent = text;
            editBox.value = text;

            // Reset to view mode
            content.style.display = 'block';
            editBox.style.display = 'none';
            document.getElementById('textPopupCloseBtn').style.display = 'inline-block';
            document.getElementById('textPopupEditBtn').style.display = 'inline-block';
            document.getElementById('textPopupSaveBtn').style.display = 'none';
            document.getElementById('textPopupCancelBtn').style.display = 'none';

            modal.style.display = 'flex';
        }

        function enableTextPopupEdit() {
            const content = document.getElementById('textPopupContent');
            const editBox = document.getElementById('textPopupEdit');

            // Switch to edit mode
            content.style.display = 'none';
            editBox.style.display = 'block';
            editBox.focus();

            // Update buttons
            document.getElementById('textPopupCloseBtn').style.display = 'none';
            document.getElementById('textPopupEditBtn').style.display = 'none';
            document.getElementById('textPopupSaveBtn').style.display = 'inline-block';
            document.getElementById('textPopupCancelBtn').style.display = 'inline-block';
        }

        async function saveTextPopupEdit() {
            const editBox = document.getElementById('textPopupEdit');
            const newText = editBox.value.trim();

            if (currentTextPopupRowIndex === null || !currentTextPopupField) return;

            // Update transaction
            if (currentTextPopupField === 'description') {
                allTransactions[currentTextPopupRowIndex].description = newText;
            } else if (currentTextPopupField === 'detail') {
                allTransactions[currentTextPopupRowIndex].detail = newText;
            }

            // Save to storage
            await saveTransactionsToStorage();

            // Re-render table
            renderTransactions();

            // Show success
            showSimpleToast('‚úÖ Text updated successfully', 'success');

            // Close modal
            closeTextPopup();
        }

        function cancelTextPopupEdit() {
            const content = document.getElementById('textPopupContent');
            const editBox = document.getElementById('textPopupEdit');

            // Reset edit box to original value
            editBox.value = content.textContent;

            // Switch back to view mode
            content.style.display = 'block';
            editBox.style.display = 'none';

            // Update buttons
            document.getElementById('textPopupCloseBtn').style.display = 'inline-block';
            document.getElementById('textPopupEditBtn').style.display = 'inline-block';
            document.getElementById('textPopupSaveBtn').style.display = 'none';
            document.getElementById('textPopupCancelBtn').style.display = 'none';
        }

        function closeTextPopup() {
            document.getElementById('textPopupModal').style.display = 'none';
            currentTextPopupField = null;
            currentTextPopupRowIndex = null;
        }

        // Close popup when clicking outside
        document.getElementById('textPopupModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTextPopup();
            }
        });

        // ========================================
        // GMAIL API AUTHENTICATION (Google Identity Services)
        // ========================================

        // Initialize GAPI client
        function gapiLoaded() {
            gapi.load('client', async () => {
                await gapi.client.init({
                    apiKey: GOOGLE_API_KEY,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'],
                });

                // Explicitly load Gmail API to ensure it's available
                await gapi.client.load('gmail', 'v1');

                gapiInited = true;
                console.log('GAPI client initialized');
                console.log('Gmail API loaded:', !!gapi.client.gmail);
                maybeEnableButtons();
            });
        }

        // Initialize GIS client
        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GMAIL_SCOPES,
                callback: (response) => {
                    if (response.error !== undefined) {
                        console.error('GIS error:', response);
                        showSimpleToast('‚ùå Gmail authentication failed', 'error');
                        return;
                    }
                    handleAuthSuccess(response.access_token);
                },
            });
            gisInited = true;
            console.log('GIS client initialized');
            maybeEnableButtons();
        }

        // Enable buttons when both libraries are loaded
        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                updateGmailStatus();
            }
        }

        // Initialize Google Auth when page loads
        function initializeGoogleAuth() {
            // Load GAPI
            if (typeof gapi !== 'undefined') {
                gapiLoaded();
            } else {
                window.addEventListener('load', () => {
                    setTimeout(gapiLoaded, 100);
                });
            }

            // Load GIS
            if (typeof google !== 'undefined' && google.accounts) {
                gisLoaded();
            } else {
                window.addEventListener('load', () => {
                    setTimeout(gisLoaded, 100);
                });
            }
        }

        // Sign in to Gmail (add new account)
        async function signInToGmail() {
            if (!tokenClient) {
                showSimpleToast('‚ö†Ô∏è Google API not initialized yet. Please wait...', 'error');
                return;
            }

            // Request an access token (will prompt for account selection)
            tokenClient.requestAccessToken({ prompt: 'select_account' });
        }

        // Sign out from specific Gmail account
        function signOutFromAccount(email) {
            const accountIndex = gmailAccounts.findIndex(acc => acc.email === email);
            if (accountIndex !== -1) {
                const account = gmailAccounts[accountIndex];
                if (account.accessToken) {
                    google.accounts.oauth2.revoke(account.accessToken, () => {
                        console.log('Access token revoked for:', email);
                    });
                }
                gmailAccounts.splice(accountIndex, 1);
                saveGmailAccountsToStorage(); // Persist removal
                updateGmailStatus();
                showSimpleToast(`‚úÖ Signed out: ${email}`, 'success');
            }
        }

        // Sign out from all Gmail accounts
        function signOutFromGmail() {
            gmailAccounts.forEach(account => {
                if (account.accessToken) {
                    google.accounts.oauth2.revoke(account.accessToken, () => {
                        console.log('Access token revoked for:', account.email);
                    });
                }
            });
            gmailAccounts = [];
            saveGmailAccountsToStorage(); // Clear saved accounts
            updateGmailStatus();
            showSimpleToast('‚úÖ Signed out from all accounts', 'success');
        }

        async function handleAuthSuccess(accessToken) {
            console.log('Authentication successful, token received');

            // Calculate token expiry time (Google OAuth2 tokens expire after 1 hour)
            // Set expiry to 55 minutes from now to be safe (account for clock skew)
            const tokenExpiresAt = Date.now() + (55 * 60 * 1000); // 55 minutes in milliseconds
            const expiryDate = new Date(tokenExpiresAt);
            console.log(`üïê Token will expire at: ${expiryDate.toLocaleTimeString()}`);

            try {
                // Get user info
                const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`
                    }
                });

                if (response.ok) {
                    const userInfo = await response.json();
                    const email = userInfo.email;

                    // Check if account already exists
                    const existingAccount = gmailAccounts.find(acc => acc.email === email);
                    if (existingAccount) {
                        // Update token for existing account
                        existingAccount.accessToken = accessToken;
                        existingAccount.tokenExpiresAt = tokenExpiresAt;
                        showSimpleToast(`‚úÖ Reconnected: ${email}`, 'success');
                    } else {
                        // Add new account (selected by default)
                        gmailAccounts.push({
                            email: email,
                            accessToken: accessToken,
                            tokenExpiresAt: tokenExpiresAt,
                            selected: true
                        });
                        showSimpleToast(`‚úÖ Connected: ${email}`, 'success');
                    }

                    console.log('User info retrieved:', email);
                } else {
                    console.warn('Could not get user info, but token is valid');
                    // Add account without email
                    gmailAccounts.push({
                        email: 'Account ' + (gmailAccounts.length + 1),
                        accessToken: accessToken,
                        tokenExpiresAt: tokenExpiresAt,
                        selected: true
                    });
                    // showSimpleToast('‚úÖ Connected to Gmail', 'success'); // DISABLED (user preference)
                }
            } catch (error) {
                console.error('Error getting user info:', error);
                // Even if we can't get user info, we have the token
                gmailAccounts.push({
                    email: 'Account ' + (gmailAccounts.length + 1),
                    accessToken: accessToken,
                    tokenExpiresAt: tokenExpiresAt,
                    selected: true
                });
                // showSimpleToast('‚úÖ Connected to Gmail', 'success'); // DISABLED (user preference)
            }

            saveGmailAccountsToStorage(); // Persist to localStorage (including token and expiry)
            updateGmailStatus();
        }

        function updateGmailStatus() {
            const statusDiv = document.getElementById('gmailConnectionStatus');
            const accountsList = document.getElementById('gmailAccountsList');
            const connectBtn = document.getElementById('gmailConnectBtn');
            const signOutBtn = document.getElementById('gmailSignOutBtn');

            if (gmailAccounts.length === 0) {
                statusDiv.innerHTML = '<span style="color: #dc2626;">‚ùå Not connected</span>';
                accountsList.innerHTML = '';
                if (connectBtn) connectBtn.style.display = 'inline-flex';
                if (signOutBtn) signOutBtn.style.display = 'none';
            } else {
                const selectedCount = gmailAccounts.filter(acc => acc.selected).length;
                statusDiv.innerHTML = `<span style="color: #059669;">${gmailAccounts.length} account${gmailAccounts.length > 1 ? 's' : ''} (${selectedCount} selected)</span>`;

                let html = '';

                gmailAccounts.forEach((account, index) => {
                    // Check if token is missing or expired
                    const now = Date.now();
                    const isTokenExpired = account.tokenExpiresAt && account.tokenExpiresAt < now;
                    const needsAuth = !account.accessToken || isTokenExpired;

                    let statusIndicator, tooltipText;
                    if (!account.accessToken) {
                        statusIndicator = '‚ö†Ô∏è';
                        tooltipText = 'Not authenticated';
                    } else if (isTokenExpired) {
                        statusIndicator = 'üïê';
                        tooltipText = 'Token expired - click Reconnect';
                    } else {
                        statusIndicator = '‚úÖ';
                        const expiryDate = new Date(account.tokenExpiresAt);
                        tooltipText = `Token valid until ${expiryDate.toLocaleTimeString()}`;
                    }

                    html += `
                        <div style="display: flex; align-items: center; gap: 5px; background: ${needsAuth ? '#fff3cd' : '#f8f9fa'}; padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; border: 1px solid ${account.selected ? '#3AAFA9' : '#e9ecef'};" title="${tooltipText}">
                            <input
                                type="checkbox"
                                id="gmailAccount${index}"
                                ${account.selected ? 'checked' : ''}
                                ${needsAuth ? 'disabled' : ''}
                                onchange="toggleAccountSelection(${index})"
                                style="cursor: ${needsAuth ? 'not-allowed' : 'pointer'}; width: 14px; height: 14px; margin: 0;"
                            >
                            <label for="gmailAccount${index}" style="flex: 1; cursor: pointer; font-size: 11px; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${statusIndicator} ${escapeHtml(account.email.split('@')[0])}
                            </label>
                            ${needsAuth ? `
                                <button
                                    onclick="reconnectAccount(${index})"
                                    class="modal-btn modal-btn-primary"
                                    style="margin: 0; padding: 2px 6px; font-size: 10px;">
                                    Reconnect
                                </button>
                            ` : ''}
                            <button
                                onclick="signOutFromAccount('${escapeHtml(account.email)}')"
                                class="modal-btn modal-btn-secondary"
                                style="margin: 0; padding: 2px 6px; font-size: 10px;">
                                ‚úï
                            </button>
                        </div>
                    `;
                });

                accountsList.innerHTML = html;

                if (connectBtn) {
                    connectBtn.innerHTML = '+ Add Account';
                }
                if (signOutBtn) signOutBtn.style.display = 'none';
            }
        }

        // Reconnect a specific account that needs re-authentication
        function reconnectAccount(index) {
            if (!tokenClient) {
                showSimpleToast('‚ùå Gmail client not initialized', 'error');
                return;
            }

            // Store the index we're reconnecting so we can match it in handleAuthSuccess
            window.reconnectingAccountIndex = index;

            // Trigger OAuth flow
            tokenClient.requestAccessToken({ prompt: 'select_account' });
        }

        // Toggle account selection for searching
        function toggleAccountSelection(index) {
            if (gmailAccounts[index]) {
                gmailAccounts[index].selected = !gmailAccounts[index].selected;
                saveGmailAccountsToStorage(); // Persist selection state
                updateGmailStatus();
            }
        }

        // ========================================
        // GMAIL SEARCH & EMAIL PARSING
        // ========================================

        async function searchEmailsForTransaction(transaction) {
            const searchQueries = buildSearchQueries(transaction);
            const selectedAccounts = gmailAccounts.filter(acc => acc.selected);

            if (selectedAccounts.length === 0) {
                showSimpleToast('‚ö†Ô∏è No accounts selected for search', 'error');
                return [];
            }

            let allResults = [];

            // Search across all selected accounts
            for (const account of selectedAccounts) {
                console.log(`Searching account: ${account.email}`);

                for (const query of searchQueries) {
                    try {
                        const results = await searchGmail(query, account.accessToken);
                        // Tag results with account email
                        results.forEach(msg => msg.accountEmail = account.email);
                        allResults = allResults.concat(results);
                    } catch (error) {
                        console.error(`Search error for ${account.email}, query:`, query, error);
                    }
                }
            }

            // Deduplicate by message ID + account email
            const uniqueResults = [];
            const seenIds = new Set();
            for (const msg of allResults) {
                const uniqueKey = `${msg.accountEmail}:${msg.id}`;
                if (!seenIds.has(uniqueKey)) {
                    seenIds.add(uniqueKey);
                    uniqueResults.push(msg);
                }
            }

            console.log(`Found ${uniqueResults.length} unique results across ${selectedAccounts.length} account(s)`);
            return uniqueResults;
        }

        function buildSearchQueries(transaction) {
            const queries = [];
            const amount = parseAmount(transaction.spent || transaction.received);
            const date = new Date(transaction.date);

            // Date range: ¬±3 days from transaction date
            const afterDate = formatGmailDate(new Date(date.getTime() - 3 * 24 * 60 * 60 * 1000));
            const beforeDate = formatGmailDate(new Date(date.getTime() + 3 * 24 * 60 * 60 * 1000));

            // Extract merchant/vendor name from description
            const merchant = extractMerchantName(transaction.description);

            // Query 1: Merchant name + date range + common invoice keywords
            if (merchant) {
                queries.push(
                    `{from:${merchant} OR subject:${merchant}} ` +
                    `{invoice OR receipt OR order OR confirmation OR payment} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            }

            // Query 2: Amount-based search (format variations)
            const amountVariations = [
                amount.toFixed(2),
                '¬£' + amount.toFixed(2),
                amount.toFixed(2).replace('.', ',') // European format
            ];

            amountVariations.forEach(amt => {
                queries.push(
                    `{${amt}} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            });

            // Query 3: Description keywords + date
            const keywords = extractKeywords(transaction.description);
            if (keywords.length > 0) {
                queries.push(
                    `{${keywords.join(' OR ')}} ` +
                    `has:attachment filename:pdf ` +
                    `after:${afterDate} before:${beforeDate}`
                );
            }

            return queries.slice(0, 3); // Limit to first 3 queries to avoid too many searches
        }

        function extractMerchantName(description) {
            // Remove common payment processor prefixes
            let cleaned = description
                .replace(/^(CARD PAYMENT TO|PAYMENT TO|PURCHASE AT|POS|DEBIT CARD|PAYPAL|STRIPE)/i, '')
                .trim();

            // Extract first significant word(s)
            const words = cleaned.split(/\s+/).filter(w => w.length > 2);
            return words.slice(0, 2).join(' '); // First 2 words
        }

        function extractKeywords(description) {
            const stopWords = ['the', 'and', 'to', 'at', 'from', 'for', 'on', 'in', 'card', 'payment'];
            return description.toLowerCase()
                .split(/\s+/)
                .filter(word => word.length > 3 && !stopWords.includes(word))
                .slice(0, 5); // Top 5 keywords
        }

        function formatGmailDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}/${month}/${day}`;
        }

        async function searchGmail(query, accessToken) {
            try {
                // Verify Gmail API is loaded
                if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.gmail) {
                    throw new Error('Gmail API not initialized');
                }

                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.list({
                    userId: 'me',
                    q: query,
                    maxResults: 10
                });

                return response.result.messages || [];
            } catch (error) {
                console.error('Gmail search error:', error);
                return [];
            }
        }

        async function extractPDFsFromEmail(messageId, accessToken) {
            try {
                // Verify Gmail API is loaded
                if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.gmail) {
                    throw new Error('Gmail API not initialized');
                }

                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.get({
                    userId: 'me',
                    id: messageId,
                    format: 'full'
                });

                const message = response.result;
                const pdfs = [];
                let emailHtmlBody = '';

                // Parse email parts recursively
                function extractAttachments(parts) {
                    if (!parts) return;

                    parts.forEach(part => {
                        if (part.mimeType === 'application/pdf') {
                            pdfs.push({
                                filename: part.filename,
                                attachmentId: part.body.attachmentId,
                                size: part.body.size,
                                messageId: messageId
                            });
                        }

                        // Extract HTML body for link detection
                        if (part.mimeType === 'text/html' && part.body.data) {
                            try {
                                const decodedHtml = atob(part.body.data.replace(/-/g, '+').replace(/_/g, '/'));
                                emailHtmlBody += decodedHtml;
                            } catch (e) {
                                console.warn('Could not decode HTML part:', e);
                            }
                        }

                        if (part.parts) {
                            extractAttachments(part.parts);
                        }
                    });
                }

                extractAttachments(message.payload.parts);

                // Return both PDFs and HTML body for link detection
                return { pdfs, htmlBody: emailHtmlBody };
            } catch (error) {
                console.error('Error extracting PDFs:', error);
                return { pdfs: [], htmlBody: '' };
            }
        }

        function detectInvoiceLinks(htmlBody) {
            if (!htmlBody) return null;

            // Patterns to detect invoice-related links/buttons
            const invoiceKeywords = [
                'invoice', 'receipt', 'order', 'bill', 'statement',
                'download', 'view', 'get', 'access', 'see'
            ];

            // Look for links with invoice-related text or URLs
            const linkPattern = /<a[^>]*href=["']([^"']+)["'][^>]*>([^<]*)<\/a>/gi;
            const buttonPattern = /<(?:button|div|span)[^>]*>([^<]*(?:invoice|receipt|order|bill)[^<]*)<\/(?:button|div|span)>/gi;

            let foundInvoiceLink = false;
            let linkText = '';

            // Check for invoice-related links
            let match;
            while ((match = linkPattern.exec(htmlBody)) !== null) {
                const url = match[1];
                const text = match[2].toLowerCase();

                // Check if link text contains invoice keywords
                const hasInvoiceKeyword = invoiceKeywords.some(keyword => text.includes(keyword));

                if (hasInvoiceKeyword) {
                    foundInvoiceLink = true;
                    linkText = match[2].trim();
                    break;
                }
            }

            // Check for invoice-related buttons if no link found
            if (!foundInvoiceLink) {
                while ((match = buttonPattern.exec(htmlBody)) !== null) {
                    linkText = match[1].trim();
                    foundInvoiceLink = true;
                    break;
                }
            }

            if (foundInvoiceLink) {
                return {
                    hasInvoiceLink: true,
                    linkText: linkText || 'Download Invoice',
                    message: 'This email contains an invoice that needs to be accessed via a link in the email.'
                };
            }

            return null;
        }

        function openGmailEmail(messageId, accountEmail) {
            // Create Gmail URL to open the email directly
            const gmailUrl = `https://mail.google.com/mail/u/${accountEmail}/#all/${messageId}`;
            window.open(gmailUrl, '_blank');
        }

        async function downloadPDFAttachment(messageId, attachmentId, accessToken) {
            try {
                // Set the access token for this request
                gapi.client.setToken({ access_token: accessToken });

                const response = await gapi.client.gmail.users.messages.attachments.get({
                    userId: 'me',
                    messageId: messageId,
                    id: attachmentId
                });

                // Gmail returns data in URL-safe base64 format
                const data = response.result.data
                    .replace(/-/g, '+')
                    .replace(/_/g, '/');

                // Convert base64 to Blob
                const binaryString = atob(data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                return new Blob([bytes], { type: 'application/pdf' });
            } catch (error) {
                console.error('Error downloading attachment:', error);
                return null;
            }
        }

        // ========================================
        // PDF STORAGE IN INDEXEDDB
        // ========================================

        async function saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId = null) {
            if (!db) await initIndexedDB();

            // Get transaction data to store with invoice for cross-page matching
            const txn = allTransactions[transactionIndex];

            const invoiceData = {
                transactionIndex: transactionIndex,
                transactionDate: txn?.date || null,
                description: txn?.description || null,
                filename: filename,
                pdfBlob: pdfBlob,
                size: pdfBlob.size,
                uploadDate: new Date().toISOString(),
                source: messageId ? 'gmail' : 'manual',
                gmailMessageId: messageId,
                extractedText: null,
                aiDescription: null
            };

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const request = store.add(invoiceData);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        console.log('Invoice saved with ID:', request.result);
                        resolve(request.result);
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error saving invoice:', error);
                return null;
            }
        }

        async function getInvoicesForTransaction(transactionIndex) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readonly');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const index = store.index('transactionIndex');
                const request = index.getAll(transactionIndex);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error getting invoices:', error);
                return [];
            }
        }

        async function updateInvoiceText(invoiceId, text) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.extractedText = text;
                        store.put(invoice);
                    }
                };
            } catch (error) {
                console.error('Error updating invoice text:', error);
            }
        }

        async function updateInvoiceWithAIDescription(invoiceId, description) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.aiDescription = description;
                        store.put(invoice);
                    }
                };
            } catch (error) {
                console.error('Error updating invoice:', error);
            }
        }

        // ========================================
        // PDF TEXT EXTRACTION (PDF.js + OCR)
        // ========================================

        async function extractTextFromPDF(pdfBlob) {
            try {
                const arrayBuffer = await pdfBlob.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                let fullText = '';
                const totalPages = pdf.numPages;

                console.log(`Processing PDF with ${totalPages} page(s)...`);

                for (let pageNum = 1; pageNum <= Math.min(totalPages, 5); pageNum++) { // Limit to first 5 pages
                    const page = await pdf.getPage(pageNum);

                    // Try text extraction first (for text-based PDFs)
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');

                    if (pageText.trim().length > 50) {
                        // Text-based PDF
                        fullText += `\n--- Page ${pageNum} ---\n` + pageText;
                    } else {
                        // Scanned PDF - use OCR
                        fullText += `\n--- Page ${pageNum} (OCR) ---\n`;
                        const ocrText = await performOCR(page);
                        fullText += ocrText;
                    }
                }

                return fullText.trim();
            } catch (error) {
                console.warn('‚ö†Ô∏è PDF extraction error:', error.message || error);
                // Don't show toast here - let the caller handle it since we might be processing multiple PDFs
                return null;
            }
        }

        async function performOCR(pdfPage) {
            try {
                const viewport = pdfPage.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;

                // Perform OCR on canvas
                const { data: { text } } = await Tesseract.recognize(
                    canvas,
                    'eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
                            }
                        }
                    }
                );

                return text;
            } catch (error) {
                console.error('OCR error:', error);
                return '';
            }
        }

        // ========================================
        // AI DESCRIPTION GENERATION
        // ========================================

        async function generateDescriptionFromInvoice(invoiceText, transaction) {
            // Check for API key
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                showSimpleToast('‚ùå OpenAI API Key required for AI description generation', 'error');
                return null;
            }

            const prompt = `You are a financial transaction classifier. Based on the invoice/receipt text below, generate a CONCISE description of the purchase in 2-10 words.

Transaction Details:
- Date: ${transaction.date}
- Amount: ¬£${transaction.spent || transaction.received}
- Original Description: ${transaction.description}

Invoice/Receipt Text:
${invoiceText.substring(0, 4000)}

IMPORTANT: Return ONLY a concise 2-10 word description. Focus on what was purchased, not who sold it.

Examples:
- "Google Workspace subscription"
- "Office supplies and stationery"
- "Website hosting services"
- "Marketing consultation"

Description:`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a financial assistant that creates concise 2-10 word purchase descriptions.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 50,
                        temperature: 0.2
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('AI description generation error:', error);
                showSimpleToast('‚ö†Ô∏è AI description generation failed', 'error');
                return null;
            }
        }

        // ========================================
        // STRUCTURED DATA EXTRACTION FROM INVOICE
        // ========================================

        /**
         * Extract structured data (company, amount, date) from invoice text using AI
         */
        async function extractStructuredDataFromInvoice(invoiceText, transactionContext = null) {
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                console.warn('‚ö†Ô∏è No API key available for structured extraction');
                return null;
            }

            // Add context hint for better date inference
            let contextHint = '';
            if (transactionContext && transactionContext.date) {
                contextHint = `\n\nContext: This invoice should be from around ${transactionContext.date}. If the invoice shows a date without a year (e.g., "Aug 19" or "19/08"), infer the year from this context date.`;
            }

            const prompt = `Extract the following information from this invoice/receipt text and return it as a JSON object:

Required fields:
- company: The company/vendor name (string)
- amount: The total amount (number, no currency symbols)
- date: The invoice/transaction date in YYYY-MM-DD format (string). IMPORTANT: If the invoice shows a date without a year, infer the correct year based on the context.${contextHint}

Invoice Text:
${invoiceText.substring(0, 4000)}

Return ONLY a valid JSON object with these three fields. If a field cannot be found, use null.
Example: {"company": "Acme Corp", "amount": 123.45, "date": "2025-01-15"}`;

            try {
                console.log('üîç [EXTRACT] Sending invoice text to ChatGPT for structured extraction...');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a data extraction assistant. Always return valid JSON only, no additional text.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 150,
                        temperature: 0.1,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const extractedData = JSON.parse(data.choices[0].message.content.trim());

                console.log('‚úÖ [EXTRACT] Structured data extracted:', extractedData);
                return extractedData;

            } catch (error) {
                console.error('‚ùå [EXTRACT] Structured extraction failed:', error);
                return null;
            }
        }

        /**
         * Validate extracted invoice data against transaction entry using AI
         */
        async function validateInvoiceData(extractedData, transaction) {
            const apiKey = getOpenAIKey();
            if (!apiKey) {
                console.warn('‚ö†Ô∏è No API key available for validation');
                return null;
            }

            // Parse transaction amount - strip ¬£ symbol and commas
            const transactionAmountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, '').trim();
            const transactionAmount = parseFloat(transactionAmountStr) || 0;

            // Parse extracted amount (handle both string and number)
            const extractedAmount = parseFloat(extractedData.amount) || 0;

            // Client-side validation checks for override
            const amountDifference = Math.abs(transactionAmount - extractedAmount);
            const clientSideAmountMatch = amountDifference <= 0.02; // Allow 2p tolerance for rounding

            // Client-side date validation (within 7 days - more flexible)
            let clientSideDateMatch = false;
            let dateDaysDifference = null;
            if (extractedData.date && transaction.date) {
                try {
                    // Parse extracted date (usually YYYY-MM-DD from AI)
                    const extractedDate = new Date(extractedData.date);

                    // Parse transaction date - handle DD/MM/YYYY format
                    let transactionDate;
                    if (transaction.date.includes('/')) {
                        // DD/MM/YYYY format
                        const [day, month, year] = transaction.date.split('/');
                        transactionDate = new Date(year, month - 1, day); // month is 0-indexed
                    } else {
                        // Assume ISO format YYYY-MM-DD
                        transactionDate = new Date(transaction.date);
                    }

                    const timeDiff = Math.abs(extractedDate - transactionDate);
                    dateDaysDifference = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                    clientSideDateMatch = dateDaysDifference <= 7; // Within 7 days = match (more flexible)

                    console.log('üìÖ [VALIDATE] Date parsing DETAILED:', {
                        transactionRaw: transaction.date,
                        transactionParsed: transactionDate.toISOString().split('T')[0],
                        transactionDateObj: transactionDate,
                        extractedRaw: extractedData.date,
                        extractedParsed: extractedDate.toISOString().split('T')[0],
                        extractedDateObj: extractedDate,
                        timeDiffMS: timeDiff,
                        daysDifference: dateDaysDifference,
                        within5Days: clientSideDateMatch
                    });
                } catch (e) {
                    console.warn('Could not parse dates for client-side validation:', e);
                }
            }

            console.log('üí∞ [VALIDATE] Amount comparison:', {
                transaction: transactionAmount,
                extracted: extractedAmount,
                difference: amountDifference,
                clientSideMatch: clientSideAmountMatch
            });

            console.log('üìÖ [VALIDATE] Date comparison:', {
                transaction: transaction.date,
                extracted: extractedData.date,
                daysDifference: dateDaysDifference,
                clientSideMatch: clientSideDateMatch
            });

            const prompt = `You are a financial data validator. Compare the extracted invoice data with the transaction entry and determine if they match.

Extracted from Invoice:
- Company: ${extractedData.company || 'Not found'}
- Amount: ¬£${extractedData.amount || 'Not found'}
- Date: ${extractedData.date || 'Not found'}

Transaction Entry:
- Description/Company: ${transaction.description || 'Not provided'}
- Amount: ¬£${transactionAmount.toFixed(2)}
- Date: ${transaction.date || 'Not provided'}

Analyze each field and return a JSON object with:
{
  "companyMatch": true/false,
  "amountMatch": true/false,
  "dateMatch": true/false,
  "companyReason": "2-10 word explanation",
  "amountReason": "2-10 word explanation",
  "dateReason": "2-10 word explanation",
  "overallConfidence": "high"/"medium"/"low",
  "recommendation": "attach"/"review"/"reject"
}

IMPORTANT: Keep all reason fields concise (2-10 words maximum). Examples:
- "Exact match"
- "Names similar"
- "Within tolerance"
- "3 days difference"

Consider:
- Company: Allow partial matches, common abbreviations, similar names
- Amount: Match if difference is ‚â§ ¬£0.02 (to account for rounding)
- Date: Match if within ¬±7 days of transaction date (be VERY lenient with dates - invoices are often dated a few days before or after the transaction)

Return ONLY valid JSON.`;

            try {
                console.log('üîç [VALIDATE] Sending data to ChatGPT for validation...');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a financial validation assistant. Always return valid JSON only, no additional text.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 300,
                        temperature: 0.1,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const validationResult = JSON.parse(data.choices[0].message.content.trim());

                // CLIENT-SIDE OVERRIDE: If amounts match within tolerance, override AI if it says they don't match
                if (clientSideAmountMatch && !validationResult.amountMatch) {
                    console.log('‚ö†Ô∏è [VALIDATE] AI said amounts don\'t match, but client-side check says they do. Overriding AI decision.');
                    validationResult.amountMatch = true;
                    validationResult.amountReason = `Amounts match within tolerance (difference: ¬£${amountDifference.toFixed(2)})`;
                }

                // CLIENT-SIDE OVERRIDE: If dates within 7 days, override AI if it says they don't match
                if (clientSideDateMatch && !validationResult.dateMatch) {
                    console.log('‚ö†Ô∏è [VALIDATE] AI said dates don\'t match, but client-side check says they do (within 7 days). Overriding AI decision.');
                    console.log('üìÖ [OVERRIDE] Date override details:', {
                        clientSideDateMatch,
                        dateDaysDifference,
                        aiDateMatch: validationResult.dateMatch,
                        overridingTo: true
                    });
                    validationResult.dateMatch = true;
                    validationResult.dateReason = `Dates match within tolerance (${dateDaysDifference} day(s) difference)`;
                }

                // Log final validation state
                console.log('üèÅ [VALIDATE] Final validation result:', {
                    companyMatch: validationResult.companyMatch,
                    amountMatch: validationResult.amountMatch,
                    dateMatch: validationResult.dateMatch,
                    recommendation: validationResult.recommendation
                });

                // Update overall recommendation if all fields now match
                if (validationResult.companyMatch && validationResult.amountMatch && validationResult.dateMatch) {
                    validationResult.recommendation = 'attach';
                    validationResult.overallConfidence = 'high';
                }

                console.log('‚úÖ [VALIDATE] Validation complete:', validationResult);
                return validationResult;

            } catch (error) {
                console.error('‚ùå [VALIDATE] Validation failed:', error);
                return null;
            }
        }

        // ========================================
        // INTELLIGENT INVOICE SEARCH - PHASE 1
        // ========================================

        /**
         * Build comprehensive search context from transaction
         */
        function buildTransactionContext(transaction, transactionIndex) {
            console.log('üîç [CONTEXT] Building search context for:', transaction);

            // Check if transaction has been converted to USD
            let amount, amountFormats, currencyInfo;

            if (transaction.convertedCurrency && transaction.convertedAmount) {
                // Use converted USD amount
                amount = transaction.convertedAmount;
                amountFormats = generateUSDAmountFormats(amount);
                currencyInfo = {
                    currency: transaction.convertedCurrency,
                    originalAmount: parseFloat((transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, '').trim()),
                    originalCurrency: 'GBP',
                    conversionRate: transaction.conversionRate,
                    conversionDate: transaction.conversionDate
                };

                console.log('üí± [CONTEXT] Using converted amount:', {
                    originalGBP: currencyInfo.originalAmount,
                    convertedUSD: amount,
                    rate: currencyInfo.conversionRate
                });
            } else {
                // Extract core data - strip ¬£ symbol and commas
                const amountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, '').trim();
                amount = parseFloat(amountStr) || 0;
                amountFormats = generateAmountFormats(amount);
                currencyInfo = { currency: 'GBP', originalAmount: amount, originalCurrency: 'GBP' };

                console.log('üí∞ [CONTEXT] Amount parsing:', {
                    original: transaction.spent || transaction.received,
                    cleaned: amountStr,
                    parsed: amount
                });
            }

            const isSpending = transaction.spent && transaction.spent.trim();

            // Clean merchant name from description
            const merchantInfo = extractMerchantName(transaction.description);

            // Extract keywords from assignments
            const contextKeywords = [];
            if (transaction.assignedItemName) {
                contextKeywords.push(transaction.assignedItemName);
            }
            if (transaction.assignments && transaction.assignments.length > 0) {
                transaction.assignments.forEach(a => {
                    if (a.itemName) contextKeywords.push(a.itemName);
                });
            }

            // Include user voice notes
            const userNotes = transaction.voiceNotes ? transaction.voiceNotes.trim() : '';

            const context = {
                // Core data
                index: transactionIndex,
                date: parseTransactionDate(transaction.date),
                amount: amount,
                description: transaction.description,
                fromTo: transaction.fromTo || null,
                bank: transaction.bank,
                isSpending: isSpending,

                // Extracted/derived
                merchantName: merchantInfo.cleaned,
                merchantOriginal: merchantInfo.original,
                merchantVariants: merchantInfo.variants,

                // Amount formats
                amountFormats: amountFormats,

                // Currency information
                currencyInfo: currencyInfo,

                // User context
                userContext: contextKeywords.join(', '),
                userNotes: userNotes,

                // Temporal
                dayOfWeek: getDayOfWeek(transaction.date),

                // Search hints
                expectedDocumentTypes: isSpending
                    ? ['invoice', 'receipt', 'order confirmation', 'payment confirmation']
                    : ['receipt', 'payment received', 'transfer confirmation']
            };

            console.log('‚úÖ [CONTEXT] Built context:', context);
            return context;
        }

        /**
         * Extract and clean merchant name from description
         */
        function extractMerchantName(description) {
            if (!description) return { original: '', cleaned: '', variants: [] };

            let cleaned = description.trim();

            // Remove common prefixes
            const prefixes = [
                'CARD PAYMENT TO ',
                'CARD PAYMENT ',
                'DIRECT DEBIT TO ',
                'DIRECT DEBIT ',
                'PAYPAL \\*',
                'PAYPAL ',
                'STANDING ORDER TO ',
                'FASTER PAYMENT TO ',
                'PAYMENT TO ',
                'TRANSFER TO ',
                'DD ',
                'SO '
            ];

            for (const prefix of prefixes) {
                const regex = new RegExp('^' + prefix, 'i');
                cleaned = cleaned.replace(regex, '');
            }

            // Remove dates at end (e.g., "AMAZON UK 23/01/25")
            cleaned = cleaned.replace(/\s+\d{1,2}\/\d{1,2}\/\d{2,4}$/, '');

            // Remove reference numbers (e.g., "REF 12345678")
            cleaned = cleaned.replace(/\s+REF\s+\w+/i, '');
            cleaned = cleaned.replace(/\s+\d{6,}$/, '');

            // Generate variants
            const variants = [cleaned];

            // Add without country codes
            const withoutCountry = cleaned.replace(/\s+(UK|GB|US|EU)\b/gi, '').trim();
            if (withoutCountry !== cleaned) {
                variants.push(withoutCountry);
            }

            // Add common abbreviations
            if (cleaned.toLowerCase().includes('amazon')) {
                variants.push('Amazon', 'Amazon UK', 'Amazon.co.uk', 'Amazon Marketplace');
            }
            if (cleaned.toLowerCase().includes('tesco')) {
                variants.push('Tesco', 'Tesco Stores');
            }
            // Add more common merchants as needed

            return {
                original: description,
                cleaned: cleaned,
                variants: [...new Set(variants)] // Remove duplicates
            };
        }

        /**
         * Generate amount in multiple formats
         */
        function generateAmountFormats(amount) {
            if (!amount || amount === 0) return [];

            const formats = [
                amount.toFixed(2),                    // 50.00
                `¬£${amount.toFixed(2)}`,              // ¬£50.00
                `\u00A3${amount.toFixed(2)}`,         // ¬£50.00 (unicode)
                amount.toFixed(2).replace('.', ','),  // 50,00 (European)
                `GBP ${amount.toFixed(2)}`,           // GBP 50.00
            ];

            // Add variations without decimals if whole number
            if (amount % 1 === 0) {
                formats.push(amount.toString());      // 50
                formats.push(`¬£${amount}`);           // ¬£50
            }

            return [...new Set(formats)];
        }

        /**
         * Generate USD amount in multiple formats
         */
        function generateUSDAmountFormats(amount) {
            if (!amount || amount === 0) return [];

            const formats = [
                amount.toFixed(2),                    // 65.23
                `$${amount.toFixed(2)}`,              // $65.23
                `\$${amount.toFixed(2)}`,             // $65.23 (escaped)
                `USD ${amount.toFixed(2)}`,           // USD 65.23
                `US$${amount.toFixed(2)}`,            // US$65.23
                amount.toFixed(2).replace('.', ','),  // 65,23 (European)
            ];

            // Add variations without decimals if whole number
            if (amount % 1 === 0) {
                formats.push(amount.toString());      // 65
                formats.push(`$${amount}`);           // $65
                formats.push(`USD ${amount}`);        // USD 65
            }

            return [...new Set(formats)];
        }

        /**
         * Parse transaction date to Date object
         */
        function parseTransactionDate(dateStr) {
            if (!dateStr) return new Date();

            // Assuming DD/MM/YYYY or DD/MM/YY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
                let year = parseInt(parts[2]);

                // Handle 2-digit years
                if (year < 100) {
                    year += year < 50 ? 2000 : 1900;
                }

                return new Date(year, month, day);
            }

            return new Date(dateStr);
        }

        /**
         * Get day of week from date string
         */
        function getDayOfWeek(dateStr) {
            const date = parseTransactionDate(dateStr);
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days[date.getDay()];
        }

        // ========================================
        // SEARCH LOGGER
        // ========================================

        class SearchLogger {
            constructor() {
                this.logs = [];
                this.container = null;
            }

            init(containerId) {
                this.container = document.getElementById(containerId);
                this.logs = [];
                this.render();
            }

            logStage(stage, name) {
                this.addLog('stage', `\n[STAGE ${stage}] ${name}`, 'info', 'üîÑ');
                this.render();
            }

            logProgress(message, type = 'info') {
                const icons = {
                    info: '‚è≥',
                    success: '‚úÖ',
                    warning: '‚ö†Ô∏è',
                    error: '‚ùå',
                    ai: 'ü§ñ'
                };
                this.addLog('progress', message, type, icons[type] || '‚Ä¢');
                this.render();
                this.updateHeader(message, icons[type]);
            }

            updateHeader(message, icon) {
                const statusEl = document.getElementById('searchLogStatus');
                const summaryEl = document.getElementById('searchLogSummary');

                if (statusEl) statusEl.textContent = icon;

                // Update summary with last message (truncated)
                if (summaryEl && message) {
                    const truncated = message.length > 40 ? message.substring(0, 40) + '...' : message;
                    summaryEl.textContent = truncated;
                }
            }

            logAI(action, result) {
                this.addLog('ai', `ü§ñ AI: ${action}`, 'ai', 'ü§ñ');
                if (result) {
                    this.addLog('ai', `   ‚Üí ${JSON.stringify(result).substring(0, 100)}...`, 'info', '  ');
                }
                this.render();
            }

            logResults(count, stage) {
                if (count > 0) {
                    this.addLog('result', `üìä Found ${count} potential invoice${count > 1 ? 's' : ''}!`, 'success', '‚úÖ');
                } else {
                    this.addLog('result', `No results in ¬±${stage} days`, 'warning', '‚ö†Ô∏è');
                }
                this.render();
            }

            addLog(category, message, type, icon) {
                this.logs.push({
                    timestamp: new Date(),
                    category,
                    message,
                    type,
                    icon
                });
            }

            render() {
                if (!this.container) return;

                const html = this.logs.map(log => {
                    const colors = {
                        info: '#94a3b8',
                        success: '#4ade80',
                        warning: '#fbbf24',
                        error: '#f87171',
                        ai: '#a78bfa'
                    };
                    const color = colors[log.type] || '#e2e8f0';

                    return `<div style="color: ${color}; margin: 3px 0; line-height: 1.5;">
                        ${log.icon} ${log.message}
                    </div>`;
                }).join('');

                this.container.innerHTML = html;

                // Auto-scroll to bottom
                this.container.scrollTop = this.container.scrollHeight;
            }

            clear() {
                this.logs = [];
                this.render();
            }
        }

        // Global search logger instance
        const searchLogger = new SearchLogger();

        /**
         * Format email date to compact format (e.g., "Jan 15" or "15 Jan 2025")
         */
        function formatCompactDate(emailDateStr) {
            try {
                const date = new Date(emailDateStr);
                const now = new Date();
                const isCurrentYear = date.getFullYear() === now.getFullYear();

                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const month = months[date.getMonth()];
                const day = date.getDate();

                if (isCurrentYear) {
                    return `${month} ${day}`;
                } else {
                    return `${month} ${day}, ${date.getFullYear()}`;
                }
            } catch (error) {
                return emailDateStr.substring(0, 15); // Fallback: truncate
            }
        }

        /**
         * Toggle search log visibility
         */
        function toggleSearchLog() {
            const container = document.getElementById('searchLogContainer');
            const icon = document.getElementById('searchLogIcon');
            const summary = document.getElementById('searchLogSummary');

            if (container.style.display === 'none') {
                // Expand
                container.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
                icon.textContent = '‚ñº';
                summary.textContent = '(Click to collapse)';
            } else {
                // Collapse
                container.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
                icon.textContent = '‚ñ∂';
                summary.textContent = '(Click to expand)';
            }
        }

        // ========================================
        // INTELLIGENT SEARCH MODAL CONTROLS
        // ========================================

        function showIntelligentSearchModal(transaction, transactionIndex) {
            const modal = document.getElementById('intelligentSearchModal');

            // Set transaction details
            document.getElementById('searchTxDate').textContent = transaction.date || 'N/A';

            // Fix double ¬£ sign - strip existing ¬£ before adding new one
            const amount = (transaction.spent || transaction.received || '0.00').toString().replace(/¬£/g, '');
            document.getElementById('searchTxAmount').textContent = `¬£${amount}`;

            document.getElementById('searchTxDesc').textContent = transaction.description || 'N/A';

            // Show/hide From/To field
            if (transaction.fromTo && transaction.fromTo.trim()) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = transaction.fromTo;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Show/hide user notes field
            if (transaction.voiceNotes && transaction.voiceNotes.trim()) {
                document.getElementById('searchTxNotesContainer').style.display = 'block';
                document.getElementById('searchTxNotes').textContent = transaction.voiceNotes;
                console.log('üìù [MODAL] Showing user notes:', transaction.voiceNotes);
            } else {
                document.getElementById('searchTxNotesContainer').style.display = 'none';
                console.log('üìù [MODAL] No user notes to display');
            }

            // Initialize logger
            searchLogger.init('searchLogContainer');

            // Clear any previous pasted image
            if (typeof clearPastedImage === 'function') {
                clearPastedImage();
            }

            // Show modal
            modal.style.display = 'flex';

            // Initialize drag-and-drop and paste functionality
            initManualUploadOnModalOpen();

            // Start search
            executeIntelligentSearch(transaction, transactionIndex);
        }

        function closeIntelligentSearchModal() {
            document.getElementById('intelligentSearchModal').style.display = 'none';

            // Restore log header visibility for next search
            const logHeader = document.getElementById('searchLogHeader');
            if (logHeader) logHeader.style.display = 'flex';

            searchLogger.clear();

            // Clear pasted image preview
            if (typeof clearPastedImage === 'function') {
                clearPastedImage();
            }
        }

        // ============================================================
        // BACKGROUND INVOICE SEARCH QUEUE SYSTEM
        // ============================================================

        /**
         * Invoice Search Queue Manager
         * Handles multiple concurrent background searches
         */
        class InvoiceSearchQueue {
            constructor() {
                this.tasks = [];
                this.maxConcurrent = 3;
                this.taskIdCounter = 0;
                this.isProcessing = false;
            }

            /**
             * Add a new search task to the queue
             */
            addTask(transaction, transactionIndex) {
                const taskId = `search_${Date.now()}_${this.taskIdCounter++}`;
                const task = {
                    id: taskId,
                    transactionIndex: transactionIndex,
                    transaction: { ...transaction },
                    status: 'pending',
                    startTime: null,
                    endTime: null,
                    results: null,
                    error: null,
                    progress: 0,
                    logs: [], // Store search logs
                    searchedAccounts: [] // Store which accounts were searched
                };

                this.tasks.push(task);
                console.log(`üìã [QUEUE] Added task ${taskId} for transaction #${transactionIndex}`, task);

                // Start processing queue
                this.processQueue();

                return taskId;
            }

            /**
             * Add a log entry to a task
             */
            logToTask(task, message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                task.logs.push({
                    time: timestamp,
                    message,
                    type // 'info', 'success', 'warning', 'error'
                });
                console.log(`[${task.id}] ${message}`);
            }

            /**
             * Process the queue - run up to maxConcurrent tasks
             */
            async processQueue() {
                if (this.isProcessing) return;
                this.isProcessing = true;

                const runningTasks = this.tasks.filter(t => t.status === 'running');
                const pendingTasks = this.tasks.filter(t => t.status === 'pending');

                // Start new tasks up to max concurrent limit
                const slotsAvailable = this.maxConcurrent - runningTasks.length;
                const tasksToStart = pendingTasks.slice(0, slotsAvailable);

                for (const task of tasksToStart) {
                    this.executeTask(task);
                }

                this.isProcessing = false;
                this.updateQueueUI();
            }

            /**
             * Execute a single search task in the background
             */
            async executeTask(task) {
                task.status = 'running';
                task.startTime = Date.now();
                console.log(`üîç [QUEUE] Starting search for transaction #${task.transactionIndex}`);

                this.updateQueueUI();
                this.updateTransactionButton(task.transactionIndex, 'searching');

                try {
                    // Execute the search in background
                    const results = await this.runBackgroundSearch(task.transaction, task.transactionIndex, task);

                    // Task completed successfully
                    task.status = 'completed';
                    task.endTime = Date.now();
                    task.results = results;
                    task.progress = 100;

                    const duration = ((task.endTime - task.startTime) / 1000).toFixed(1);
                    console.log(`‚úÖ [QUEUE] Task completed in ${duration}s:`, results);

                    // Show notification
                    // this.showCompletionNotification(task);  // DISABLED: User no longer wants popup notifications

                    // Update button state
                    this.updateTransactionButton(task.transactionIndex, 'completed', results);

                } catch (error) {
                    // Task failed
                    task.status = 'failed';
                    task.endTime = Date.now();
                    task.error = error.message || 'Unknown error';
                    task.progress = 0;

                    console.error(`‚ùå [QUEUE] Task failed:`, error);

                    // Show error notification
                    // this.showCompletionNotification(task);  // DISABLED: User no longer wants popup notifications

                    // Update button state
                    this.updateTransactionButton(task.transactionIndex, 'failed');
                }

                // Process next task in queue
                setTimeout(() => this.processQueue(), 100);
            }

            /**
             * Run background search (silent version of executeIntelligentSearch)
             */
            async runBackgroundSearch(transaction, transactionIndex, task) {
                // Check Gmail connection
                if (gmailAccounts.length === 0) {
                    throw new Error('Gmail not connected');
                }

                this.logToTask(task, 'üîç Starting invoice search...', 'info');

                // Get valid accounts
                const validAccounts = gmailAccounts.filter(acc => {
                    const now = Date.now();
                    return acc.accessToken && (!acc.tokenExpiresAt || acc.tokenExpiresAt > now);
                });

                if (validAccounts.length === 0) {
                    const expiredAccounts = gmailAccounts.filter(acc => acc.tokenExpiresAt && acc.tokenExpiresAt <= Date.now());

                    if (expiredAccounts.length > 0) {
                        // Tokens expired - auto-trigger reconnect
                        this.logToTask(task, `‚ö†Ô∏è Gmail access tokens have expired for ${expiredAccounts.length} account(s)`, 'warning');
                        this.logToTask(task, 'üîÑ Opening reconnect dialog...', 'info');

                        // Find the index of the first expired account and reconnect it
                        const accountIndex = gmailAccounts.findIndex(acc =>
                            acc.tokenExpiresAt && acc.tokenExpiresAt <= Date.now()
                        );

                        // Trigger reconnect dialog
                        setTimeout(() => {
                            if (accountIndex >= 0) {
                                reconnectAccount(accountIndex);
                            } else {
                                signInToGmail(); // Fallback to general connect
                            }
                        }, 500);

                        throw new Error('Gmail access tokens expired. Opening reconnect dialog...');
                    } else if (gmailAccounts.length === 0) {
                        // No accounts connected - auto-trigger connect
                        this.logToTask(task, '‚ùå No Gmail accounts connected', 'error');
                        this.logToTask(task, 'üìß Opening Gmail connection dialog...', 'info');

                        // Trigger Gmail connection dialog
                        setTimeout(() => signInToGmail(), 500);

                        throw new Error('No Gmail accounts connected. Opening connection dialog...');
                    } else {
                        // Accounts exist but have no tokens
                        this.logToTask(task, '‚ö†Ô∏è Gmail accounts need authentication', 'warning');
                        this.logToTask(task, 'üîÑ Opening reconnect dialog...', 'info');

                        setTimeout(() => reconnectAccount(0), 500);

                        throw new Error('No valid Gmail access tokens. Opening reconnect dialog...');
                    }
                }

                task.searchedAccounts = validAccounts.map(acc => acc.email);
                this.logToTask(task, `üìß Searching ${validAccounts.length} Gmail account(s): ${validAccounts.map(a => a.email).join(', ')}`, 'success');

                // Build search context
                task.progress = 10;
                this.updateQueueUI();
                this.logToTask(task, 'üìù Building search context...', 'info');
                const context = buildTransactionContext(transaction, transactionIndex);
                this.logToTask(task, `üí∞ Amount: ¬£${context.amount} | Date: ${context.date.toLocaleDateString()}`, 'info');
                this.logToTask(task, `üè¢ Merchant: "${context.merchantName}"`, 'info');

                // AI merchant interpretation
                task.progress = 20;
                this.updateQueueUI();
                this.logToTask(task, 'ü§ñ Analyzing merchant name with AI...', 'info');
                const aiMerchantInfo = await interpretMerchantNameWithAI(context.merchantName);
                if (aiMerchantInfo) {
                    context.aiMerchantInfo = aiMerchantInfo;
                    this.logToTask(task, `üéØ AI identified: "${aiMerchantInfo.companyName}"`, 'success');
                    if (aiMerchantInfo.likelyDomain) {
                        this.logToTask(task, `üìß Likely domain: ${aiMerchantInfo.likelyDomain}`, 'success');
                    }
                }

                // AI keyword enhancement
                task.progress = 30;
                this.updateQueueUI();
                this.logToTask(task, 'üîé Generating smart search keywords...', 'info');
                const aiKeywords = await generateAISearchKeywords(context);
                if (aiKeywords && aiKeywords.length > 0) {
                    this.logToTask(task, `üìã AI keywords: ${aiKeywords.join(', ')}`, 'success');
                }

                // Sequential search with progress updates
                task.progress = 40;
                this.updateQueueUI();
                this.logToTask(task, 'üîç Executing search queries...', 'info');
                const allMessages = await this.performSequentialSearch(context, aiKeywords, validAccounts, task);

                // Collect results
                task.progress = 90;
                this.updateQueueUI();

                this.logToTask(task, `üìä Found ${allMessages.length} email(s) in search`, allMessages.length > 0 ? 'success' : 'warning');

                const results = {
                    messagesFound: allMessages.length,
                    pdfsFound: 0,
                    linkBasedInvoicesFound: 0,
                    emailMatches: []
                };

                if (allMessages.length > 0) {
                    this.logToTask(task, 'üìé Extracting PDF attachments and analyzing emails...', 'info');
                }

                // Process each message and extract PDFs
                for (const msg of allMessages) {
                    const account = validAccounts.find(acc => acc.email === msg.accountEmail);
                    if (!account) continue;

                    try {
                        gapi.client.setToken({ access_token: account.accessToken });

                        const messageDetail = await gapi.client.gmail.users.messages.get({
                            userId: 'me',
                            id: msg.id,
                            format: 'metadata',
                            metadataHeaders: ['From', 'Subject', 'Date']
                        });

                        const headers = messageDetail.result.payload.headers;
                        const extractionResult = await extractPDFsFromEmail(msg.id, account.accessToken);
                        const pdfs = extractionResult.pdfs || [];
                        const htmlBody = extractionResult.htmlBody || '';

                        // Check for invoice links if no PDFs found
                        let invoiceLinkInfo = null;
                        if (pdfs.length === 0 && htmlBody) {
                            invoiceLinkInfo = detectInvoiceLinks(htmlBody);
                            if (invoiceLinkInfo) {
                                results.linkBasedInvoicesFound++;
                            }
                        }

                        const emailMatch = {
                            messageId: msg.id,
                            accountEmail: msg.accountEmail,
                            subject: headers.find(h => h.name === 'Subject')?.value || 'No Subject',
                            from: headers.find(h => h.name === 'From')?.value || 'Unknown',
                            date: headers.find(h => h.name === 'Date')?.value || '',
                            pdfs: pdfs,
                            invoiceLinkInfo: invoiceLinkInfo
                        };

                        results.emailMatches.push(emailMatch);
                        results.pdfsFound += pdfs.length;

                        if (pdfs.length > 0) {
                            const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                            this.logToTask(task, `üìÑ Found ${pdfs.length} PDF(s) in: "${subject.substring(0, 40)}..."`, 'success');
                        } else if (invoiceLinkInfo) {
                            const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                            this.logToTask(task, `üîó Found invoice link in: "${subject.substring(0, 40)}..."`, 'success');
                        }
                    } catch (error) {
                        console.error('Error processing message:', error);
                        this.logToTask(task, `‚ö†Ô∏è Error processing email: ${error.message}`, 'warning');
                    }
                }

                const totalInvoices = results.pdfsFound + results.linkBasedInvoicesFound;
                if (totalInvoices > 0) {
                    this.logToTask(task, `‚úÖ Search complete! Found ${results.pdfsFound} PDF invoice(s) and ${results.linkBasedInvoicesFound} link-based invoice(s)`, 'success');
                } else {
                    this.logToTask(task, `‚ÑπÔ∏è Search complete. No invoices found.`, 'warning');
                }

                return results;
            }

            /**
             * Perform sequential search across accounts
             */
            async performSequentialSearch(context, aiKeywords, accounts, task) {
                const allMessages = [];

                // Use stage 1 search (tightest date window)
                const stage = { stage: 1, dateWindow: 7, autoExecute: true };
                const queries = buildStageQueries(context, stage, aiKeywords);

                this.logToTask(task, `üîé Generated ${queries.length} search queries (using top 3)`, 'info');

                const totalSteps = accounts.length * Math.min(queries.length, 3); // Limit to first 3 queries for speed
                const progressPerStep = 50 / totalSteps; // 40-90% range
                let currentStep = 0;

                // Verify Gmail API is loaded
                if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.gmail) {
                    this.logToTask(task, '‚ùå Gmail API not initialized. Please refresh the page.', 'error');
                    throw new Error('Gmail API not initialized');
                }

                // Search each account with top queries
                for (const account of accounts) {
                    gapi.client.setToken({ access_token: account.accessToken });
                    this.logToTask(task, `üìß Searching account: ${account.email}`, 'info');

                    // Try top 3 queries for this account
                    for (let qIdx = 0; qIdx < Math.min(queries.length, 3); qIdx++) {
                        const query = queries[qIdx];

                        this.logToTask(task, `  Query ${qIdx + 1}: ${query.description || query.query.substring(0, 60)}...`, 'info');

                        try {
                            const response = await gapi.client.gmail.users.messages.list({
                                userId: 'me',
                                q: query.query,
                                maxResults: 5
                            });

                            if (response.result.messages) {
                                response.result.messages.forEach(msg => {
                                    allMessages.push({
                                        ...msg,
                                        accountEmail: account.email
                                    });
                                });

                                // If we found results, no need to try more queries for this account
                                if (response.result.messages.length > 0) {
                                    this.logToTask(task, `  ‚úÖ Found ${response.result.messages.length} email(s)!`, 'success');
                                    currentStep += (Math.min(queries.length, 3) - qIdx); // Skip remaining queries
                                    break;
                                } else {
                                    this.logToTask(task, `  No results for this query`, 'info');
                                }
                            }
                        } catch (error) {
                            console.error(`Error searching account ${account.email}:`, error);
                            this.logToTask(task, `  ‚ö†Ô∏è Error: ${error.message}`, 'warning');
                        }

                        // Update progress
                        currentStep++;
                        task.progress = 40 + (currentStep * progressPerStep);
                        this.updateQueueUI();
                    }
                }

                return allMessages;
            }

            /**
             * Show completion notification
             */
            showCompletionNotification(task) {
                const transaction = task.transaction;
                const shortDesc = (transaction.description || 'Transaction').substring(0, 30) + '...';

                let icon, title, message, bgColor;

                if (task.status === 'completed') {
                    const pdfCount = task.results.pdfsFound || 0;
                    const linkCount = task.results.linkBasedInvoicesFound || 0;
                    const totalInvoices = pdfCount + linkCount;

                    if (totalInvoices > 0) {
                        icon = '‚úÖ';
                        title = 'Invoice Search Complete';
                        if (pdfCount > 0 && linkCount > 0) {
                            message = `Found ${pdfCount} PDF invoice${pdfCount > 1 ? 's' : ''} and ${linkCount} email${linkCount > 1 ? 's' : ''} with invoice links for ${shortDesc}`;
                        } else if (pdfCount > 0) {
                            message = `Found ${pdfCount} PDF invoice${pdfCount > 1 ? 's' : ''} for ${shortDesc}`;
                        } else {
                            message = `Found ${linkCount} email${linkCount > 1 ? 's' : ''} with invoice links for ${shortDesc}. Click to open in Gmail.`;
                        }
                        bgColor = '#10b981';
                    } else {
                        icon = '‚ÑπÔ∏è';
                        title = 'No Invoices Found';
                        message = `No invoices found for ${shortDesc}`;
                        bgColor = '#3b82f6';
                    }
                } else if (task.status === 'failed') {
                    // Check if this is an auth-related error that auto-triggered reconnect
                    const isAuthError = task.error.includes('expired') ||
                                       task.error.includes('not connected') ||
                                       task.error.includes('No valid') ||
                                       task.error.includes('Opening');

                    if (isAuthError) {
                        icon = 'üîÑ';
                        title = 'Reconnecting Gmail...';
                        message = task.error.includes('Opening') ?
                                 'Gmail reconnect dialog should open automatically' :
                                 `${task.error}`;
                        bgColor = '#f59e0b'; // Orange for warning/action needed
                    } else {
                        icon = '‚ùå';
                        title = 'Search Failed';
                        message = `${task.error} - ${shortDesc}`;
                        bgColor = '#ef4444';
                    }
                }

                // Determine which actions to show based on error type
                const actions = [];

                if (task.status === 'failed' && (
                    task.error.includes('expired') ||
                    task.error.includes('not connected') ||
                    task.error.includes('No valid') ||
                    task.error.includes('Opening')
                )) {
                    // For auth issues, reconnect dialog opens automatically - just show dismissable toast
                    // No action buttons needed since reconnect is auto-triggered
                } else if (task.status === 'completed' || task.status === 'failed') {
                    actions.push({
                        label: 'View Results',
                        onClick: () => openSearchResults(task.id)
                    });
                }

                showToast({
                    icon,
                    title,
                    message,
                    bgColor,
                    duration: task.status === 'failed' ? 12000 : 8000, // Longer duration for errors
                    actions
                });
            }

            /**
             * Update transaction button state
             */
            updateTransactionButton(transactionIndex, state, results = null) {
                const btn = document.getElementById(`invoiceBtn${transactionIndex}`);
                if (!btn) return;

                switch (state) {
                    case 'searching':
                        btn.innerHTML = 'üîç';
                        btn.title = 'Searching for invoice...';
                        btn.style.background = '#3b82f6';
                        btn.classList.add('searching-pulse');
                        break;

                    case 'completed':
                        if (results) {
                            const pdfCount = results.pdfsFound || 0;
                            const linkCount = results.linkBasedInvoicesFound || 0;
                            const totalInvoices = pdfCount + linkCount;

                            if (totalInvoices > 0) {
                                btn.innerHTML = `üîî<span style="position: absolute; top: -4px; right: -4px; background: #10b981; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; font-weight: bold; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${totalInvoices}</span>`;
                                if (pdfCount > 0 && linkCount > 0) {
                                    btn.title = `${pdfCount} PDF${pdfCount > 1 ? 's' : ''} and ${linkCount} email${linkCount > 1 ? 's' : ''} with invoice links - click to view`;
                                } else if (linkCount > 0) {
                                    btn.title = `${linkCount} email${linkCount > 1 ? 's' : ''} with invoice links - click to open in Gmail`;
                                } else {
                                    btn.title = `${pdfCount} invoice${pdfCount > 1 ? 's' : ''} found - click to view`;
                                }
                                btn.style.background = '#10b981';
                                btn.classList.remove('searching-pulse');
                                btn.classList.add('pulse-once');
                            } else {
                                btn.innerHTML = '‚ÑπÔ∏è';
                                btn.title = 'No invoices found - click to search again';
                                btn.style.background = '#94a3b8';
                                btn.classList.remove('searching-pulse');
                            }
                        } else {
                            btn.innerHTML = '‚ÑπÔ∏è';
                            btn.title = 'No invoices found - click to search again';
                            btn.style.background = '#94a3b8';
                            btn.classList.remove('searching-pulse');
                        }
                        break;

                    case 'failed':
                        btn.innerHTML = '‚ùå';
                        btn.title = 'Search failed - click to try again';
                        btn.style.background = '#ef4444';
                        btn.classList.remove('searching-pulse');
                        break;
                }
            }

            /**
             * Update queue UI indicator
             */
            updateQueueUI() {
                const runningCount = this.tasks.filter(t => t.status === 'running').length;
                const pendingCount = this.tasks.filter(t => t.status === 'pending').length;
                const totalActive = runningCount + pendingCount;

                const indicator = document.getElementById('queueStatusIndicator');
                if (!indicator) return;

                if (totalActive > 0) {
                    indicator.style.display = 'flex';
                    indicator.innerHTML = `
                        <span class="queue-pulse"></span>
                        <span>üîç ${runningCount} running</span>
                        ${pendingCount > 0 ? `<span style="margin-left: 8px; color: rgba(255,255,255,0.7);">‚è≥ ${pendingCount} queued</span>` : ''}
                    `;
                } else {
                    indicator.style.display = 'none';
                }

                // Update queue panel if open
                const panel = document.getElementById('queueManagerPanel');
                if (panel && panel.style.display !== 'none') {
                    this.renderQueuePanel();
                }
            }

            /**
             * Cancel a task
             */
            cancelTask(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;

                if (task.status === 'pending') {
                    task.status = 'cancelled';
                    console.log(`üö´ [QUEUE] Cancelled task ${taskId}`);
                    this.updateQueueUI();
                    this.processQueue();
                } else if (task.status === 'running') {
                    // Can't truly cancel running task, but mark it
                    console.warn(`‚ö†Ô∏è [QUEUE] Cannot cancel running task ${taskId}`);
                }
            }

            /**
             * Get queue statistics
             */
            getStats() {
                return {
                    total: this.tasks.length,
                    running: this.tasks.filter(t => t.status === 'running').length,
                    pending: this.tasks.filter(t => t.status === 'pending').length,
                    completed: this.tasks.filter(t => t.status === 'completed').length,
                    failed: this.tasks.filter(t => t.status === 'failed').length
                };
            }

            /**
             * Clear completed tasks
             */
            clearCompleted() {
                const beforeCount = this.tasks.length;
                this.tasks = this.tasks.filter(t => t.status !== 'completed' && t.status !== 'failed');
                const cleared = beforeCount - this.tasks.length;
                console.log(`üóëÔ∏è [QUEUE] Cleared ${cleared} completed tasks`);
                this.updateQueueUI();
            }

            /**
             * Get task by ID
             */
            getTask(taskId) {
                return this.tasks.find(t => t.id === taskId);
            }

            /**
             * Render queue manager panel
             */
            renderQueuePanel() {
                const panel = document.getElementById('queuePanelContent');
                if (!panel) return;

                const running = this.tasks.filter(t => t.status === 'running');
                const pending = this.tasks.filter(t => t.status === 'pending');
                const completed = this.tasks.filter(t => t.status === 'completed' || t.status === 'failed').slice(-10);

                let html = '';

                // Running tasks
                if (running.length > 0) {
                    html += `<div class="queue-section">
                        <div class="queue-section-header">RUNNING (${running.length})</div>`;
                    running.forEach(task => {
                        const desc = (task.transaction.description || 'Unknown').substring(0, 30);
                        html += `
                            <div class="queue-item queue-item-running">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600;">‚è≥ ${desc}...</div>
                                    <div style="font-size: 11px; color: #64748b; margin-top: 2px;">Progress: ${task.progress}%</div>
                                </div>
                                <button onclick="invoiceSearchQueue.cancelTask('${task.id}')" class="queue-btn-cancel">Cancel</button>
                            </div>`;
                    });
                    html += `</div>`;
                }

                // Pending tasks
                if (pending.length > 0) {
                    html += `<div class="queue-section">
                        <div class="queue-section-header">QUEUED (${pending.length})</div>`;
                    pending.forEach(task => {
                        const desc = (task.transaction.description || 'Unknown').substring(0, 30);
                        const position = pending.indexOf(task) + 1;
                        html += `
                            <div class="queue-item queue-item-pending">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600;">‚è∏Ô∏è ${desc}...</div>
                                    <div style="font-size: 11px; color: #64748b; margin-top: 2px;">Position #${position}</div>
                                </div>
                                <button onclick="invoiceSearchQueue.cancelTask('${task.id}')" class="queue-btn-cancel">Cancel</button>
                            </div>`;
                    });
                    html += `</div>`;
                }

                // Completed tasks
                if (completed.length > 0) {
                    html += `<div class="queue-section">
                        <div class="queue-section-header">COMPLETED (${completed.length})</div>`;
                    completed.forEach(task => {
                        const desc = (task.transaction.description || 'Unknown').substring(0, 25);
                        const icon = task.status === 'completed' ? '‚úÖ' : '‚ùå';
                        const resultText = task.status === 'completed'
                            ? `${task.results.pdfsFound} PDF${task.results.pdfsFound !== 1 ? 's' : ''}`
                            : 'Failed';
                        html += `
                            <div class="queue-item queue-item-completed">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600;">${icon} ${desc}...</div>
                                    <div style="font-size: 11px; color: #64748b; margin-top: 2px;">${resultText}</div>
                                </div>
                                <button onclick="openSearchResults('${task.id}')" class="queue-btn-view">View</button>
                            </div>`;
                    });
                    html += `</div>`;
                }

                if (running.length === 0 && pending.length === 0 && completed.length === 0) {
                    html = '<div style="text-align: center; padding: 40px; color: #94a3b8;">No search tasks</div>';
                }

                panel.innerHTML = html;
            }
        }

        // Initialize global queue instance
        const invoiceSearchQueue = new InvoiceSearchQueue();

        // ============================================================
        // TOAST NOTIFICATION SYSTEM
        // ============================================================

        let toastIdCounter = 0;
        const activeToasts = [];
        const toastActionHandlers = {}; // Store action handlers by ID

        /**
         * Show a toast notification
         */
        function showToast({ icon, title, message, bgColor, duration = 8000, actions = [] }) {
            const toastId = `toast_${Date.now()}_${toastIdCounter++}`;

            const toast = document.createElement('div');
            toast.id = toastId;
            toast.className = 'toast-notification';
            toast.style.cssText = `
                position: fixed;
                right: 20px;
                top: ${100 + (activeToasts.length * 130)}px;
                width: 380px;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                padding: 16px;
                z-index: 10000;
                animation: slideInRight 0.3s ease-out;
                border-left: 5px solid ${bgColor};
            `;

            let actionsHtml = '';
            if (actions.length > 0) {
                actionsHtml = '<div style="display: flex; gap: 8px; margin-top: 12px;">';
                actions.forEach((action, index) => {
                    const actionId = `${toastId}_action_${index}`;
                    // Store the handler
                    toastActionHandlers[actionId] = action.onClick;

                    actionsHtml += `
                        <button onclick="handleToastAction('${actionId}')"
                                style="flex: 1; padding: 8px 12px; background: ${bgColor}; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            ${action.label}
                        </button>`;
                });
                actionsHtml += `
                    <button onclick="dismissToast('${toastId}')"
                            style="padding: 8px 12px; background: #e2e8f0; color: #64748b; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                        Dismiss
                    </button>
                </div>`;
            }

            toast.innerHTML = `
                <div style="display: flex; align-items: start; gap: 12px;">
                    <div style="font-size: 28px; flex-shrink: 0;">${icon}</div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 700; font-size: 15px; color: #1e293b; margin-bottom: 4px;">${title}</div>
                        <div style="font-size: 13px; color: #64748b; line-height: 1.4;">${message}</div>
                        ${actionsHtml}
                    </div>
                    <button onclick="dismissToast('${toastId}')" style="background: none; border: none; color: #94a3b8; font-size: 20px; cursor: pointer; padding: 0; line-height: 1; flex-shrink: 0;">&times;</button>
                </div>
            `;

            document.body.appendChild(toast);
            activeToasts.push({ id: toastId, element: toast });

            // Auto-dismiss
            if (duration > 0) {
                setTimeout(() => dismissToast(toastId), duration);
            }

            return toastId;
        }

        /**
         * Handle toast action button click
         */
        function handleToastAction(actionId) {
            const handler = toastActionHandlers[actionId];
            if (handler) {
                handler();
                // Clean up the handler
                delete toastActionHandlers[actionId];
            }
        }

        /**
         * Dismiss a toast notification
         */
        function dismissToast(toastId) {
            const toastIndex = activeToasts.findIndex(t => t.id === toastId);
            if (toastIndex === -1) return;

            const toast = activeToasts[toastIndex].element;
            toast.style.animation = 'slideOutRight 0.3s ease-out';

            setTimeout(() => {
                if (toast && toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
                activeToasts.splice(toastIndex, 1);

                // Reposition remaining toasts
                activeToasts.forEach((t, idx) => {
                    t.element.style.top = `${100 + (idx * 130)}px`;
                });
            }, 300);
        }

        // ============================================================
        // QUEUE HELPER FUNCTIONS
        // ============================================================

        /**
         * Open search results for a specific task
         */
        function openSearchResults(taskId) {
            const task = invoiceSearchQueue.getTask(taskId);
            if (!task) {
                console.error('Task not found:', taskId);
                return;
            }

            if (task.status === 'completed' && task.results) {
                // Show results in a modal similar to the current search modal
                showSearchResultsModal(task);
            } else if (task.status === 'failed') {
                alert(`Search failed: ${task.error}\n\nClick "Find Invoice" again to retry.`);
            }
        }

        /**
         * Show search results modal
         */
        function showSearchResultsModal(task) {
            const modal = document.getElementById('intelligentSearchModal');
            const resultsContainer = document.getElementById('searchResultsContainer');

            if (!modal || !resultsContainer) {
                console.error('Search modal or results container not found');
                return;
            }

            // Hide progress bar (search is complete)
            document.getElementById('searchProgressBar').style.display = 'none';

            // Show search log with final results (collapsed by default)
            const logHeader = document.getElementById('searchLogHeader');
            const logContainer = document.getElementById('searchLogContainer');
            const logContent = document.getElementById('searchLogContent');

            if (logHeader) logHeader.style.display = 'flex';
            // Keep log minimized by default - user can click to expand if needed
            // if (logContainer) {
            //     logContainer.style.display = 'block';
            //     logContainer.style.maxHeight = '200px';
            // }

            // Render complete logs
            if (logContent && task.logs && task.logs.length > 0) {
                const logColors = {
                    info: '#64748b',
                    success: '#10b981',
                    warning: '#f59e0b',
                    error: '#ef4444'
                };

                let logsHtml = task.logs.map(log => {
                    const color = logColors[log.type] || logColors.info;
                    return `<div style="margin-bottom: 6px; font-size: 12px; color: ${color};">
                        <span style="opacity: 0.7;">[${log.time}]</span> ${log.message}
                    </div>`;
                }).join('');

                logContent.innerHTML = logsHtml;
                logContent.scrollTop = logContent.scrollHeight; // Scroll to bottom
            }

            // Set title
            document.getElementById('searchModalTitle').textContent = 'Search Results';

            // Populate transaction details
            const tx = task.transaction;
            document.getElementById('searchTxDate').textContent = tx.date || 'N/A';
            document.getElementById('searchTxAmount').textContent = `¬£${(tx.spent || tx.received || '0.00').toString().replace(/¬£/g, '')}`;
            document.getElementById('searchTxDesc').textContent = tx.description || 'N/A';

            if (tx.fromTo && tx.fromTo.trim()) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = tx.fromTo;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Build results HTML
            const results = task.results;
            resultsContainer.style.display = 'block';

            if (results.emailMatches.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8fafc; border-radius: 8px;">
                        <div style="font-size: 48px; margin-bottom: 15px;">üîç</div>
                        <h4 style="margin: 0 0 10px 0; color: #64748b;">No Invoices Found</h4>
                        <p style="color: #94a3b8; margin: 0 0 20px 0;">Try searching again with a different date range or merchant name.</p>

                        <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-top: 20px;">
                            <p style="color: #64748b; margin: 0 0 15px 0; font-size: 14px; font-weight: 500;">Or upload an invoice manually:</p>
                            <button onclick="document.getElementById('manualInvoiceUpload').click()" class="modal-btn modal-btn-primary" style="display: inline-flex; align-items: center; gap: 8px; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);">
                                <span style="font-size: 18px;">üì§</span>
                                <span>Upload PDF or Image</span>
                            </button>
                        </div>
                    </div>
                `;
            } else {
                let html = `<div style="font-weight: 600; margin-bottom: 12px; color: #10b981; font-size: 13px;">Found ${results.messagesFound} email(s) with ${results.pdfsFound} PDF(s):</div>`;

                const tx = task.transaction;
                const txAmount = (tx.spent || tx.received || '0.00').toString().replace(/¬£/g, '');
                const txDate = tx.date || 'N/A';

                results.emailMatches.forEach((match, matchIndex) => {
                    // Extract company from transaction description or fromTo
                    const txCompany = tx.fromTo || tx.description || 'Unknown';

                    html += `
                        <div class="invoice-result-card">
                            <!-- Main flex container: Left side (info) and Right side (buttons) -->
                            <div style="display: flex; gap: 12px; align-items: flex-start;">

                                <!-- Left side: Email info and content analysis -->
                                <div style="flex: 1; min-width: 0;">
                                    <!-- Email subject and sender -->
                                    <div style="font-size: 11px; color: #3AAFA9; font-weight: 600; margin-bottom: 4px;">
                                        üìß ${escapeHtml(match.subject)}
                                    </div>
                                    <div style="font-size: 10px; color: #94a3b8; margin-bottom: 8px;">
                                        <strong>From:</strong> ${escapeHtml(match.from)} | <strong>Account:</strong> ${escapeHtml(match.accountEmail)}
                                    </div>

                                    <!-- Transaction vs PDF comparison table (will be populated by autoProcessAllEmails) -->`;

                    // Store match index for table cell IDs
                    match.matchIndex = matchIndex;

                    if (match.pdfs.length > 0) {
                        match.pdfs.forEach((pdf, pdfIndex) => {
                            html += `
                                <table class="invoice-mini-table">
                                    <thead>
                                        <tr>
                                            <th style="width: 110px;"></th>
                                            <th>COMPANY</th>
                                            <th style="width: 100px;">AMOUNT</th>
                                            <th style="width: 90px;">DATE</th>
                                            <th style="width: 60px; text-align: center;">MATCH</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="row-label">Transaction</td>
                                            <td>${escapeHtml(txCompany.substring(0, 25))}${txCompany.length > 25 ? '...' : ''}</td>
                                            <td class="amount-cell">¬£${txAmount}</td>
                                            <td>${escapeHtml(txDate)}</td>
                                            <td class="match-icon">-</td>
                                        </tr>
                                        <tr id="email_${matchIndex}_${pdfIndex}_data">
                                            <td class="row-label">Email</td>
                                            <td class="pending-cell" colspan="3">‚è≥ Analyzing...</td>
                                            <td class="match-icon">‚è≥</td>
                                        </tr>
                                        <tr id="pdf_${matchIndex}_${pdfIndex}_data">
                                            <td class="row-label">PDF Invoice</td>
                                            <td class="pending-cell" colspan="3">‚è≥ Waiting...</td>
                                            <td class="match-icon">‚è≥</td>
                                        </tr>
                                    </tbody>
                                </table>`;
                        });
                    } else {
                        html += `<div style="color: #94a3b8; font-size: 12px; margin-top: 6px; text-align: center; padding: 10px; background: #f8fafc; border-radius: 4px;">No PDF attachments</div>`;
                    }

                    html += `
                                </div>

                                <!-- Right side: Action buttons -->
                                <div style="display: flex; flex-direction: column; gap: 6px; min-width: 180px;">`;

                    if (match.pdfs.length > 0) {
                        match.pdfs.forEach((pdf, pdfIndex) => {
                            html += `
                                <button onclick="attachInvoiceToTransaction('${escapeJs(match.messageId)}', '${escapeJs(pdf.attachmentId)}', '${escapeJs(pdf.filename)}', ${task.transactionIndex}, '${escapeJs(match.accountEmail)}')"
                                        class="modal-btn modal-btn-primary"
                                        style="padding: 10px 12px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; font-size: 10px; text-align: center; box-shadow: 0 2px 4px rgba(34,197,94,0.2); transition: all 0.2s;"
                                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(34,197,94,0.4)'"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(34,197,94,0.2)'">
                                    <div style="font-size: 18px; margin-bottom: 4px;">üì•</div>
                                    <div style="margin-bottom: 2px;">Download & Process</div>
                                    <div style="font-size: 8px; opacity: 0.9; font-weight: 500;">${escapeHtml(pdf.filename)} (${formatFileSize(pdf.size)})</div>
                                </button>`;
                        });
                    }

                    html += `
                                    <button onclick="openEmailInGmail('${escapeJs(match.messageId)}', '${escapeJs(match.accountEmail)}')"
                                            style="padding: 8px 12px; background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 10px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 5px; transition: all 0.2s;"
                                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 8px rgba(234,67,53,0.3)'"
                                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                        <span style="font-size: 12px;">üìß</span>
                                        <span>Open in Gmail</span>
                                    </button>
                                </div>
                            </div>
                        </div>`;
                });

                resultsContainer.innerHTML = html;
            }

            modal.style.display = 'flex';

            // Automatically start parallel processing
            autoProcessAllEmails(results, task);
        }

        // ========================================
        // PARALLEL EMAIL ANALYSIS SYSTEM
        // ========================================

        /**
         * Auto-processing configuration
         */
        const AUTO_PROCESS_SETTINGS = {
            minEmailMatchThreshold: 10,     // Minimum email match % to trigger auto-processing (10%)
            autoStopThreshold: 90,          // Auto-stop when PDF match >= 90%
            maxPDFsToProcess: 10,           // Maximum PDFs to process
            batchSize: 3,                   // Process N PDFs at a time
            confirmThreshold: 85,           // Ask user before continuing if match >= 85%
            allowBackground: true           // Allow background processing
        };

        /**
         * Automatic parallel processing of all emails
         */
        async function autoProcessAllEmails(results, task) {
            console.log('üöÄ [AUTO-PROCESS] Starting parallel analysis for', results.emailMatches.length, 'emails');
            console.log('üîç [DEBUG] Results structure:', results);

            const transaction = task.transaction;
            const txAmount = parseFloat((transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, ''));
            const txDate = parseTransactionDate(transaction.date);
            const txCompany = transaction.fromTo || transaction.description || 'Unknown';

            console.log('üí∞ [DEBUG] Transaction:', { txCompany, txAmount, txDate });

            // PHASE 1: Analyze email content (all parallel - instant)
            console.log('üìß [PHASE 1] Analyzing email content...');
            const emailAnalysisPromises = results.emailMatches.map(async (match, idx) => {
                console.log(`üìß [DEBUG] Analyzing email ${idx}:`, {
                    subject: match.subject,
                    from: match.from,
                    date: match.date,
                    matchIndex: match.matchIndex,
                    pdfCount: match.pdfs?.length
                });
                return analyzeEmailContent(match, transaction, txCompany, txAmount, txDate);
            });

            const emailScores = await Promise.all(emailAnalysisPromises);
            console.log('‚úÖ [PHASE 1] Email analysis complete:', emailScores);

            // Update UI with email scores
            results.emailMatches.forEach((match, idx) => {
                match.emailScore = emailScores[idx];

                // Update all email rows for this match
                if (match.pdfs && match.pdfs.length > 0) {
                    match.pdfs.forEach((pdf, pdfIdx) => {
                        const emailCellId = `email_${match.matchIndex}_${pdfIdx}_data`;
                        console.log(`üîß [DEBUG] Updating email cell: ${emailCellId}`, emailScores[idx]);
                        updateEmailTableRow(emailCellId, emailScores[idx], txAmount, txCompany, txDate);
                    });
                }
            });

            // Re-order results by email score (highest first)
            console.log('üîÑ [AUTO-PROCESS] Re-ordering results by email score...');
            reorderResultsByScore(results.emailMatches);

            // PHASE 2: Smart Threshold Check - Should we auto-process PDFs?
            const matchingEmails = results.emailMatches.filter(m =>
                m.emailScore && m.emailScore.totalScore >= AUTO_PROCESS_SETTINGS.minEmailMatchThreshold
            );

            if (matchingEmails.length === 0) {
                console.log('‚ùå [AUTO-PROCESS] No emails meet threshold. Stopping.');
                showNoMatchesMessage();
                return;
            }

            console.log(`‚úÖ [AUTO-PROCESS] Found ${matchingEmails.length} emails above threshold (${AUTO_PROCESS_SETTINGS.minEmailMatchThreshold}%). Auto-processing PDFs...`);

            // Show notification that auto-processing started
            // showSimpleToast(`üîÑ Auto-processing ${matchingEmails.length} PDFs in background...`, 'info'); // DISABLED (user preference)

            // PHASE 3: Build Priority Queue
            const priorityQueue = buildPriorityQueue(matchingEmails);
            const totalToProcess = priorityQueue.high.length + priorityQueue.medium.length + priorityQueue.low.length;

            console.log('üìä [QUEUE] Priority breakdown:', {
                high: priorityQueue.high.length,
                medium: priorityQueue.medium.length,
                low: priorityQueue.low.length,
                total: totalToProcess
            });

            if (totalToProcess === 0) {
                console.warn('‚ö†Ô∏è [AUTO-PROCESS] No emails with PDFs to process!');
                showNoMatchesMessage();
                return;
            }

            // Show progress indicator
            showProgressIndicator(0, totalToProcess, `Starting PDF processing (${totalToProcess} PDFs)...`);

            // PHASE 4: Process PDFs in batches (smart ordering)
            await processQueueInBatches(priorityQueue, transaction, task.transactionIndex, results.emailMatches);
        }

        /**
         * Build priority queue from matching emails
         */
        function buildPriorityQueue(emailMatches) {
            // Sort by email score (highest first)
            const sorted = emailMatches
                .filter(m => m.pdfs && m.pdfs.length > 0) // Only emails with PDFs
                .sort((a, b) => b.emailScore.totalScore - a.emailScore.totalScore);

            return {
                high: sorted.filter(m => m.emailScore.totalScore >= 70),
                medium: sorted.filter(m => m.emailScore.totalScore >= 40 && m.emailScore.totalScore < 70),
                low: sorted.filter(m => m.emailScore.totalScore > 0 && m.emailScore.totalScore < 40)
            };
        }

        /**
         * Process priority queue in batches
         */
        async function processQueueInBatches(queue, transaction, transactionIndex, emailMatches) {
            const allToProcess = [...queue.high, ...queue.medium, ...queue.low];
            const totalPDFs = allToProcess.reduce((sum, m) => sum + m.pdfs.length, 0);

            console.log(`üì¶ [BATCH] Processing ${totalPDFs} PDFs from ${allToProcess.length} emails`);
            console.log(`üì¶ [BATCH] Queue details:`, allToProcess.map(m => ({
                subject: m.subject.substring(0, 40),
                emailScore: m.emailScore.totalScore,
                pdfCount: m.pdfs.length
            })));

            let processedCount = 0;
            let bestMatchSoFar = 0;
            let bestMatchEmail = null;
            const results = [];

            // Limit to maxPDFsToProcess
            const limitedQueue = allToProcess.slice(0, AUTO_PROCESS_SETTINGS.maxPDFsToProcess);

            console.log(`üì¶ [BATCH] Will process ${limitedQueue.length} emails (limited from ${allToProcess.length})`);

            // Process in batches
            for (let i = 0; i < limitedQueue.length; i += AUTO_PROCESS_SETTINGS.batchSize) {
                const batch = limitedQueue.slice(i, i + AUTO_PROCESS_SETTINGS.batchSize);
                const batchNum = Math.floor(i / AUTO_PROCESS_SETTINGS.batchSize) + 1;

                console.log(`üì¶ [BATCH ${batchNum}] Starting batch with ${batch.length} emails:`);
                batch.forEach(m => console.log(`  - ${m.subject.substring(0, 50)} (Email: ${m.emailScore.totalScore}%)`));

                showProgressIndicator(processedCount, limitedQueue.length, `Processing batch ${batchNum} (${batch.length} PDFs)...`);

                // Process batch in parallel
                const batchPromises = [];
                for (const match of batch) {
                    if (match.pdfs && match.pdfs.length > 0) {
                        // Only process first PDF per email for speed
                        const pdf = match.pdfs[0];
                        console.log(`üìÑ [BATCH ${batchNum}] Queuing PDF: ${pdf.filename}`);

                        const promise = processPDFInParallel(match, pdf, i, transaction, transactionIndex)
                            .then(result => {
                                console.log(`‚úÖ [BATCH ${batchNum}] PDF completed:`, {
                                    filename: pdf.filename,
                                    score: result ? result.totalScore : 'error',
                                    result
                                });

                                if (result && result.totalScore !== undefined) {
                                    // Store PDF score in match object for re-ordering
                                    match.pdfScore = result.totalScore;

                                    results.push({
                                        email: match.subject,
                                        emailScore: match.emailScore.totalScore,
                                        pdfScore: result.totalScore,
                                        ...result
                                    });

                                    if (result.totalScore > bestMatchSoFar) {
                                        bestMatchSoFar = result.totalScore;
                                        bestMatchEmail = match;
                                        console.log(`üéØ [BEST] New best match: ${bestMatchSoFar}% from "${match.subject.substring(0, 40)}..."`);
                                        showSimpleToast(`üéØ Best match so far: ${bestMatchSoFar}%`, 'success');
                                    }
                                }
                                return result;
                            })
                            .catch(error => {
                                console.error(`‚ùå [BATCH ${batchNum}] Error processing PDF ${pdf.filename}:`, error);
                                return null;
                            });

                        batchPromises.push(promise);
                    }
                }

                console.log(`‚è≥ [BATCH ${batchNum}] Waiting for ${batchPromises.length} PDFs to process...`);
                const batchResults = await Promise.all(batchPromises);
                console.log(`‚úÖ [BATCH ${batchNum}] Batch complete. Results:`, batchResults.filter(r => r !== null));

                processedCount += batch.length;

                // Re-order results after each batch completes
                console.log('üîÑ [BATCH] Re-ordering results after batch completion...');
                reorderResultsByScore(emailMatches);

                // Update progress
                showProgressIndicator(processedCount, limitedQueue.length, `Processed ${processedCount}/${limitedQueue.length} - Best: ${bestMatchSoFar}%`);

                // Early exit check
                if (bestMatchSoFar >= AUTO_PROCESS_SETTINGS.autoStopThreshold) {
                    console.log(`üèÅ [EARLY EXIT] Found ${bestMatchSoFar}% match! Stopping processing.`);
                    showEarlyExitNotification(bestMatchSoFar, bestMatchEmail);
                    showSimpleToast(`‚úÖ Perfect match found! (${bestMatchSoFar}%)`, 'success');
                    break;
                }
            }

            // Complete
            console.log(`‚úÖ [COMPLETE] Processing finished!`);
            console.log(`üìä [COMPLETE] Summary:`, {
                processed: processedCount,
                total: limitedQueue.length,
                bestMatch: bestMatchSoFar,
                results: results
            });

            if (bestMatchSoFar > 0) {
                showProgressIndicator(processedCount, limitedQueue.length, `‚úÖ Complete! Best match: ${bestMatchSoFar}%`);
                // showSimpleToast(`‚úÖ Processing complete! Best match: ${bestMatchSoFar}%`, 'success'); // DISABLED (user preference)
            } else {
                showProgressIndicator(processedCount, limitedQueue.length, `‚ö†Ô∏è No valid matches found in PDFs`);
                // showSimpleToast(`‚ö†Ô∏è PDFs processed but no matches found`, 'warning'); // DISABLED (user preference)
            }

            setTimeout(() => {
                hideProgressIndicator();
            }, 5000);
        }

        /**
         * Update email table row with analysis results
         */
        function updateEmailTableRow(cellId, emailScore, txAmount, txCompany, txDate) {
            const row = document.getElementById(cellId);
            if (!row) return;

            const companyColor = emailScore.companyScore >= 25 ? '#059669' : (emailScore.companyScore >= 15 ? '#f59e0b' : '#dc2626');
            const amountColor = emailScore.amountScore >= 25 ? '#059669' : (emailScore.amountScore >= 15 ? '#f59e0b' : '#dc2626');
            const dateColor = emailScore.dateScore >= 25 ? '#059669' : (emailScore.dateScore >= 15 ? '#f59e0b' : '#dc2626');

            let matchIcon, matchClass;
            if (emailScore.totalScore >= 90) {
                matchIcon = 'üü¢';
                matchClass = 'match-perfect';
            } else if (emailScore.totalScore >= 70) {
                matchIcon = 'üü°';
                matchClass = 'match-good';
            } else if (emailScore.totalScore >= 50) {
                matchIcon = 'üü†';
                matchClass = 'match-possible';
            } else {
                matchIcon = 'üî¥';
                matchClass = 'match-weak';
            }

            row.innerHTML = `
                <td class="row-label">Email</td>
                <td style="color: ${companyColor}; font-weight: 600;">
                    ${emailScore.companyScore >= 15 ? '‚úì' : '‚úó'} ${escapeHtml(emailScore.companyText)}
                    <div style="font-size: 9px; opacity: 0.8;">+${emailScore.companyScore.toFixed(1)}%</div>
                </td>
                <td style="color: ${amountColor}; font-weight: 600;">
                    ${emailScore.amountScore >= 25 ? '‚úì' : '‚úó'} ${escapeHtml(emailScore.amountText)}
                    <div style="font-size: 9px; opacity: 0.8;">+${emailScore.amountScore.toFixed(1)}%</div>
                </td>
                <td style="color: ${dateColor}; font-weight: 600;">
                    ${emailScore.dateScore >= 15 ? '‚úì' : '‚úó'} ${escapeHtml(emailScore.dateText)}
                    <div style="font-size: 9px; opacity: 0.8;">+${emailScore.dateScore.toFixed(1)}%</div>
                </td>
                <td class="match-icon ${matchClass}" title="${emailScore.totalScore.toFixed(1)}% match">
                    ${matchIcon}<br>
                    <strong style="font-size: 13px;">${emailScore.totalScore.toFixed(0)}%</strong>
                </td>
            `;

            row.classList.add(matchClass);
        }

        /**
         * PHASE 1: Analyze email content for matches
         */
        async function analyzeEmailContent(match, transaction, txCompany, txAmount, txDate) {
            const subject = match.subject || '';
            const from = match.from || '';
            const snippet = match.snippet || '';
            const emailDate = match.date || '';

            // Combine email text for analysis
            const emailText = `${subject} ${from} ${snippet}`.toLowerCase();

            // Score company match
            const companyScore = scoreCompanyMatch(txCompany, emailText, from);

            // Score amount match
            const amountScore = scoreAmountMatch(txAmount, emailText);

            // Score date match
            const dateScore = scoreDateMatch(txDate, emailDate);

            // Overall email score
            const totalScore = companyScore + amountScore + dateScore;

            return {
                companyScore,
                companyText: getCompanyMatchText(companyScore),
                amountScore,
                amountText: getAmountMatchText(amountScore, txAmount, emailText),
                dateScore,
                dateText: getDateMatchText(dateScore, txDate, emailDate),
                totalScore: Math.round(totalScore * 10) / 10
            };
        }

        /**
         * Process single PDF through all phases (2-5)
         */
        async function processPDFInParallel(match, pdf, pdfGlobalIndex, transaction, transactionIndex) {
            const matchIndex = match.matchIndex || 0;
            const pdfIndex = match.pdfs.indexOf(pdf);
            const cellId = `pdf_${matchIndex}_${pdfIndex}_data`;

            console.log(`üìÑ [PDF-PROCESS] Starting PDF processing:`, {
                cellId,
                matchIndex,
                pdfIndex,
                filename: pdf.filename,
                messageId: match.messageId
            });

            try {
                // Find the account
                const account = gmailAccounts.find(acc => acc.email === match.accountEmail);
                if (!account || !account.accessToken) {
                    console.error(`‚ùå [PDF-PROCESS] No valid access token for ${match.accountEmail}`);
                    updatePDFStatus(cellId, '‚ùå No access token', '‚ùå');
                    return;
                }

                // PHASE 2: Download PDF
                console.log(`üì• [PDF-PROCESS] Downloading PDF: ${pdf.filename}`);
                updatePDFStatus(cellId, 'üì• Downloading...', '‚è≥');
                gapi.client.setToken({ access_token: account.accessToken });

                const attachResponse = await gapi.client.gmail.users.messages.attachments.get({
                    userId: 'me',
                    messageId: match.messageId,
                    id: pdf.attachmentId
                });

                const data = attachResponse.result.data;
                const pdfData = data.replace(/-/g, '+').replace(/_/g, '/');
                const pdfBlob = base64ToBlob(pdfData, 'application/pdf');
                console.log(`‚úÖ [PDF-PROCESS] Downloaded PDF: ${pdf.filename} (${pdfBlob.size} bytes)`);

                // PHASE 3: OCR Processing
                console.log(`üîç [PDF-PROCESS] Extracting text from PDF: ${pdf.filename}`);
                updatePDFStatus(cellId, 'üîç Extracting text...', '‚è≥');
                const ocrText = await extractTextFromPDF(pdfBlob);

                console.log(`üìù [PDF-PROCESS] Extracted text length: ${ocrText ? ocrText.length : 0}`);

                if (!ocrText || ocrText.trim().length < 20) {
                    console.warn(`‚ö†Ô∏è [PDF-PROCESS] No text extracted from ${pdf.filename}`);
                    updatePDFStatus(cellId, '‚ö†Ô∏è No text found', '‚ùå');
                    return;
                }

                // PHASE 4: AI Data Extraction
                console.log(`ü§ñ [PDF-PROCESS] Sending to AI for extraction: ${pdf.filename}`);
                updatePDFStatus(cellId, 'ü§ñ Analyzing with AI...', '‚è≥');
                const extractedData = await extractStructuredDataFromInvoice(ocrText, transaction);

                console.log(`üí° [PDF-PROCESS] AI extraction result:`, extractedData);

                if (!extractedData) {
                    console.warn(`‚ö†Ô∏è [PDF-PROCESS] No data extracted from ${pdf.filename}`);
                    updatePDFStatus(cellId, '‚ö†Ô∏è Could not extract data', '‚ùå');
                    return;
                }

                // PHASE 5: Validation & Scoring
                console.log(`‚úì [PDF-PROCESS] Validating data from ${pdf.filename}`);
                updatePDFStatus(cellId, '‚úì Validating...', '‚è≥');
                const validation = await validateInvoiceData(extractedData, transaction);

                // Calculate match score
                const txAmount = parseFloat((transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, ''));
                const txDate = parseTransactionDate(transaction.date);
                const txCompany = transaction.fromTo || transaction.description || 'Unknown';

                const pdfCompanyScore = scoreCompanyMatch(txCompany, extractedData.company, extractedData.company);
                const pdfAmountScore = scoreAmountMatchPrecise(txAmount, parseFloat(extractedData.amount || 0));
                const pdfDateScore = scoreDateMatchPrecise(txDate, parseTransactionDate(extractedData.date));

                const totalPDFScore = pdfCompanyScore + pdfAmountScore + pdfDateScore;

                console.log(`üéØ [PDF-PROCESS] Match scores for ${pdf.filename}:`, {
                    company: pdfCompanyScore,
                    amount: pdfAmountScore,
                    date: pdfDateScore,
                    total: totalPDFScore
                });

                // Update table with final results
                console.log(`üîß [PDF-PROCESS] Updating table cell: ${cellId}`);
                updatePDFTableRow(cellId, {
                    company: extractedData.company || 'Unknown',
                    companyScore: pdfCompanyScore,
                    amount: extractedData.amount || '0',
                    amountScore: pdfAmountScore,
                    date: extractedData.date || 'Unknown',
                    dateScore: pdfDateScore,
                    totalScore: Math.round(totalPDFScore * 10) / 10,
                    validation
                });

                console.log(`‚úÖ [PDF-PROCESS] Completed processing ${pdf.filename}`);

                // Return score for batch tracking
                return {
                    totalScore: Math.round(totalPDFScore * 10) / 10,
                    company: extractedData.company || 'Unknown',
                    amount: extractedData.amount || '0',
                    date: extractedData.date || 'Unknown'
                };

            } catch (error) {
                console.error(`‚ùå [PDF-PROCESS] Error processing PDF ${pdf.filename}:`, error);
                console.error(`‚ùå [PDF-PROCESS] Error stack:`, error.stack);
                const errorMsg = error.message || error.toString() || 'Unknown error';
                updatePDFStatus(cellId, `‚ùå Error: ${errorMsg}`, '‚ùå');
                return null;
            }
        }

        /**
         * Update PDF processing status in table
         */
        function updatePDFStatus(cellId, message, icon) {
            const row = document.getElementById(cellId);
            if (row) {
                row.innerHTML = `
                    <td class="row-label">PDF Invoice</td>
                    <td class="pending-cell" colspan="3">${escapeHtml(message)}</td>
                    <td class="match-icon">${icon}</td>
                `;
            }
        }

        /**
         * Update PDF table row with final analysis
         */
        function updatePDFTableRow(cellId, data) {
            const row = document.getElementById(cellId);
            if (!row) return;

            const companyColor = data.companyScore >= 25 ? '#059669' : (data.companyScore >= 15 ? '#f59e0b' : '#dc2626');
            const amountColor = data.amountScore >= 25 ? '#059669' : (data.amountScore >= 15 ? '#f59e0b' : '#dc2626');
            const dateColor = data.dateScore >= 25 ? '#059669' : (data.dateScore >= 15 ? '#f59e0b' : '#dc2626');

            let matchIcon, matchClass;
            if (data.totalScore >= 90) {
                matchIcon = 'üü¢';
                matchClass = 'match-perfect';
            } else if (data.totalScore >= 70) {
                matchIcon = 'üü°';
                matchClass = 'match-good';
            } else if (data.totalScore >= 50) {
                matchIcon = 'üü†';
                matchClass = 'match-possible';
            } else {
                matchIcon = 'üî¥';
                matchClass = 'match-weak';
            }

            row.innerHTML = `
                <td class="row-label">PDF Invoice</td>
                <td style="color: ${companyColor}; font-weight: 600;">
                    ${data.companyScore >= 25 ? '‚úì' : '‚úó'} ${escapeHtml(data.company)}
                    <div style="font-size: 9px; opacity: 0.8;">+${data.companyScore.toFixed(1)}%</div>
                </td>
                <td style="color: ${amountColor}; font-weight: 600;">
                    ${data.amountScore >= 25 ? '‚úì' : '‚úó'} ¬£${data.amount}
                    <div style="font-size: 9px; opacity: 0.8;">+${data.amountScore.toFixed(1)}%</div>
                </td>
                <td style="color: ${dateColor}; font-weight: 600;">
                    ${data.dateScore >= 25 ? '‚úì' : '‚úó'} ${escapeHtml(data.date)}
                    <div style="font-size: 9px; opacity: 0.8;">+${data.dateScore.toFixed(1)}%</div>
                </td>
                <td class="match-icon ${matchClass}" title="${data.totalScore.toFixed(1)}% match">
                    ${matchIcon}<br>
                    <strong style="font-size: 13px;">${data.totalScore.toFixed(0)}%</strong>
                </td>
            `;

            // Add color classes
            row.classList.add(matchClass);
        }

        // ========================================
        // MATCH SCORING ALGORITHMS
        // ========================================

        /**
         * Normalize company name by removing punctuation and spaces
         * Examples: "car-y-mor" ‚Üí "carymor", "ABC Ltd." ‚Üí "abcltd"
         */
        function normalizeCompanyName(name) {
            return name
                .toLowerCase()
                .trim()
                .replace(/[^a-z0-9]/g, ''); // Remove all non-alphanumeric characters
        }

        /**
         * Score company name match (33.3% max)
         */
        function scoreCompanyMatch(txCompany, emailText, extractedCompany) {
            const tx = txCompany.toLowerCase().trim();
            const text = emailText.toLowerCase();
            const extracted = extractedCompany ? extractedCompany.toLowerCase().trim() : '';

            // Perfect match (exact)
            if (extracted && extracted === tx) return 33.3;

            // ENHANCED: Normalized match (handles "carymor" vs "car-y-mor")
            const txNormalized = normalizeCompanyName(tx);
            const extractedNormalized = normalizeCompanyName(extracted);

            if (extractedNormalized && txNormalized === extractedNormalized) {
                console.log(`üéØ [MATCH] Normalized match: "${tx}" ‚âà "${extracted}" ‚Üí 95%`);
                return 31.5; // 95% of 33.3 = ~31.5
            }

            // Check if normalized versions are very similar (one contains the other)
            if (extractedNormalized && txNormalized.length >= 4 && extractedNormalized.length >= 4) {
                if (extractedNormalized.includes(txNormalized) || txNormalized.includes(extractedNormalized)) {
                    const lengthRatio = Math.min(txNormalized.length, extractedNormalized.length) /
                                       Math.max(txNormalized.length, extractedNormalized.length);
                    if (lengthRatio >= 0.8) {
                        console.log(`üéØ [MATCH] Normalized substring: "${tx}" ‚âà "${extracted}" ‚Üí 90%`);
                        return 30.0; // 90%
                    }
                }
            }

            // Calculate Levenshtein similarity on normalized strings
            const normalizedSimilarity = calculateStringSimilarity(txNormalized, extractedNormalized || normalizeCompanyName(text));

            if (normalizedSimilarity >= 0.95) return 33.3;
            if (normalizedSimilarity >= 0.90) return 30.0;
            if (normalizedSimilarity >= 0.80) return 25.0;

            // Fallback to original Levenshtein similarity
            const similarity = calculateStringSimilarity(tx, extracted || text);

            if (similarity >= 0.90) return 30.0;
            if (similarity >= 0.80) return 25.0;
            if (similarity >= 0.60) return 18.0;
            if (similarity >= 0.40) return 10.0;

            // Domain match
            if (text.includes(tx) || text.includes(txNormalized)) return 8.0;

            return 0;
        }

        /**
         * Score amount match from email text (33.3% max)
         */
        function scoreAmountMatch(txAmount, emailText) {
            // Search for amount in various formats
            const amountPatterns = [
                new RegExp(`¬£${txAmount.toFixed(2)}`, 'i'),
                new RegExp(`${txAmount.toFixed(2)}`, 'i'),
                new RegExp(`¬£${Math.floor(txAmount)}`, 'i'),
                new RegExp(`${Math.floor(txAmount)}`, 'i')
            ];

            for (const pattern of amountPatterns) {
                if (pattern.test(emailText)) {
                    return 33.3; // Found exact amount in email
                }
            }

            return 0; // Amount not found in email
        }

        /**
         * Score amount match with precise comparison (33.3% max)
         */
        function scoreAmountMatchPrecise(txAmount, invoiceAmount) {
            if (!invoiceAmount || isNaN(invoiceAmount)) return 0;

            const difference = Math.abs(txAmount - invoiceAmount);
            const percentOff = (difference / txAmount) * 100;

            if (difference === 0) return 33.3;
            if (difference < 0.50) return 32.0;
            if (percentOff < 1.0) return 30.0;
            if (percentOff < 2.0) return 27.0;
            if (percentOff < 5.0) return 22.0;
            if (percentOff < 10.0) return 15.0;
            if (percentOff < 20.0) return 8.0;

            return 0;
        }

        /**
         * Score date match (33.3% max)
         */
        function scoreDateMatch(txDate, emailDateStr) {
            if (!emailDateStr) return 0;

            try {
                const emailDate = new Date(emailDateStr);
                const daysDiff = Math.abs(Math.floor((emailDate - txDate) / (1000 * 60 * 60 * 24)));

                return scoreDateMatchPrecise(txDate, emailDate);
            } catch (error) {
                return 0;
            }
        }

        /**
         * Score date match with precise comparison (33.3% max)
         */
        function scoreDateMatchPrecise(txDate, invoiceDate) {
            if (!invoiceDate) return 0;

            const daysDiff = Math.abs(Math.floor((invoiceDate - txDate) / (1000 * 60 * 60 * 24)));

            if (daysDiff === 0) return 33.3;
            if (daysDiff === 1) return 32.0;
            if (daysDiff === 2) return 30.0;
            if (daysDiff === 3) return 27.0;
            if (daysDiff <= 5) return 22.0;
            if (daysDiff <= 7) return 18.0;
            if (daysDiff <= 10) return 13.0;
            if (daysDiff <= 14) return 8.0;
            if (daysDiff <= 21) return 4.0;

            return 0;
        }

        /**
         * Calculate string similarity (Levenshtein distance)
         */
        function calculateStringSimilarity(str1, str2) {
            const s1 = str1.toLowerCase();
            const s2 = str2.toLowerCase();

            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }

            const maxLength = Math.max(s1.length, s2.length);
            return maxLength === 0 ? 1.0 : (maxLength - costs[s2.length]) / maxLength;
        }

        /**
         * Get human-readable company match text
         */
        function getCompanyMatchText(score) {
            if (score >= 30) return '‚úì Perfect match';
            if (score >= 25) return '‚úì High similarity';
            if (score >= 18) return '~ Good similarity';
            if (score >= 10) return '~ Partial match';
            if (score >= 8) return '~ Domain match';
            return '‚úó No match';
        }

        /**
         * Get human-readable amount match text
         */
        function getAmountMatchText(score, txAmount, emailText) {
            if (score >= 30) return `‚úì ¬£${txAmount.toFixed(2)} found`;
            return '‚úó Not found in email';
        }

        /**
         * Get human-readable date match text
         */
        function getDateMatchText(score, txDate, emailDateStr) {
            if (!emailDateStr) return '? Date unknown';

            try {
                const emailDate = new Date(emailDateStr);
                const daysDiff = Math.abs(Math.floor((emailDate - txDate) / (1000 * 60 * 60 * 24)));

                if (daysDiff === 0) return '‚úì Same day';
                if (daysDiff === 1) return '‚úì 1 day off';
                if (daysDiff <= 3) return `‚úì ${daysDiff} days off`;
                if (daysDiff <= 7) return `~ ${daysDiff} days off`;
                if (daysDiff <= 14) return `‚ö† ${daysDiff} days off`;
                return `‚úó ${daysDiff} days off`;
            } catch (error) {
                return '? Date error';
            }
        }

        // ========================================
        // UI HELPER FUNCTIONS
        // ========================================

        /**
         * Show progress indicator
         */
        function showProgressIndicator(current, total, message) {
            let progressDiv = document.getElementById('pdfProcessingProgress');

            if (!progressDiv) {
                // Create progress div if doesn't exist
                const resultsContainer = document.getElementById('searchResultsContainer');
                if (resultsContainer) {
                    progressDiv = document.createElement('div');
                    progressDiv.id = 'pdfProcessingProgress';
                    resultsContainer.insertBefore(progressDiv, resultsContainer.firstChild);
                } else {
                    return;
                }
            }

            const percent = total > 0 ? Math.round((current / total) * 100) : 0;

            progressDiv.innerHTML = `
                <div style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #0ea5e9;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600; color: #0369a1; font-size: 13px;">üîÑ ${escapeHtml(message)}</span>
                        <span style="color: #0369a1; font-size: 12px; font-weight: 600;">${current}/${total}</span>
                    </div>
                    <div style="background: #e0f2fe; border-radius: 999px; height: 8px; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #0ea5e9, #0369a1); height: 100%; width: ${percent}%; transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
        }

        /**
         * Hide progress indicator
         */
        function hideProgressIndicator() {
            const progressDiv = document.getElementById('pdfProcessingProgress');
            if (progressDiv) {
                progressDiv.remove();
            }
        }

        /**
         * Show no matches message
         */
        function showNoMatchesMessage() {
            const progressDiv = document.getElementById('pdfProcessingProgress');
            if (progressDiv) {
                progressDiv.innerHTML = `
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #f59e0b;">
                        <div style="font-weight: 600; color: #92400e; font-size: 13px;">‚ÑπÔ∏è No emails meet the match threshold</div>
                        <div style="color: #78350f; font-size: 11px; margin-top: 4px;">All emails scored 0%. PDFs will not be processed automatically.</div>
                    </div>
                `;
            }
        }

        /**
         * Show early exit notification
         */
        function showEarlyExitNotification(score, email) {
            const progressDiv = document.getElementById('pdfProcessingProgress');
            if (progressDiv) {
                const subject = email ? email.subject.substring(0, 50) : 'Unknown';
                progressDiv.innerHTML = `
                    <div style="background: #d1fae5; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #059669;">
                        <div style="font-weight: 600; color: #065f46; font-size: 13px;">üéØ Perfect match found! (${score}%)</div>
                        <div style="color: #047857; font-size: 11px; margin-top: 4px;">Stopped processing remaining PDFs. Email: "${escapeHtml(subject)}..."</div>
                    </div>
                `;

                setTimeout(() => {
                    hideProgressIndicator();
                }, 5000);
            }
        }

        /**
         * Re-order result cards by highest score (email or PDF)
         * Moves best matches to the top of the list
         */
        function reorderResultsByScore(emailMatches) {
            console.log('üîÑ [REORDER] Starting result re-ordering...');

            const resultsContainer = document.getElementById('searchResultsContainer');
            if (!resultsContainer) {
                console.warn('‚ö†Ô∏è [REORDER] Results container not found');
                return;
            }

            // Find all result cards
            const cards = Array.from(resultsContainer.querySelectorAll('.invoice-result-card'));
            if (cards.length === 0) {
                console.warn('‚ö†Ô∏è [REORDER] No result cards found');
                return;
            }

            // Build scoring data for each card
            const cardScores = cards.map((card, cardIdx) => {
                const match = emailMatches[cardIdx];
                if (!match) return { card, score: 0, cardIdx };

                // Get max score from email or PDFs
                let maxScore = match.emailScore ? match.emailScore.totalScore : 0;

                // Check if any PDF has been processed and has a higher score
                if (match.pdfScore !== undefined && match.pdfScore > maxScore) {
                    maxScore = match.pdfScore;
                }

                console.log(`üìä [REORDER] Card ${cardIdx}: "${match.subject.substring(0, 30)}..." ‚Üí Score: ${maxScore.toFixed(1)}%`);
                return { card, score: maxScore, cardIdx, match };
            });

            // Sort by score (highest first)
            const sortedCards = cardScores.sort((a, b) => b.score - a.score);

            // Check if order actually changed
            const orderChanged = sortedCards.some((item, idx) => item.cardIdx !== idx);

            if (!orderChanged) {
                console.log('‚úÖ [REORDER] Cards already in correct order');
                return;
            }

            console.log('üîÑ [REORDER] Re-ordering cards...');
            console.log('üìä [REORDER] New order:', sortedCards.map(s => `${s.cardIdx}(${s.score.toFixed(0)}%)`).join(' ‚Üí '));

            // Find the header div (the "Found X email(s)" text)
            const headerDiv = Array.from(resultsContainer.children).find(child =>
                child.textContent && child.textContent.includes('Found')
            );

            // Re-append cards in new order (after the header)
            sortedCards.forEach(({ card }) => {
                resultsContainer.appendChild(card);
            });

            // Ensure header stays at top
            if (headerDiv) {
                resultsContainer.insertBefore(headerDiv, resultsContainer.firstChild);
            }

            // Add visual feedback for top result
            if (sortedCards[0].score >= AUTO_PROCESS_SETTINGS.minEmailMatchThreshold) {
                sortedCards[0].card.style.animation = 'pulse 1s ease-in-out';
                sortedCards[0].card.style.border = '2px solid #10b981';
                sortedCards[0].card.style.boxShadow = '0 4px 12px rgba(16, 185, 129, 0.3)';

                setTimeout(() => {
                    sortedCards[0].card.style.animation = '';
                }, 1000);
            }

            console.log('‚úÖ [REORDER] Re-ordering complete!');
        }

        /**
         * Toggle queue manager panel
         */
        function toggleQueuePanel() {
            const panel = document.getElementById('queueManagerPanel');
            if (!panel) return;

            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                invoiceSearchQueue.renderQueuePanel();
            } else {
                panel.style.display = 'none';
            }
        }

        /**
         * Get list of checked Gmail accounts for search (dynamically during search)
         */
        function getCheckedSearchAccounts() {
            const checkedAccounts = [];
            const now = Date.now();

            gmailAccounts.forEach((account, index) => {
                const checkbox = document.getElementById(`searchAccount_${index}`);
                if (checkbox && checkbox.checked) {
                    // Validate that account has a valid access token
                    const hasValidToken = account.accessToken &&
                                         (!account.tokenExpiresAt || account.tokenExpiresAt > now);

                    if (hasValidToken) {
                        checkedAccounts.push(account);
                    } else {
                        console.warn(`‚ö†Ô∏è [SEARCH] Skipping Account ${index + 1} - no valid token`);
                        searchLogger.logProgress(`‚ö†Ô∏è Skipping Account ${index + 1} - token expired or missing`, 'warning');
                    }
                }
            });

            return checkedAccounts;
        }

        async function connectGmailFromSearch() {
            searchLogger.logProgress('Connecting to Gmail...', 'info');
            try {
                await signInToGmail();
                // Wait for auth to complete
                await new Promise(resolve => setTimeout(resolve, 1500));

                if (gmailAccounts.length > 0) {
                    searchLogger.logProgress('‚úÖ Gmail connected successfully!', 'success');
                    searchLogger.logProgress('Restarting search...', 'info');
                    // Restart the search
                    const modal = document.getElementById('intelligentSearchModal');
                    const txIndex = currentInvoiceSearchIndex; // Should be set from handleInvoiceFetch
                    const transaction = allTransactions[txIndex];
                    executeIntelligentSearch(transaction, txIndex);
                } else {
                    searchLogger.logProgress('‚ùå Failed to connect Gmail', 'error');
                }
            } catch (error) {
                searchLogger.logProgress(`‚ùå Connection error: ${error.message}`, 'error');
            }
        }

        function updateSearchProgress(percent, text) {
            const bar = document.getElementById('searchProgressBar');
            const fill = document.getElementById('searchProgressFill');
            const progressText = document.getElementById('searchProgressText');

            bar.style.display = 'block';
            fill.style.width = percent + '%';
            progressText.textContent = text;
        }

        // ========================================
        // PROGRESSIVE SEARCH ENGINE
        // ========================================

        const SEARCH_STAGES = [
            {
                stage: 1,
                name: "Initial Search",
                dateWindow: 5,
                autoExecute: true,
                description: "Searching ¬±5 days from transaction date"
            },
            {
                stage: 2,
                name: "Extended Search",
                dateWindow: 10,
                autoExecute: true,
                description: "Searching ¬±10 days from transaction date"
            }
        ];

        async function executeIntelligentSearch(transaction, transactionIndex) {
            try {
                // Check if Gmail is connected
                if (gmailAccounts.length === 0) {
                    searchLogger.logProgress('‚ùå Gmail not connected!', 'error');
                    const resultsContainer = document.getElementById('searchResultsContainer');
                    resultsContainer.style.display = 'block';
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; padding: 30px; background: #fef3c7; border-radius: 8px; border: 2px solid #f59e0b;">
                            <div style="font-size: 48px; margin-bottom: 15px;">üìß</div>
                            <h4 style="margin: 0 0 10px 0; color: #92400e;">Gmail Not Connected</h4>
                            <p style="color: #78350f; margin: 0 0 20px 0;">
                                You need to connect your Gmail account to search for invoices.
                            </p>
                            <button onclick="connectGmailFromSearch()" class="btn-primary" style="margin-right: 10px;">
                                Connect Gmail Now
                            </button>
                            <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                Cancel
                            </button>
                        </div>
                    `;
                    return;
                }

                // Get checked accounts (with valid tokens)
                const checkedAccounts = getCheckedSearchAccounts();
                if (checkedAccounts.length === 0) {
                    // Check if user has accounts but they all have expired tokens
                    const hasAccountsWithoutTokens = gmailAccounts.some(acc => {
                        const checkbox = document.getElementById(`searchAccount_${gmailAccounts.indexOf(acc)}`);
                        return checkbox && checkbox.checked && !acc.accessToken;
                    });

                    const errorMessage = hasAccountsWithoutTokens
                        ? 'Your Gmail account tokens have expired. Please re-authenticate to search for invoices.'
                        : 'Please tick at least one Gmail account to search.';

                    searchLogger.logProgress('‚ùå No valid accounts available', 'error');
                    const resultsContainer = document.getElementById('searchResultsContainer');
                    resultsContainer.style.display = 'block';
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; padding: 30px; background: #fef3c7; border-radius: 8px; border: 2px solid #f59e0b;">
                            <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
                            <h4 style="margin: 0 0 10px 0; color: #92400e;">No Valid Accounts Available</h4>
                            <p style="color: #78350f; margin: 0 0 20px 0;">
                                ${errorMessage}
                            </p>
                            <div style="display: flex; gap: 10px; justify-content: center;">
                                ${hasAccountsWithoutTokens ? '<button onclick="connectGmailFromSearch()" class="btn-primary">Re-authenticate Gmail</button>' : ''}
                                <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                    Close
                                </button>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Log which account(s) will be searched
                if (checkedAccounts.length === gmailAccounts.length) {
                    searchLogger.logProgress(`üìß Searching in all ${gmailAccounts.length} connected account(s)`, 'success');
                } else {
                    const accountNames = checkedAccounts.map((acc, idx) => {
                        const accountNum = gmailAccounts.findIndex(a => a.email === acc.email) + 1;
                        return `Account ${accountNum}`;
                    }).join(', ');
                    searchLogger.logProgress(`üìß Searching in: ${accountNames}`, 'success');
                }

                // Step 1: Build context
                searchLogger.logProgress('Building search context...', 'info');
                const context = buildTransactionContext(transaction, transactionIndex);

                // Extract core keyword for human-like search
                const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
                searchLogger.logProgress(`Merchant: "${context.merchantName}"`, 'success');
                searchLogger.logProgress(`Search keyword: "${merchantKeyword}"`, 'success');
                searchLogger.logProgress(`Amount formats: ${context.amountFormats.length} variations`, 'success');

                // Step 2: AI merchant name interpretation (NEW!)
                updateSearchProgress(15, 'Interpreting merchant name with AI...');
                searchLogger.logAI('Analyzing merchant name...');

                const aiMerchantInfo = await interpretMerchantNameWithAI(context.merchantName);
                if (aiMerchantInfo) {
                    searchLogger.logProgress(`üéØ AI identified: "${aiMerchantInfo.companyName}"`, 'success');
                    searchLogger.logProgress(`üìß Likely domain: ${aiMerchantInfo.likelyDomain}`, 'success');
                    // Store in context for use in queries
                    context.aiMerchantInfo = aiMerchantInfo;
                }

                // Step 3: Optional AI keyword enhancement
                updateSearchProgress(20, 'Enhancing search with AI...');
                searchLogger.logAI('Generating smart search keywords...');

                const aiKeywords = await generateAISearchKeywords(context);
                if (aiKeywords) {
                    searchLogger.logProgress(`AI keywords: ${aiKeywords.join(', ')}`, 'success');
                }

                // Step 3: Progressive search stages
                for (let i = 0; i < SEARCH_STAGES.length; i++) {
                    const stage = SEARCH_STAGES[i];

                    // Ask user before non-auto stages
                    if (!stage.autoExecute && i > 0) {
                        const shouldContinue = await promptUserToContinueSearch(stage);
                        if (!shouldContinue) {
                            searchLogger.logProgress('Search cancelled by user', 'warning');
                            return;
                        }
                    }

                    searchLogger.logStage(stage.stage, `${stage.name} (¬±${stage.dateWindow} days)`);
                    updateSearchProgress(20 + (i * 25), `Stage ${stage.stage}: ${stage.description}`);

                    const results = await executeSearchStage(context, stage, aiKeywords);

                    searchLogger.logResults(results.length, stage.dateWindow);

                    if (results.length > 0) {
                        updateSearchProgress(70, 'Processing invoices...');
                        searchLogger.logProgress(`‚úÖ Found ${results.length} potential invoice(s)!`, 'success');
                        await displayIntelligentSearchResults(results, transaction, transactionIndex);
                        return;
                    }
                }

                // No results found
                searchLogger.logProgress('No invoices found in any search stage', 'warning');
                updateSearchProgress(100, 'Search complete - no results');

                // Show no results options with extend option
                showNoResultsOptions(context, transaction, transactionIndex);

            } catch (error) {
                console.error('Intelligent search error:', error);
                searchLogger.logProgress(`Error: ${error.message}`, 'error');
                showSimpleToast('Search error: ' + error.message, 'error');
            }
        }

        /**
         * Execute a single search stage
         */
        async function executeSearchStage(context, stage, aiKeywords) {
            const queries = buildStageQueries(context, stage, aiKeywords);
            const allResults = [];

            for (let i = 0; i < queries.length; i++) {
                const query = queries[i];
                searchLogger.logProgress(`${query.description}...`, 'info');
                console.log('üìß [Gmail Query]:', query.query);

                try {
                    // Get currently checked accounts (dynamically during search)
                    const accountsToSearch = getCheckedSearchAccounts();

                    if (accountsToSearch.length === 0) {
                        searchLogger.logProgress('  ‚ö†Ô∏è No accounts selected - search paused', 'warning');
                        continue;
                    }

                    // Search in checked Gmail account(s)
                    console.log(`üîÑ [SEARCH LOOP] Searching ${accountsToSearch.length} account(s) for query: "${query.query}"`);

                    for (const account of accountsToSearch) {
                        // Re-check if account is still checked before searching
                        const accountIndex = gmailAccounts.findIndex(a => a.email === account.email);
                        const checkbox = document.getElementById(`searchAccount_${accountIndex}`);

                        console.log(`üîç [SEARCH LOOP] Processing account ${accountIndex + 1}: ${account.email}`, {
                            hasCheckbox: !!checkbox,
                            isChecked: checkbox?.checked,
                            accountIndex,
                            hasAccessToken: !!account.accessToken
                        });

                        if (!checkbox || !checkbox.checked) {
                            searchLogger.logProgress(`  ‚è≠Ô∏è Skipping ${account.email} (unchecked)`, 'info');
                            console.log(`‚è≠Ô∏è [SEARCH LOOP] Skipped account ${accountIndex + 1} (unchecked)`);
                            continue;
                        }

                        const accountNum = accountIndex + 1;
                        console.log(`üîé [SEARCH LOOP] Calling searchGmailWithQuery for account ${accountNum}...`);

                        const messages = await searchGmailWithQuery(query.query, account, context.date, stage.dateWindow);

                        if (messages.length > 0) {
                            searchLogger.logProgress(`  ‚úÖ Found ${messages.length} email(s) in Account ${accountNum}`, 'success');
                            console.log(`‚úÖ [SEARCH LOOP] Account ${accountNum} returned ${messages.length} message(s)`);
                            allResults.push(...messages.map(m => ({
                                ...m,
                                accountEmail: account.email,
                                accountAccessToken: account.accessToken,
                                allowNonPDF: query.allowNonPDF || false
                            })));
                        } else {
                            searchLogger.logProgress(`  No results in Account ${accountNum}`, 'info');
                            console.log(`‚ö†Ô∏è [SEARCH LOOP] Account ${accountNum} returned 0 messages`);
                        }
                    }

                    console.log(`üìä [SEARCH LOOP] Completed query. Total results: ${allResults.length}`);
                } catch (error) {
                    searchLogger.logProgress(`  Query failed: ${error.message}`, 'error');
                    console.error('Gmail search error:', error);
                }
            }

            // Deduplicate by message ID
            const uniqueResults = deduplicateMessages(allResults);
            return uniqueResults;
        }

        /**
         * Build search queries for a stage (Human-like search approach)
         */
        function buildStageQueries(context, stage, aiKeywords) {
            const queries = [];

            // Extract core merchant keyword (e.g., "google" from "Card Purchase Google GSUITE pebl-cic")
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);

            // ========================================
            // AI-POWERED QUERIES (Highest Priority!)
            // ========================================

            if (context.aiMerchantInfo) {
                const ai = context.aiMerchantInfo;

                // Query AI-1: Direct domain search (MOST RELIABLE!)
                if (ai.likelyDomain) {
                    queries.push({
                        query: `from:@${ai.likelyDomain} (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                        description: `ü§ñ Searching emails from @${ai.likelyDomain}`,
                        weight: 1.2 // HIGHEST PRIORITY
                    });
                }

                // Query AI-2: Alternate domain searches
                if (ai.alternateDomains && ai.alternateDomains.length > 0) {
                    ai.alternateDomains.slice(0, 2).forEach(domain => {
                        queries.push({
                            query: `from:@${domain} (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                            description: `ü§ñ Searching emails from @${domain}`,
                            weight: 1.1
                        });
                    });
                }

                // Query AI-3: AI-interpreted company name
                if (ai.companyName && ai.companyName !== context.merchantName) {
                    queries.push({
                        query: `"${ai.companyName}" (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                        description: `ü§ñ Searching for AI-interpreted name "${ai.companyName}"`,
                        weight: 1.15
                    });
                }

                // Query AI-4: AI-provided search keywords
                if (ai.searchKeywords && ai.searchKeywords.length > 0 && stage.stage >= 2) {
                    const keywordOr = ai.searchKeywords.slice(0, 3).join(' OR ');
                    queries.push({
                        query: `(${keywordOr}) (invoice OR receipt) has:attachment filename:pdf`,
                        description: `ü§ñ Searching with AI keywords`,
                        weight: 1.0
                    });
                }
            }

            // ========================================
            // GOVERNMENT & SERVICE CONFIRMATION QUERIES (High Priority)
            // ========================================

            // Detect government services and similar providers that send confirmation emails
            const merchantLower = context.merchantName.toLowerCase();
            const isGovernmentService = merchantLower.includes('dvla') ||
                                       merchantLower.includes('hmrc') ||
                                       merchantLower.includes('gov.uk') ||
                                       merchantLower.includes('council') ||
                                       merchantLower.includes('passport');

            if (isGovernmentService) {
                // Query GOV-1: DVLA-specific search (highest priority for DVLA)
                if (merchantLower.includes('dvla')) {
                    queries.push({
                        query: `DVLA (confirmation OR confirmed OR "vehicle tax" OR "payment received")`,
                        description: `üèõÔ∏è Searching for DVLA confirmation emails`,
                        weight: 1.4, // Higher than AI queries for DVLA
                        allowNonPDF: true
                    });

                    // Query GOV-2: DVLA domain searches
                    queries.push({
                        query: `from:@dvla.gov.uk confirmation`,
                        description: `üèõÔ∏è Searching emails from @dvla.gov.uk`,
                        weight: 1.35,
                        allowNonPDF: true
                    });

                    queries.push({
                        query: `from:@notifications.service.gov.uk DVLA`,
                        description: `üèõÔ∏è Searching UK Gov notifications (DVLA)`,
                        weight: 1.3,
                        allowNonPDF: true
                    });
                }

                // Query GOV-3: HMRC-specific search
                if (merchantLower.includes('hmrc')) {
                    queries.push({
                        query: `HMRC (confirmation OR payment OR "tax paid")`,
                        description: `üèõÔ∏è Searching for HMRC confirmation emails`,
                        weight: 1.4,
                        allowNonPDF: true
                    });

                    queries.push({
                        query: `from:@hmrc.gov.uk`,
                        description: `üèõÔ∏è Searching emails from @hmrc.gov.uk`,
                        weight: 1.35,
                        allowNonPDF: true
                    });
                }

                // Query GOV-4: Generic gov.uk search
                if (merchantLower.includes('gov.uk') || merchantLower.includes('council')) {
                    queries.push({
                        query: `from:@gov.uk confirmation`,
                        description: `üèõÔ∏è Searching government emails (.gov.uk)`,
                        weight: 1.25,
                        allowNonPDF: true
                    });
                }

                // Query GOV-5: Broader government confirmation search with amount
                if (context.amountFormats.length > 0) {
                    const amountOr = context.amountFormats.slice(0, 2).map(a => `"${a}"`).join(' OR ');
                    queries.push({
                        query: `${merchantKeyword} confirmation (${amountOr})`,
                        description: `üèõÔ∏è Searching "${merchantKeyword}" confirmation + amount`,
                        weight: 1.2,
                        allowNonPDF: true
                    });
                }
            }

            // ========================================
            // TRADITIONAL QUERIES (Fallback)
            // ========================================

            // Query 1: Simple human-like search - merchant + invoice keywords
            if (merchantKeyword) {
                queries.push({
                    query: `${merchantKeyword} (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                    description: `Searching for "${merchantKeyword} invoice"`,
                    weight: 1.0
                });
            }

            // Query 2: Merchant + payment keywords (broader)
            if (merchantKeyword && stage.stage >= 2) {
                queries.push({
                    query: `${merchantKeyword} (payment OR bill OR statement) has:attachment filename:pdf`,
                    description: `Searching for "${merchantKeyword} payment/bill"`,
                    weight: 0.9
                });
            }

            // Query 3: Full merchant name search (if different from keyword)
            if (context.merchantName && context.merchantName !== merchantKeyword) {
                queries.push({
                    query: `"${context.merchantName}" invoice has:attachment`,
                    description: `Searching for exact merchant name`,
                    weight: 0.85
                });

                // Query 3b: Space-removed variations with domain extensions
                // Handles cases like "our sqk accountancy" -> "oursqkaccountancy.co.uk"
                const noSpacesName = context.merchantName.replace(/\s+/g, '').toLowerCase();
                const domainVariations = [
                    `${noSpacesName}.co.uk`,
                    `${noSpacesName}.com`,
                    `${noSpacesName}.org.uk`,
                    `${noSpacesName}.uk`,
                    noSpacesName // Also search without domain
                ];

                // Create OR query with all variations
                const domainOr = domainVariations.map(v => `"${v}"`).join(' OR ');
                queries.push({
                    query: `(${domainOr}) (invoice OR receipt OR "order confirmation") has:attachment filename:pdf`,
                    description: `Searching for "${noSpacesName}" with domain variations`,
                    weight: 0.9
                });
            }

            // Query 4: Amount-based search
            if (context.amountFormats.length > 0 && stage.stage >= 2) {
                const amountOr = context.amountFormats.slice(0, 3).map(a => `"${a}"`).join(' OR ');
                queries.push({
                    query: `${merchantKeyword} (${amountOr}) has:attachment`,
                    description: `Searching for "${merchantKeyword}" + amount`,
                    weight: 0.8
                });
            }

            // Query 5: AI keywords (if available)
            if (aiKeywords && aiKeywords.length > 0 && stage.stage >= 2) {
                // Use AI keywords with merchant name
                const topKeywords = aiKeywords.slice(0, 3).join(' OR ');
                queries.push({
                    query: `${merchantKeyword} (${topKeywords}) has:attachment filename:pdf`,
                    description: `Searching "${merchantKeyword}" + AI keywords`,
                    weight: 0.9
                });
            }

            // Query 6: User notes (if available) - High priority!
            if (context.userNotes && stage.stage >= 2) {
                const notesSnippet = context.userNotes.substring(0, 50).split(/[.!?]/)[0];
                queries.push({
                    query: `${merchantKeyword} "${notesSnippet}" has:attachment`,
                    description: `Searching "${merchantKeyword}" + your notes`,
                    weight: 0.95
                });
            }

            // Query 7: User context (if available)
            if (context.userContext && stage.stage >= 3) {
                queries.push({
                    query: `${merchantKeyword} "${context.userContext}" has:attachment`,
                    description: `Searching "${merchantKeyword}" + project assignments`,
                    weight: 0.85
                });
            }

            // Query 8: Fallback - just merchant name + attachment (Stage 3 only)
            if (stage.stage >= 3 && merchantKeyword) {
                queries.push({
                    query: `${merchantKeyword} has:attachment`,
                    description: `Wide search for "${merchantKeyword}" with any attachment`,
                    weight: 0.5
                });
            }

            // ========================================
            // SECONDARY QUERIES - Emails WITHOUT PDFs
            // (Lower priority, but can find relevant emails to open in Gmail)
            // ========================================

            // Only add non-PDF queries in stage 1 to avoid too much noise
            if (stage.stage === 1) {
                // Query NP-1: AI domain search without PDF filter
                if (context.aiMerchantInfo && context.aiMerchantInfo.likelyDomain) {
                    queries.push({
                        query: `from:@${context.aiMerchantInfo.likelyDomain} (invoice OR receipt OR payment OR "order confirmation")`,
                        description: `ü§ñ Searching emails from @${context.aiMerchantInfo.likelyDomain} (no PDF)`,
                        weight: 0.6
                    });
                }

                // Query NP-2: AI company name search without PDF filter
                if (context.aiMerchantInfo && context.aiMerchantInfo.companyName && context.aiMerchantInfo.companyName !== context.merchantName) {
                    queries.push({
                        query: `"${context.aiMerchantInfo.companyName}" (invoice OR receipt OR payment)`,
                        description: `ü§ñ Searching "${context.aiMerchantInfo.companyName}" (no PDF)`,
                        weight: 0.55
                    });
                }

                // Query NP-3: Merchant keyword + payment terms without PDF filter
                if (merchantKeyword) {
                    queries.push({
                        query: `${merchantKeyword} (invoice OR receipt OR payment OR bill)`,
                        description: `Searching "${merchantKeyword}" with payment terms (no PDF)`,
                        weight: 0.5
                    });
                }

                // Query NP-4: Subject line search (most reliable for non-PDF matches)
                if (merchantKeyword) {
                    queries.push({
                        query: `subject:(${merchantKeyword} (invoice OR receipt OR payment))`,
                        description: `Searching subject for "${merchantKeyword} invoice/payment" (no PDF)`,
                        weight: 0.55
                    });
                }
            }

            // Sort queries by weight (highest first) - AI queries will be tried first!
            queries.sort((a, b) => b.weight - a.weight);

            console.log('üìã [QUERIES] Built and sorted queries:', queries.map(q => ({
                desc: q.description,
                weight: q.weight,
                preview: q.query.substring(0, 80) + '...'
            })));

            return queries;
        }

        /**
         * Extract core merchant keyword (like a human would type)
         * "Card Purchase Google GSUITE pebl-cic" ‚Üí "google"
         * "Amazon UK" ‚Üí "amazon"
         */
        function extractCoreMerchantKeyword(merchantName) {
            if (!merchantName) return '';

            // Convert to lowercase for matching
            const lower = merchantName.toLowerCase();

            // Common merchant keywords to extract
            const knownMerchants = [
                'amazon', 'google', 'microsoft', 'apple', 'paypal', 'stripe',
                'tesco', 'sainsbury', 'asda', 'morrisons', 'waitrose',
                'edf', 'british gas', 'thames water', 'vodafone', 'bt', 'sky',
                'spotify', 'netflix', 'adobe', 'dropbox', 'zoom',
                'uber', 'deliveroo', 'just eat'
            ];

            // Check if any known merchant appears in the name
            for (const merchant of knownMerchants) {
                if (lower.includes(merchant)) {
                    return merchant;
                }
            }

            // If no known merchant, extract first meaningful word
            const words = merchantName.split(/\s+/);
            for (const word of words) {
                // Skip common words
                if (word.length > 3 && !['card', 'payment', 'purchase'].includes(word.toLowerCase())) {
                    return word.toLowerCase();
                }
            }

            // Fallback: return cleaned merchant name
            return merchantName.toLowerCase();
        }

        /**
         * Extract email body content from Gmail message structure
         * Handles multipart messages and returns HTML or plain text
         */
        function extractEmailBody(emailMessage) {
            if (!emailMessage || !emailMessage.payload) {
                return '';
            }

            const payload = emailMessage.payload;

            // Helper function to decode base64url
            const decodeBase64 = (str) => {
                if (!str) return '';
                try {
                    // Replace URL-safe chars and decode
                    const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
                    return decodeURIComponent(escape(atob(base64)));
                } catch (e) {
                    console.error('Failed to decode base64:', e);
                    return '';
                }
            };

            // Check if body is directly in payload
            if (payload.body && payload.body.data) {
                return decodeBase64(payload.body.data);
            }

            // Check parts (multipart message)
            if (payload.parts && payload.parts.length > 0) {
                // Try to find HTML part first
                let htmlPart = payload.parts.find(part => part.mimeType === 'text/html');
                if (htmlPart && htmlPart.body && htmlPart.body.data) {
                    return decodeBase64(htmlPart.body.data);
                }

                // Fall back to plain text
                let textPart = payload.parts.find(part => part.mimeType === 'text/plain');
                if (textPart && textPart.body && textPart.body.data) {
                    return decodeBase64(textPart.body.data);
                }

                // Check nested parts (some emails have nested multipart structure)
                for (const part of payload.parts) {
                    if (part.parts && part.parts.length > 0) {
                        let nestedHtml = part.parts.find(p => p.mimeType === 'text/html');
                        if (nestedHtml && nestedHtml.body && nestedHtml.body.data) {
                            return decodeBase64(nestedHtml.body.data);
                        }

                        let nestedText = part.parts.find(p => p.mimeType === 'text/plain');
                        if (nestedText && nestedText.body && nestedText.body.data) {
                            return decodeBase64(nestedText.body.data);
                        }
                    }
                }
            }

            return '';
        }

        /**
         * Strip HTML tags and convert to plain text
         * Preserves line breaks and basic formatting
         */
        function stripHtmlTags(html) {
            if (!html) return '';

            // Create temporary div to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // Replace <br> and <p> with line breaks before stripping
            temp.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
            temp.querySelectorAll('p').forEach(p => {
                const text = p.textContent;
                p.replaceWith(text + '\n\n');
            });

            // Get text content
            let text = temp.textContent || temp.innerText || '';

            // Clean up excessive whitespace
            text = text.replace(/\n{3,}/g, '\n\n'); // Max 2 consecutive newlines
            text = text.replace(/[ \t]+/g, ' '); // Replace multiple spaces with single space
            text = text.trim();

            return text;
        }

        /**
         * Detect confirmation email type and return metadata for better formatting
         */
        function detectConfirmationEmailType(subject, body, fromAddress) {
            const subjectLower = (subject || '').toLowerCase();
            const bodyLower = (body || '').toLowerCase();
            const fromLower = (fromAddress || '').toLowerCase();

            const types = {
                dvla: {
                    name: 'DVLA Vehicle Tax',
                    icon: 'üöó',
                    keywords: ['dvla', 'vehicle tax', 'vehicle licensing']
                },
                hmrc: {
                    name: 'HMRC Tax Payment',
                    icon: 'üí∑',
                    keywords: ['hmrc', 'tax', 'self assessment']
                },
                council: {
                    name: 'Council Tax',
                    icon: 'üèõÔ∏è',
                    keywords: ['council tax', 'council payment']
                },
                passport: {
                    name: 'Passport Service',
                    icon: 'üõÇ',
                    keywords: ['passport', 'home office']
                },
                utility: {
                    name: 'Utility Payment',
                    icon: '‚ö°',
                    keywords: ['energy', 'water', 'gas', 'electric']
                },
                generic: {
                    name: 'Payment Confirmation',
                    icon: '‚úâÔ∏è',
                    keywords: ['confirmation', 'payment', 'receipt']
                }
            };

            // Check each type
            for (const [key, type] of Object.entries(types)) {
                if (key === 'generic') continue; // Check generic last

                for (const keyword of type.keywords) {
                    if (subjectLower.includes(keyword) || bodyLower.includes(keyword) || fromLower.includes(keyword)) {
                        return type;
                    }
                }
            }

            return types.generic;
        }

        /**
         * Convert email to PDF document
         * Creates a formatted PDF from email content when no PDF attachment exists
         */
        async function convertEmailToPDF(emailMessage) {
            try {
                console.log('üìÑ [EMAIL-TO-PDF] Starting conversion...');

                // Check if jsPDF is available
                if (typeof window.jspdf === 'undefined') {
                    console.error('‚ùå [EMAIL-TO-PDF] jsPDF library not loaded');
                    throw new Error('jsPDF library not available');
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Extract email headers
                const headers = emailMessage.payload.headers;
                const from = headers.find(h => h.name === 'From')?.value || 'Unknown Sender';
                const to = headers.find(h => h.name === 'To')?.value || '';
                const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                const date = headers.find(h => h.name === 'Date')?.value || '';

                // Extract and process email body
                const bodyHtml = extractEmailBody(emailMessage);
                const bodyText = stripHtmlTags(bodyHtml);

                // Detect email type for better formatting
                const emailType = detectConfirmationEmailType(subject, bodyText, from);

                // PDF Styling
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 20;
                const contentWidth = pageWidth - (2 * margin);
                let yPosition = 20;

                // Header Section - Email Type Badge
                doc.setFillColor(58, 175, 169); // PEBL brand color
                doc.rect(0, 0, pageWidth, 15, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(11);
                doc.setFont('helvetica', 'bold');
                doc.text(`${emailType.icon} ${emailType.name}`, margin, 10);

                // Reset text color
                doc.setTextColor(0, 0, 0);
                yPosition = 25;

                // Email Metadata Section
                doc.setFontSize(9);
                doc.setTextColor(100, 100, 100);
                doc.setFont('helvetica', 'normal');

                // From
                doc.text('From:', margin, yPosition);
                doc.setFont('helvetica', 'bold');
                const fromText = doc.splitTextToSize(from, contentWidth - 30);
                doc.text(fromText, margin + 25, yPosition);
                yPosition += (fromText.length * 4) + 3;

                // To
                if (to) {
                    doc.setFont('helvetica', 'normal');
                    doc.text('To:', margin, yPosition);
                    doc.setFont('helvetica', 'bold');
                    const toText = doc.splitTextToSize(to, contentWidth - 30);
                    doc.text(toText, margin + 25, yPosition);
                    yPosition += (toText.length * 4) + 3;
                }

                // Date
                doc.setFont('helvetica', 'normal');
                doc.text('Date:', margin, yPosition);
                doc.setFont('helvetica', 'bold');
                doc.text(date, margin + 25, yPosition);
                yPosition += 7;

                // Subject
                doc.setFontSize(11);
                doc.setTextColor(0, 0, 0);
                doc.setFont('helvetica', 'normal');
                doc.text('Subject:', margin, yPosition);
                doc.setFont('helvetica', 'bold');
                const subjectLines = doc.splitTextToSize(subject, contentWidth - 30);
                doc.text(subjectLines, margin + 25, yPosition);
                yPosition += (subjectLines.length * 5) + 5;

                // Separator line
                doc.setDrawColor(200, 200, 200);
                doc.setLineWidth(0.5);
                doc.line(margin, yPosition, pageWidth - margin, yPosition);
                yPosition += 8;

                // Email Body
                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                doc.setFont('helvetica', 'normal');

                // Split body text to fit page width
                const bodyLines = doc.splitTextToSize(bodyText, contentWidth);

                // Add body text with pagination
                for (let i = 0; i < bodyLines.length; i++) {
                    // Check if we need a new page
                    if (yPosition > pageHeight - 30) {
                        doc.addPage();
                        yPosition = 20;
                    }

                    doc.text(bodyLines[i], margin, yPosition);
                    yPosition += 5;
                }

                // Footer on last page
                const footerY = pageHeight - 15;
                doc.setFontSize(8);
                doc.setTextColor(150, 150, 150);
                doc.setFont('helvetica', 'italic');
                const footerText = 'Generated from email by PEBLGen Invoice Search';
                const footerWidth = doc.getTextWidth(footerText);
                doc.text(footerText, (pageWidth - footerWidth) / 2, footerY);

                const generatedDate = new Date().toLocaleString('en-GB', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                doc.text(generatedDate, (pageWidth - doc.getTextWidth(generatedDate)) / 2, footerY + 4);

                // Generate PDF blob
                const pdfBlob = doc.output('blob');
                console.log('‚úÖ [EMAIL-TO-PDF] Conversion successful, size:', pdfBlob.size, 'bytes');

                return pdfBlob;

            } catch (error) {
                console.error('‚ùå [EMAIL-TO-PDF] Conversion failed:', error);
                throw error;
            }
        }

        /**
         * Search Gmail with date window
         */
        async function searchGmailWithQuery(query, account, transactionDate, dateWindowDays) {
            try {
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('üîç [GMAIL SEARCH START]');
                console.log('   Account:', account.email);
                console.log('   Has access token:', !!account.accessToken);
                console.log('   Token preview:', account.accessToken ? account.accessToken.substring(0, 20) + '...' : 'MISSING');
                console.log('   Query:', query);
                console.log('   Date window:', `¬±${dateWindowDays} days`);
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

                // Check if Gmail API is available
                if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.gmail) {
                    console.error('‚ùå [GMAIL SEARCH] Gmail API not initialized');
                    throw new Error('Gmail API not initialized');
                }
                console.log('‚úÖ [GMAIL SEARCH] Gmail API is available');

                // Set the access token for this account
                if (!account || !account.accessToken) {
                    console.error('‚ùå [GMAIL SEARCH] No valid access token for account');
                    throw new Error('No valid access token for account');
                }

                gapi.client.setToken({ access_token: account.accessToken });
                console.log('‚úÖ [GMAIL SEARCH] Set access token for:', account.email);

                // Calculate date range
                const startDate = new Date(transactionDate);
                startDate.setDate(startDate.getDate() - dateWindowDays);

                const endDate = new Date(transactionDate);
                endDate.setDate(endDate.getDate() + dateWindowDays);

                // Format dates for Gmail (YYYY/MM/DD)
                const formatDate = (d) => {
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}/${month}/${day}`;
                };

                const dateQuery = `after:${formatDate(startDate)} before:${formatDate(endDate)}`;
                const fullQuery = `${query} ${dateQuery}`;

                console.log('üìÖ [GMAIL SEARCH] Date range:', formatDate(startDate), 'to', formatDate(endDate));
                console.log('üîé [GMAIL SEARCH] Full Gmail query:', fullQuery);

                // Execute Gmail search
                console.log('‚è≥ [GMAIL SEARCH] Calling Gmail API...');
                const response = await gapi.client.gmail.users.messages.list({
                    userId: 'me',
                    q: fullQuery,
                    maxResults: 10
                });

                console.log('üì¶ [GMAIL SEARCH] Gmail API response received:', {
                    hasResult: !!response.result,
                    hasMessages: !!response.result?.messages,
                    messageCount: response.result?.messages?.length || 0,
                    resultSizeEstimate: response.result?.resultSizeEstimate
                });

                if (!response || !response.result) {
                    console.error('‚ùå [GMAIL SEARCH] Invalid Gmail API response:', response);
                    return [];
                }

                if (!response.result.messages) {
                    console.log('‚ö†Ô∏è [GMAIL SEARCH] No messages found in response');
                    console.log('   Result object:', response.result);
                    return [];
                }

                console.log(`‚úÖ [GMAIL SEARCH] Found ${response.result.messages.length} message(s) for ${account.email}`);
                console.log('   Message IDs:', response.result.messages.map(m => m.id).join(', '));
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

                return response.result.messages;

            } catch (error) {
                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.error('‚ùå [GMAIL SEARCH ERROR]');
                console.error('   Account:', account.email);
                console.error('   Error type:', error.name || 'Unknown');
                console.error('   Error message:', error.message);
                console.error('   Status:', error.status || error.result?.error?.status || 'N/A');
                console.error('   Full error object:', error);
                console.error('   Error result:', error.result);
                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

                const errorMsg = error.message || error.result?.error?.message || 'Unknown error';
                throw new Error(`Gmail search failed: ${errorMsg}`);
            }
        }

        /**
         * Deduplicate messages by ID
         */
        function deduplicateMessages(messages) {
            const seen = new Set();
            return messages.filter(msg => {
                const key = `${msg.id}_${msg.accountEmail}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        /**
         * Prompt user to continue to next search stage
         */
        async function promptUserToContinueSearch(stage) {
            return new Promise((resolve) => {
                const btnHtml = `
                    <div id="continueSearchPrompt" style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <p style="margin: 0 0 10px 0; font-weight: 500;">No invoices found. Continue searching?</p>
                        <p style="margin: 0 0 15px 0; font-size: 14px; color: #92400e;">
                            ${stage.description}
                        </p>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="continueSearchResponse(true)" class="btn-primary" style="flex: 1;">
                                Continue to Stage ${stage.stage}
                            </button>
                            <button onclick="continueSearchResponse(false)" class="btn-secondary" style="flex: 1;">
                                Stop Searching
                            </button>
                        </div>
                    </div>
                `;

                document.getElementById('searchActionButtons').insertAdjacentHTML('beforebegin', btnHtml);

                window.continueSearchResponse = (response) => {
                    const prompt = document.getElementById('continueSearchPrompt');
                    if (prompt) prompt.remove();
                    delete window.continueSearchResponse;
                    resolve(response);
                };
            });
        }

        /**
         * Display search results
         */
        async function displayIntelligentSearchResults(messages, transaction, transactionIndex) {
            console.log('üìä [RESULTS] Displaying', messages.length, 'invoice matches');
            searchLogger.logProgress(`Analyzing and scoring ${messages.length} invoice(s)...`, 'info');

            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.style.display = 'block';

            // Get transaction context for scoring
            const context = buildTransactionContext(transaction, transactionIndex);

            // Show initial placeholder
            resultsContainer.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 10px;">
                        Found ${messages.length} potential invoice${messages.length > 1 ? 's' : ''} (processing...)
                    </div>
                </div>
                <div id="invoiceResultsContainer"></div>
            `;

            // Fetch, score, and AUTOMATICALLY PROCESS PDFs
            const scoredMessages = [];
            const totalMessages = messages.length;

            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];

                try {
                    // Update progress bar incrementally during OCR/validation
                    const progressPercent = 70 + Math.floor((i / totalMessages) * 25); // 70% to 95%
                    updateSearchProgress(progressPercent, `Processing invoice ${i + 1} of ${totalMessages}...`);
                    searchLogger.logProgress(`Processing invoice ${i + 1} of ${totalMessages}...`, 'info');

                    // Set access token for this message's account
                    if (msg.accountAccessToken) {
                        gapi.client.setToken({ access_token: msg.accountAccessToken });
                        console.log('üîë [AUTO-PROCESS] Set token for:', msg.accountEmail);
                    } else {
                        throw new Error(`No access token for message from ${msg.accountEmail}`);
                    }

                    // Get full message details
                    const response = await gapi.client.gmail.users.messages.get({
                        userId: 'me',
                        id: msg.id
                    });

                    const message = response.result;

                    // Score this invoice
                    const scoring = scoreInvoiceRelevance(message, transaction, context);

                    // Extract attachments
                    const attachments = extractAttachments(message.payload);

                    // AUTOMATIC PDF PROCESSING: Download and extract data from ALL PDFs
                    const processedAttachments = [];

                    if (attachments.length > 0) {
                        searchLogger.logProgress(`  üìÑ Found ${attachments.length} PDF attachment(s)`, 'info');

                        // Process each attachment separately
                        for (let attIndex = 0; attIndex < attachments.length; attIndex++) {
                            const attachment = attachments[attIndex];
                            let pdfBlob = null;
                            let extractedData = null;
                            let validation = null;
                            let ocrText = null;

                            try {
                                searchLogger.logProgress(`  üìÑ Downloading attachment ${attIndex + 1}/${attachments.length}: ${attachment.filename}`, 'info');

                                // Token already set above, no need to set again
                                const attachResponse = await gapi.client.gmail.users.messages.attachments.get({
                                    userId: 'me',
                                    messageId: msg.id,
                                    id: attachment.id
                                });

                                // Decode PDF
                                const data = attachResponse.result.data;
                                const pdfData = data.replace(/-/g, '+').replace(/_/g, '/');
                                pdfBlob = base64ToBlob(pdfData, 'application/pdf');

                                // Extract text using OCR
                                searchLogger.logProgress(`  üîç Running OCR on ${attachment.filename}...`, 'info');
                                ocrText = await extractTextFromPDF(pdfBlob);

                                if (ocrText === null) {
                                    // PDF extraction failed (invalid structure, corrupt file, etc.)
                                    searchLogger.logProgress(`  ‚ö†Ô∏è Could not read ${attachment.filename} - file may be corrupt or invalid`, 'warning');
                                } else if (ocrText.trim().length > 20) {
                                    // Extract structured data (company, amount, date)
                                    searchLogger.logProgress(`  ü§ñ Extracting invoice data from ${attachment.filename}...`, 'info');
                                    extractedData = await extractStructuredDataFromInvoice(ocrText, transaction);

                                    if (extractedData) {
                                        // Validate against transaction
                                        searchLogger.logProgress(`  ‚úì Validating invoice data...`, 'info');
                                        validation = await validateInvoiceData(extractedData, transaction);

                                        console.log(`‚úÖ [AUTO-PROCESS] Extracted and validated (attachment ${attIndex + 1}):`, {
                                            filename: attachment.filename,
                                            company: extractedData.company,
                                            amount: extractedData.amount,
                                            date: extractedData.date,
                                            validation: validation.recommendation
                                        });
                                    } else {
                                        searchLogger.logProgress(`  ‚ö†Ô∏è Could not extract structured data from ${attachment.filename}`, 'warning');
                                    }
                                } else {
                                    // PDF read successfully but insufficient text found
                                    searchLogger.logProgress(`  ‚ö†Ô∏è ${attachment.filename} appears to be blank or has no readable text`, 'warning');
                                }
                            } catch (pdfError) {
                                console.error(`‚ùå [AUTO-PROCESS] PDF processing error for ${attachment.filename}:`, pdfError);
                                searchLogger.logProgress(`  ‚ö†Ô∏è PDF processing failed for ${attachment.filename}: ${pdfError.message}`, 'warning');
                            }

                            // Store results for this attachment (even if some fields are null)
                            processedAttachments.push({
                                attachment,
                                pdfBlob,
                                extractedData,
                                validation,
                                ocrText
                            });
                        }
                    } else if (msg.allowNonPDF) {
                        // NO PDF ATTACHMENTS: Convert email to PDF
                        searchLogger.logProgress(`  üìß No PDF attachment - converting email to PDF`, 'info');

                        let pdfBlob = null;
                        let extractedData = null;
                        let validation = null;
                        let ocrText = null;

                        try {
                            // Convert email content to PDF
                            pdfBlob = await convertEmailToPDF(message);

                            // Extract text from generated PDF for processing
                            searchLogger.logProgress(`  üîç Extracting text from converted email...`, 'info');
                            ocrText = await extractTextFromPDF(pdfBlob);

                            if (ocrText && ocrText.trim().length > 20) {
                                // Extract structured data (company, amount, date)
                                searchLogger.logProgress(`  ü§ñ Extracting data from email content...`, 'info');
                                extractedData = await extractStructuredDataFromInvoice(ocrText, transaction);

                                if (extractedData) {
                                    // Validate against transaction
                                    searchLogger.logProgress(`  ‚úì Validating email data...`, 'info');
                                    validation = await validateInvoiceData(extractedData, transaction);

                                    if (validation.recommendation === 'attach') {
                                        searchLogger.logProgress(`  ‚úÖ Email content matches transaction!`, 'success');
                                    } else if (validation.recommendation === 'review') {
                                        searchLogger.logProgress(`  ‚ö†Ô∏è Email content partially matches - review recommended`, 'warning');
                                    } else {
                                        searchLogger.logProgress(`  ‚ö†Ô∏è Email content does not match transaction`, 'warning');
                                    }
                                }
                            }
                        } catch (emailConversionError) {
                            console.error(`‚ùå [EMAIL-TO-PDF] Conversion error:`, emailConversionError);
                            searchLogger.logProgress(`  ‚ö†Ô∏è Email conversion failed: ${emailConversionError.message}`, 'warning');
                        }

                        // Store converted email as a "virtual attachment"
                        const headers = message.payload.headers;
                        const subject = headers.find(h => h.name === 'Subject')?.value || 'Email Confirmation';
                        const emailDate = headers.find(h => h.name === 'Date')?.value || '';

                        processedAttachments.push({
                            attachment: {
                                filename: `${subject.substring(0, 50)}.pdf`,
                                id: 'email-converted',
                                mimeType: 'application/pdf',
                                size: pdfBlob?.size || 0
                            },
                            pdfBlob,
                            extractedData,
                            validation,
                            ocrText,
                            isEmailConversion: true  // Flag to show special badge in UI
                        });
                    }

                    scoredMessages.push({
                        message,
                        scoring,
                        attachments,
                        accountEmail: msg.accountEmail,
                        processedAttachments  // Store array of processed attachments
                    });

                    console.log('üìä Scored email:', {
                        subject: message.payload.headers.find(h => h.name === 'Subject')?.value,
                        score: scoring.total,
                        breakdown: scoring.details,
                        attachmentCount: processedAttachments.length,
                        validatedAttachments: processedAttachments.filter(a => a.validation).length
                    });

                    // IMMEDIATE DISPLAY: Render results incrementally as each invoice is processed
                    renderInvoiceResults(scoredMessages, transaction, transactionIndex, context);

                } catch (error) {
                    console.error('Error fetching message details:', error);
                    searchLogger.logProgress(`Error loading email ${msg.id}: ${error.message}`, 'error');
                }
            }

            // Final render with completion message
            searchLogger.logProgress(`‚úÖ Processed and ranked ${scoredMessages.length} results`, 'success');
            renderInvoiceResults(scoredMessages, transaction, transactionIndex, context, true);
        }

        /**
         * Render invoice results (called incrementally or at completion)
         */
        function renderInvoiceResults(scoredMessages, transaction, transactionIndex, context, isComplete = false) {
            // Sort by validation quality first, then email score
            scoredMessages.sort((a, b) => {
                // Calculate best validation match count across all attachments (0-3 for how many fields match)
                const getBestValidationScore = (item) => {
                    if (!item.processedAttachments || item.processedAttachments.length === 0) return -1;

                    let bestScore = -1;
                    for (const processed of item.processedAttachments) {
                        if (processed.validation) {
                            let score = 0;
                            if (processed.validation.companyMatch) score++;
                            if (processed.validation.amountMatch) score++;
                            if (processed.validation.dateMatch) score++;
                            bestScore = Math.max(bestScore, score);
                        }
                    }
                    return bestScore;
                };

                const aValidationScore = getBestValidationScore(a);
                const bValidationScore = getBestValidationScore(b);

                // Sort by validation score first (3 matches > 2 matches > 1 match > no validation)
                if (aValidationScore !== bValidationScore) {
                    return bValidationScore - aValidationScore;
                }

                // If same validation score, sort by email scoring
                return b.scoring.total - a.scoring.total;
            });

            // Build HTML
            const statusText = isComplete ? 'sorted by match probability' : `processing ${scoredMessages.length}...`;
            let html = `<div style="margin-bottom: 20px;">
                <div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 10px;">
                    Found ${scoredMessages.length} potential invoice${scoredMessages.length > 1 ? 's' : ''} (${statusText})
                </div>
            </div>`;

            // Display scored results
            scoredMessages.forEach((item, index) => {
                const headers = item.message.payload.headers;
                const from = headers.find(h => h.name === 'From')?.value || 'Unknown';
                const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                const date = headers.find(h => h.name === 'Date')?.value || '';
                const messageId = item.message.id;

                // Border color based on rank
                const borderColor = index === 0 ? '#3AAFA9' : (index === 1 ? '#d97706' : '#94a3b8');

                // Score color
                let scoreColor, scoreIcon;
                if (item.scoring.total >= 80) {
                    scoreColor = '#059669';
                } else if (item.scoring.total >= 60) {
                    scoreColor = '#d97706';
                } else if (item.scoring.total >= 40) {
                    scoreColor = '#ea580c';
                } else {
                    scoreColor = '#dc2626';
                }

                // Scoring pill colors and icons
                const getMatchIcon = (score, threshold) => score >= threshold ? '‚úì' : '‚úó';
                const getMatchColor = (score, threshold) => score >= threshold ? '#059669' : '#dc2626';

                // PRIORITY: Use validation results from OCR if available, otherwise fall back to email scoring
                let companyColor, amountColor, dateColor, companyIcon, amountIcon, dateIcon;

                // Find best validation result across all attachments
                let bestValidation = null;
                let bestExtractedData = null;
                if (item.processedAttachments && item.processedAttachments.length > 0) {
                    for (const processed of item.processedAttachments) {
                        if (processed.validation) {
                            const matchCount = (processed.validation.companyMatch ? 1 : 0) +
                                             (processed.validation.amountMatch ? 1 : 0) +
                                             (processed.validation.dateMatch ? 1 : 0);
                            const bestMatchCount = bestValidation ?
                                ((bestValidation.companyMatch ? 1 : 0) +
                                 (bestValidation.amountMatch ? 1 : 0) +
                                 (bestValidation.dateMatch ? 1 : 0)) : 0;

                            if (matchCount > bestMatchCount) {
                                bestValidation = processed.validation;
                                bestExtractedData = processed.extractedData;
                            }
                        }
                    }
                }

                if (bestValidation) {
                    // Use OCR validation results (more accurate!)
                    companyColor = bestValidation.companyMatch ? '#059669' : '#dc2626';
                    amountColor = bestValidation.amountMatch ? '#059669' : '#dc2626';
                    dateColor = bestValidation.dateMatch ? '#059669' : '#dc2626';

                    companyIcon = bestValidation.companyMatch ? '‚úì' : '‚úó';
                    amountIcon = bestValidation.amountMatch ? '‚úì' : '‚úó';
                    dateIcon = bestValidation.dateMatch ? '‚úì' : '‚úó';

                    console.log('üìä Using OCR validation for pills:', {
                        company: bestValidation.companyMatch,
                        amount: bestValidation.amountMatch,
                        date: bestValidation.dateMatch
                    });
                } else {
                    // Fallback to email-based scoring
                    companyColor = getMatchColor(item.scoring.company, 30);
                    amountColor = getMatchColor(item.scoring.amount, 25);
                    dateColor = item.scoring.date >= 14 ? '#059669' : '#ea580c';  // Threshold 14: dates ‚â§5 days (15 pts) show green

                    companyIcon = getMatchIcon(item.scoring.company, 30);
                    amountIcon = getMatchIcon(item.scoring.amount, 25);
                    dateIcon = getMatchIcon(item.scoring.date, 14);  // Threshold 14: dates ‚â§5 days (15 pts) show ‚úì

                    console.log('üìä Using email scoring for pills (no OCR validation available)');
                }

                // Format date compactly
                const formattedDate = formatCompactDate(date);
                const fromName = from.includes('<') ? from.split('<')[0].trim() : from.substring(0, 30);

                // Build email content summary details
                let emailContentSummary = '';

                // Company match details from email content
                const companyMatchText = item.scoring.details.companyMatch || 'No company match';

                // Amount match details from email content
                const amountMatchText = item.scoring.details.amountMatch || 'No amount match';

                // Date match details from email content
                const dateMatchText = item.scoring.details.dateMatch || 'Date not found';

                // Overall email score
                const emailScore = item.scoring.total;
                let scoreLabel = '';
                if (emailScore >= 80) scoreLabel = 'Excellent Match';
                else if (emailScore >= 60) scoreLabel = 'Good Match';
                else if (emailScore >= 40) scoreLabel = 'Possible Match';
                else scoreLabel = 'Weak Match';

                html += `<div style="background: #fff; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${borderColor}; box-shadow: 0 1px 4px rgba(0,0,0,0.08); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'" onmouseout="this.style.boxShadow='0 1px 4px rgba(0,0,0,0.08)'">

                    <!-- Main content: Left side info, Right side button -->
                    <div style="display: flex; gap: 12px; align-items: flex-start;">

                        <!-- Left side: Email info and scoring -->
                        <div style="flex: 1; min-width: 0;">
                            <!-- Email info -->
                            <div style="font-size: 13px; color: #1e293b; margin-bottom: 4px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(subject)}">
                                ${escapeHtml(subject)}
                            </div>
                            <div style="font-size: 11px; color: #64748b; margin-bottom: 8px;">
                                ${escapeHtml(fromName)} ‚Ä¢ ${formattedDate}
                            </div>

                            <!-- Email Content Summary Table -->
                            <div style="background: #f8fafc; border-radius: 6px; padding: 8px; margin-bottom: 8px; font-size: 10px;">
                                <div style="font-weight: 600; color: #475569; margin-bottom: 6px; font-size: 11px;">üìß Email Content Analysis (Score: ${emailScore}% - ${scoreLabel})</div>
                                <table style="width: 100%; border-collapse: collapse;">
                                    <tr style="border-bottom: 1px solid #e2e8f0;">
                                        <td style="padding: 4px 0; font-weight: 600; color: #64748b;">Company:</td>
                                        <td style="padding: 4px 0; color: ${companyColor};">${companyMatchText}</td>
                                    </tr>
                                    <tr style="border-bottom: 1px solid #e2e8f0;">
                                        <td style="padding: 4px 0; font-weight: 600; color: #64748b;">Amount:</td>
                                        <td style="padding: 4px 0; color: ${amountColor};">${amountMatchText}</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 4px 0; font-weight: 600; color: #64748b;">Date:</td>
                                        <td style="padding: 4px 0; color: ${dateColor};">${dateMatchText}</td>
                                    </tr>
                                </table>
                            </div>

                            <!-- PDF Validation Pills (if available) -->`;

                // Add validation status badge if available
                if (bestExtractedData && bestValidation) {
                    const allMatch = bestValidation.companyMatch && bestValidation.amountMatch && bestValidation.dateMatch;
                    const someMatch = bestValidation.companyMatch || bestValidation.amountMatch || bestValidation.dateMatch;

                    let validationIcon, validationText, validationColor;
                    if (allMatch) {
                        validationIcon = '‚úÖ';
                        validationText = 'PDF Validated: All fields match';
                        validationColor = '#22c55e';
                    } else if (someMatch) {
                        validationIcon = '‚ö†Ô∏è';
                        validationText = 'PDF Validated: Partial match';
                        validationColor = '#f59e0b';
                    } else {
                        validationIcon = '‚ùå';
                        validationText = 'PDF Validated: Mismatch';
                        validationColor = '#ef4444';
                    }

                    html += `
                            <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px;">
                                <span style="background: ${companyColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                    ${companyIcon} Company
                                </span>
                                <span style="background: ${amountColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                    ${amountIcon} Amount
                                </span>
                                <span style="background: ${dateColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                    ${dateIcon} Date
                                </span>
                                <span style="background: ${validationColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;">
                                    ${validationIcon} ${validationText}
                                </span>
                            </div>`;
                }

                html += `
                        </div>

                        <!-- Right side: Download & Process button -->
                        <div style="display: flex; flex-direction: column; gap: 6px; min-width: 180px;">`;

                if (item.processedAttachments && item.processedAttachments.length > 0) {
                    // Show buttons for ALL attachments

                    for (let attIdx = 0; attIdx < item.processedAttachments.length; attIdx++) {
                        const processed = item.processedAttachments[attIdx];
                        const att = processed.attachment;
                        const sizeKB = (att.size / 1024).toFixed(1);

                        // Store the processed data in a global map so previewAndAttachInvoice can access it
                        const dataKey = `${messageId}_${att.id}`;
                        if (!window.processedInvoiceData) window.processedInvoiceData = {};
                        window.processedInvoiceData[dataKey] = {
                            pdfBlob: processed.pdfBlob,
                            extractedData: processed.extractedData,
                            validation: processed.validation,
                            ocrText: processed.ocrText
                        };

                        // Add validation badges next to filename
                        let validationBadge = '';

                        // Email conversion badge (shown first if applicable)
                        if (processed.isEmailConversion) {
                            validationBadge = '<span style="background: #3AAFA9; color: white; padding: 2px 6px; border-radius: 10px; font-size: 8px; font-weight: 700; margin-left: 4px;" title="Generated from email confirmation">üìß Email</span>';
                        }

                        // Add validation status badge
                        if (processed.validation) {
                            const matchCount = (processed.validation.companyMatch ? 1 : 0) +
                                             (processed.validation.amountMatch ? 1 : 0) +
                                             (processed.validation.dateMatch ? 1 : 0);

                            if (matchCount === 3) {
                                validationBadge += '<span style="color: #22c55e; font-weight: bold; margin-left: 4px;">‚úÖ</span>';
                            } else if (matchCount >= 1) {
                                validationBadge += `<span style="color: #f59e0b; font-weight: bold; margin-left: 4px;">‚ö†Ô∏è ${matchCount}/3</span>`;
                            } else {
                                validationBadge += '<span style="color: #ef4444; font-weight: bold; margin-left: 4px;">‚ùå</span>';
                            }
                        } else if (processed.ocrText === null && !processed.isEmailConversion) {
                            // PDF couldn't be read (corrupt/invalid)
                            validationBadge += '<span style="color: #94a3b8; font-size: 9px; font-weight: 600; margin-left: 4px;" title="Could not read PDF - file may be corrupt">üîí Unreadable</span>';
                        }

                        // Shorten filename if too long
                        let displayFilename = att.filename;
                        if (displayFilename.length > 20) {
                            const ext = displayFilename.split('.').pop();
                            displayFilename = displayFilename.substring(0, 15) + '...' + ext;
                        }

                        html += `
                            <button onclick="previewAndAttachInvoice(${transactionIndex}, '${messageId}', '${att.id}', '${escapeHtml(att.filename)}', '${escapeHtml(item.accountEmail)}')"
                                style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; padding: 10px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 10px; font-weight: 700; width: 100%; transition: all 0.2s; text-align: center; box-shadow: 0 2px 4px rgba(34,197,94,0.2);"
                                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(34,197,94,0.4)'"
                                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(34,197,94,0.2)'"
                                title="${escapeHtml(att.filename)} (${sizeKB} KB) - Click to download and process">
                                <div style="font-size: 18px; margin-bottom: 4px;">üì•</div>
                                <div style="margin-bottom: 2px;">Download & Process</div>
                                <div style="font-size: 8px; opacity: 0.9; font-weight: 500;">${escapeHtml(displayFilename)} ${validationBadge}</div>
                            </button>
                        `;
                    }

                    // Gmail button
                    html += `
                        <button
                            onclick="openEmailInGmail('${messageId}', '${escapeHtml(item.accountEmail)}')"
                            style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); color: white; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 10px; font-weight: 600; width: 100%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 5px;"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 8px rgba(234,67,53,0.3)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                            title="Open this email in Gmail">
                            <span style="font-size: 12px;">üìß</span>
                            <span>Open in Gmail</span>
                        </button>
                    `;
                } else {
                    // No PDF attachments - show warning and Gmail button
                    html += `
                        <div style="background: #fffbeb; border-radius: 6px; padding: 10px; border: 1px dashed #f59e0b; text-align: center; margin-bottom: 6px;">
                            <div style="color: #d97706; font-size: 10px; font-weight: 600; margin-bottom: 6px;">
                                ‚ö†Ô∏è No PDF found
                            </div>
                        </div>
                        <button
                            onclick="openEmailInGmail('${messageId}', '${escapeHtml(item.accountEmail)}')"
                            style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); color: white; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 10px; font-weight: 600; width: 100%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 5px;"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 8px rgba(234,67,53,0.3)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'"
                            title="Open this email in Gmail">
                            <span style="font-size: 12px;">üìß</span>
                            <span>Open in Gmail</span>
                        </button>
                    `;
                }

                // Close right column and main flex container
                html += `
                        </div>
                    </div>
                </div>`;
            });

            // Render to invoiceResultsContainer (inside the main results container)
            const invoiceResultsContainer = document.getElementById('invoiceResultsContainer');
            if (invoiceResultsContainer) {
                invoiceResultsContainer.innerHTML = html;
            }

            // Update progress and log only on completion
            if (isComplete) {
                updateSearchProgress(100, 'Complete! Results displayed.');
                searchLogger.logProgress('‚úÖ Results displayed! Click "Preview & Attach" to view invoice.', 'success');
            }
        }

        /**
         * Extract attachments from email payload
         */
        function extractAttachments(payload, attachments = []) {
            if (payload.parts) {
                for (const part of payload.parts) {
                    if (part.filename && part.body && part.body.attachmentId) {
                        attachments.push({
                            filename: part.filename,
                            id: part.body.attachmentId,
                            mimeType: part.mimeType,
                            size: part.body.size || 0
                        });
                    }
                    // Recursively check nested parts
                    if (part.parts) {
                        extractAttachments(part, attachments);
                    }
                }
            }
            return attachments;
        }

        /**
         * Score an email's relevance to the transaction
         * Returns score 0-100 based on company, amount, and date match
         */
        function scoreInvoiceRelevance(email, transaction, context) {
            let score = 0;
            const scoring = {
                company: 0,
                amount: 0,
                date: 0,
                details: {}
            };

            // Get email metadata
            const headers = email.payload.headers;
            const from = headers.find(h => h.name === 'From')?.value || '';
            const subject = headers.find(h => h.name === 'Subject')?.value || '';
            const dateStr = headers.find(h => h.name === 'Date')?.value || '';
            const snippet = email.snippet || '';

            // 1. COMPANY NAME MATCH (max 40 points)
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
            const searchText = `${from} ${subject}`.toLowerCase();

            // Check for exact keyword match
            if (searchText.includes(merchantKeyword.toLowerCase())) {
                score += 40;
                scoring.company = 40;
                scoring.details.companyMatch = `‚úì "${merchantKeyword}" found in email`;
            } else {
                // Check space-removed variations (e.g., "our sqk accountancy" -> "oursqkaccountancy")
                const noSpacesName = context.merchantName.replace(/\s+/g, '').toLowerCase();
                const domainVariations = [
                    noSpacesName + '.co.uk',
                    noSpacesName + '.com',
                    noSpacesName + '.org.uk',
                    noSpacesName + '.uk',
                    noSpacesName
                ];

                const domainMatch = domainVariations.some(variant => searchText.includes(variant));

                if (domainMatch) {
                    score += 40;
                    scoring.company = 40;
                    scoring.details.companyMatch = `‚úì "${noSpacesName}" variation found in email`;
                } else {
                    // Partial match - check merchant variants
                    const partialMatch = context.merchantVariants.some(variant =>
                        searchText.includes(variant.toLowerCase())
                    );
                    if (partialMatch) {
                        score += 20;
                        scoring.company = 20;
                        scoring.details.companyMatch = `~ Partial match found`;
                    } else {
                        scoring.details.companyMatch = `‚úó Company name not found`;
                    }
                }
            }

            // 2. AMOUNT MATCH (max 35 points)
            const amountStr = context.amount.toFixed(2);
            const amountGBP = `¬£${amountStr}`;
            const fullText = `${subject} ${snippet}`.toLowerCase();

            if (fullText.includes(amountStr) || fullText.includes(amountGBP)) {
                score += 35;
                scoring.amount = 35;
                scoring.details.amountMatch = `‚úì ¬£${amountStr} found`;
            } else {
                // Check for amount variations (with commas, different formats)
                const hasAmountVariation = context.amountFormats.some(format =>
                    fullText.includes(format.toLowerCase())
                );
                if (hasAmountVariation) {
                    score += 20;
                    scoring.amount = 20;
                    scoring.details.amountMatch = `~ Amount format variation found`;
                } else {
                    scoring.details.amountMatch = `‚úó Amount not found`;
                }
            }

            // 3. DATE PROXIMITY (max 25 points)
            try {
                const emailDate = new Date(dateStr);
                const txDate = context.date;
                const daysDiff = Math.abs(Math.floor((emailDate - txDate) / (1000 * 60 * 60 * 24)));

                if (daysDiff === 0) {
                    score += 25;
                    scoring.date = 25;
                    scoring.details.dateMatch = `‚úì Same day`;
                } else if (daysDiff <= 2) {
                    score += 20;
                    scoring.date = 20;
                    scoring.details.dateMatch = `‚úì ${daysDiff} day(s) difference`;
                } else if (daysDiff <= 5) {
                    score += 15;
                    scoring.date = 15;
                    scoring.details.dateMatch = `~ ${daysDiff} days difference`;
                } else if (daysDiff <= 10) {
                    score += 10;
                    scoring.date = 10;
                    scoring.details.dateMatch = `~ ${daysDiff} days difference`;
                } else {
                    score += 5;
                    scoring.date = 5;
                    scoring.details.dateMatch = `‚ö† ${daysDiff} days difference`;
                }
            } catch (error) {
                scoring.details.dateMatch = `? Could not parse date`;
            }

            scoring.total = score;
            return scoring;
        }

        /**
         * Get score badge HTML with color coding
         */
        function getScoreBadge(score) {
            let color, label, bgColor;

            if (score >= 80) {
                color = '#059669';
                bgColor = '#d1fae5';
                label = 'HIGH MATCH';
            } else if (score >= 60) {
                color = '#d97706';
                bgColor = '#fef3c7';
                label = 'LIKELY';
            } else if (score >= 40) {
                color = '#ea580c';
                bgColor = '#ffedd5';
                label = 'POSSIBLE';
            } else {
                color = '#dc2626';
                bgColor = '#fee2e2';
                label = 'LOW MATCH';
            }

            return `<div style="display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; background: ${bgColor}; border-radius: 6px; border: 2px solid ${color};">
                <span style="font-weight: 700; font-size: 18px; color: ${color};">${score}%</span>
                <span style="font-weight: 600; font-size: 11px; color: ${color}; letter-spacing: 0.5px;">${label}</span>
            </div>`;
        }

        /**
         * Show no results options
         */
        function showNoResultsOptions(context, transaction, transactionIndex) {
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.style.display = 'block';

            // Build Gmail account buttons
            let gmailAccountButtons = '';
            if (gmailAccounts && gmailAccounts.length > 0) {
                gmailAccountButtons = gmailAccounts.map((account, index) => {
                    return `
                        <button
                            onclick="window.open('https://mail.google.com/mail/u/${index}/#search/${encodeURIComponent(context.merchantName)}', '_blank')"
                            style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); color: white; padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px; transition: all 0.2s; box-shadow: 0 2px 4px rgba(234,67,53,0.2);"
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(234,67,53,0.3)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(234,67,53,0.2)'"
                            title="Open Gmail for ${escapeHtml(account.email)}">
                            <span style="font-size: 18px;">üìß</span>
                            <div style="text-align: left; flex: 1;">
                                <div style="font-size: 13px; font-weight: 600;">Open Gmail ${index + 1}</div>
                                <div style="font-size: 11px; opacity: 0.9;">${escapeHtml(account.email)}</div>
                            </div>
                        </button>
                    `;
                }).join('');
            }

            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 30px; background: #f8fafc; border-radius: 8px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">üì≠</div>
                    <h4 style="margin: 0 0 10px 0; color: #1e293b;">No Invoices Found</h4>
                    <p style="color: #64748b; margin: 0 0 15px 0;">
                        Searched up to ¬±10 days for "${context.merchantName}"
                    </p>

                    <div style="margin-bottom: 20px;">
                        <button onclick="extendSearch()" class="btn-primary" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); padding: 12px 24px; font-size: 14px; font-weight: 600;">
                            üîç Extend Search to ¬±30 Days
                        </button>
                    </div>

                    ${gmailAccountButtons ? `
                        <div style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid #e2e8f0;">
                            <p style="color: #475569; font-size: 14px; font-weight: 500; margin: 0 0 12px 0;">
                                Or open Gmail to search manually:
                            </p>
                            <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                                ${gmailAccountButtons}
                            </div>
                        </div>
                    ` : ''}

                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                        <button onclick="document.getElementById('manualInvoiceUpload').click()" class="btn-primary">
                            üìé Upload PDF Manually
                        </button>
                        <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                            Close
                        </button>
                    </div>
                </div>
            `;

            // Store context for extended search
            window._extendedSearchContext = { context, transaction, transactionIndex };
        }

        /**
         * Extend search to ¬±30 days
         */
        async function extendSearch() {
            if (!window._extendedSearchContext) {
                showSimpleToast('‚ùå Search context lost. Please try again.', 'error');
                return;
            }

            const { context, transaction, transactionIndex } = window._extendedSearchContext;

            // Clear results and reset logger
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.innerHTML = '';
            resultsContainer.style.display = 'none';
            searchLogger.clear();

            // Update progress
            searchLogger.logProgress('üîç Extending search to ¬±30 days...', 'info');
            updateSearchProgress(0, 'Extended search in progress...');

            try {
                // Create extended search stage
                const extendedStage = {
                    stage: 3,
                    name: "Extended Search (¬±30 days)",
                    dateWindow: 30,
                    autoExecute: true,
                    description: "Searching ¬±30 days with merchant variants and AI keywords"
                };

                searchLogger.logStage(extendedStage.stage, `${extendedStage.name} (¬±${extendedStage.dateWindow} days)`);

                // Re-run AI merchant interpretation if not already done
                let aiKeywords = context.aiMerchantInfo || null;
                if (!aiKeywords) {
                    searchLogger.logProgress('ü§ñ Analyzing merchant with AI...', 'info');
                    aiKeywords = await interpretMerchantWithAI(context.merchantName, transaction);
                    if (aiKeywords) {
                        context.aiMerchantInfo = aiKeywords;
                    }
                }

                // Execute extended search
                const results = await executeSearchStage(context, extendedStage, aiKeywords);

                if (results.length > 0) {
                    searchLogger.logResults(results.length, extendedStage.dateWindow);
                    updateSearchProgress(70, 'Processing invoices...');
                    searchLogger.logProgress(`‚úÖ Found ${results.length} potential invoice(s)!`, 'success');
                    await displayIntelligentSearchResults(results, transaction, transactionIndex);
                } else {
                    // Still no results after extended search
                    searchLogger.logProgress('No invoices found even with ¬±30 days', 'warning');
                    updateSearchProgress(100, 'Search complete - no results');

                    // Show final no results message (without extend button)
                    showFinalNoResultsOptions(context);
                }

            } catch (error) {
                console.error('Extended search error:', error);
                searchLogger.logProgress(`Error: ${error.message}`, 'error');
                showSimpleToast('Extended search error: ' + error.message, 'error');
            }
        }

        /**
         * Show final no results options (after extended search)
         */
        function showFinalNoResultsOptions(context) {
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.style.display = 'block';

            // Build Gmail account buttons
            let gmailAccountButtons = '';
            if (gmailAccounts && gmailAccounts.length > 0) {
                gmailAccountButtons = gmailAccounts.map((account, index) => {
                    return `
                        <button
                            onclick="window.open('https://mail.google.com/mail/u/${index}/#search/${encodeURIComponent(context.merchantName)}', '_blank')"
                            style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); color: white; padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px; transition: all 0.2s; box-shadow: 0 2px 4px rgba(234,67,53,0.2);"
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(234,67,53,0.3)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(234,67,53,0.2)'"
                            title="Open Gmail for ${escapeHtml(account.email)}">
                            <span style="font-size: 18px;">üìß</span>
                            <div style="text-align: left; flex: 1;">
                                <div style="font-size: 13px; font-weight: 600;">Open Gmail ${index + 1}</div>
                                <div style="font-size: 11px; opacity: 0.9;">${escapeHtml(account.email)}</div>
                            </div>
                        </button>
                    `;
                }).join('');
            }

            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 30px; background: #f8fafc; border-radius: 8px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">üì≠</div>
                    <h4 style="margin: 0 0 10px 0; color: #1e293b;">No Invoices Found</h4>
                    <p style="color: #64748b; margin: 0 0 20px 0;">
                        Searched up to ¬±30 days for "${context.merchantName}"
                    </p>

                    ${gmailAccountButtons ? `
                        <div style="margin-bottom: 20px;">
                            <p style="color: #475569; font-size: 14px; font-weight: 500; margin: 0 0 12px 0;">
                                Open Gmail to search manually:
                            </p>
                            <div style="display: flex; flex-direction: column; gap: 10px; max-width: 400px; margin: 0 auto;">
                                ${gmailAccountButtons}
                            </div>
                        </div>
                    ` : ''}

                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                        <button onclick="document.getElementById('manualInvoiceUpload').click()" class="btn-primary">
                            üìé Upload PDF Manually
                        </button>
                        <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                            Close
                        </button>
                    </div>
                </div>
            `;
        }

        // ========================================
        // PDF PREVIEW & ATTACHMENT WORKFLOW
        // ========================================

        // Store current attachment details
        let currentAttachmentData = null;
        let pendingInvoiceAttachment = null; // Stores data for confirmation modal

        /**
         * Display validation results in the UI
         */
        function displayValidationResults(validation, extractedData, transaction) {
            const container = document.getElementById('validationResultsContainer');

            // Check if validation UI exists in the modal (might not be present)
            if (!container) {
                console.warn('‚ö†Ô∏è [VALIDATION] Validation results container not found in modal - skipping display');
                return;
            }

            container.style.display = 'block';

            // Parse transaction amount for display - strip ¬£ symbol and commas
            const transactionAmountStr = (transaction.spent || transaction.received || '0').toString().replace(/¬£/g, '').replace(/,/g, '').trim();
            const transactionAmount = parseFloat(transactionAmountStr) || 0;

            // Company validation
            const companyValidation = document.getElementById('companyValidation');
            const companyStatus = document.getElementById('companyStatus');
            const companyReason = document.getElementById('companyReason');
            const companyExpected = document.getElementById('companyExpected');
            const companyFound = document.getElementById('companyFound');

            // Verify all company elements exist
            if (!companyValidation || !companyStatus || !companyReason || !companyExpected || !companyFound) {
                console.warn('‚ö†Ô∏è [VALIDATION] Some company validation elements not found');
                return;
            }

            // Populate Expected vs Found
            companyExpected.textContent = (transaction.description || 'N/A').substring(0, 20);
            companyFound.textContent = (extractedData?.company || 'Not found').substring(0, 20);

            if (validation.companyMatch) {
                companyStatus.textContent = '‚úÖ';
                companyValidation.style.background = '#f0fdf4';
                companyValidation.style.borderColor = '#22c55e';
            } else {
                companyStatus.textContent = '‚ùå';
                companyValidation.style.background = '#fef2f2';
                companyValidation.style.borderColor = '#ef4444';
            }
            companyReason.textContent = validation.companyReason || 'No reason provided';

            // Amount validation
            const amountValidation = document.getElementById('amountValidation');
            const amountStatus = document.getElementById('amountStatus');
            const amountReason = document.getElementById('amountReason');
            const amountExpected = document.getElementById('amountExpected');
            const amountFound = document.getElementById('amountFound');

            // Verify all amount elements exist
            if (!amountValidation || !amountStatus || !amountReason || !amountExpected || !amountFound) {
                console.warn('‚ö†Ô∏è [VALIDATION] Some amount validation elements not found');
                return;
            }

            // Populate Expected vs Found
            amountExpected.textContent = `¬£${transactionAmount.toFixed(2)}`;
            amountFound.textContent = extractedData?.amount ? `¬£${extractedData.amount}` : 'Not found';

            if (validation.amountMatch) {
                amountStatus.textContent = '‚úÖ';
                amountValidation.style.background = '#f0fdf4';
                amountValidation.style.borderColor = '#22c55e';
            } else {
                amountStatus.textContent = '‚ùå';
                amountValidation.style.background = '#fef2f2';
                amountValidation.style.borderColor = '#ef4444';
            }
            amountReason.textContent = validation.amountReason || 'No reason provided';

            // Date validation
            const dateValidation = document.getElementById('dateValidation');
            const dateStatus = document.getElementById('dateStatus');
            const dateReason = document.getElementById('dateReason');
            const dateExpected = document.getElementById('dateExpected');
            const dateFound = document.getElementById('dateFound');

            // Verify all date elements exist
            if (!dateValidation || !dateStatus || !dateReason || !dateExpected || !dateFound) {
                console.warn('‚ö†Ô∏è [VALIDATION] Some date validation elements not found');
                return;
            }

            // Populate Expected vs Found
            dateExpected.textContent = transaction.date || 'N/A';
            dateFound.textContent = extractedData?.date || 'Not found';

            if (validation.dateMatch) {
                dateStatus.textContent = '‚úÖ';
                dateValidation.style.background = '#f0fdf4';
                dateValidation.style.borderColor = '#22c55e';
            } else {
                dateStatus.textContent = '‚ùå';
                dateValidation.style.background = '#fef2f2';
                dateValidation.style.borderColor = '#ef4444';
            }
            dateReason.textContent = validation.dateReason || 'No reason provided';

            // Overall recommendation
            const recommendationContainer = document.getElementById('validationRecommendation');
            const recommendationIcon = document.getElementById('recommendationIcon');
            const recommendationText = document.getElementById('recommendationText');

            // Check if elements exist before updating (they might not be in the modal)
            if (!recommendationContainer || !recommendationIcon || !recommendationText) {
                console.warn('‚ö†Ô∏è [VALIDATION] Some validation UI elements not found in modal');
                return;
            }

            const allMatch = validation.companyMatch && validation.amountMatch && validation.dateMatch;

            if (validation.recommendation === 'attach' || allMatch) {
                recommendationContainer.style.background = '#f0fdf4';
                recommendationContainer.style.borderColor = '#22c55e';
                recommendationIcon.textContent = '‚úÖ';
                recommendationText.textContent = 'AI Recommendation: Safe to attach - All fields match!';
            } else if (validation.recommendation === 'review') {
                recommendationContainer.style.background = '#fffbeb';
                recommendationContainer.style.borderColor = '#f59e0b';
                recommendationIcon.textContent = '‚ö†Ô∏è';
                recommendationText.textContent = 'AI Recommendation: Please review - Some fields don\'t match';
            } else {
                recommendationContainer.style.background = '#fef2f2';
                recommendationContainer.style.borderColor = '#ef4444';
                recommendationIcon.textContent = 'üö´';
                recommendationText.textContent = 'AI Recommendation: Mismatched invoice - Consider rejecting';
            }

            // Update button text based on confidence
            const attachBtn = document.getElementById('attachInvoiceBtn');
            if (attachBtn) {
                if (validation.overallConfidence === 'high' && allMatch) {
                    attachBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
                } else if (validation.recommendation === 'reject') {
                    attachBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
                    attachBtn.textContent = '‚ö†Ô∏è Attach Anyway';
                } else {
                    attachBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                }
            }
        }

        /**
         * Perform validation on loaded PDF
         */
        async function performInvoiceValidation(pdfBlob, transaction) {
            try {
                console.log('üîç [VALIDATE] Starting invoice validation...');

                // Show validation container with loading state
                const container = document.getElementById('validationResultsContainer');
                container.style.display = 'block';

                // Extract text from PDF
                const extractedText = await extractTextFromPDF(pdfBlob);

                if (!extractedText || extractedText.trim().length < 20) {
                    throw new Error('Insufficient text extracted from PDF');
                }

                // Extract structured data
                const extractedData = await extractStructuredDataFromInvoice(extractedText, transaction);

                if (!extractedData) {
                    throw new Error('Failed to extract structured data');
                }

                // Validate against transaction
                const validation = await validateInvoiceData(extractedData, transaction);

                if (!validation) {
                    throw new Error('Validation failed');
                }

                // Check if modal was closed during validation
                if (!currentAttachmentData) {
                    console.log('‚ö†Ô∏è [VALIDATE] Modal was closed, skipping result storage');
                    return;
                }

                // Store validation results
                currentAttachmentData.validation = validation;
                currentAttachmentData.extractedData = extractedData;

                // Display results
                displayValidationResults(validation, extractedData, transaction);

                console.log('‚úÖ [VALIDATE] Validation complete and displayed');

            } catch (error) {
                console.error('‚ùå [VALIDATE] Validation error:', error);

                // Show error state only if modal is still open
                const container = document.getElementById('validationResultsContainer');
                if (container && currentAttachmentData) {
                    container.style.display = 'block';
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #fef2f2; border-radius: 8px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                            <div style="color: #dc2626; font-weight: 600;">Validation Failed</div>
                            <div style="color: #64748b; font-size: 14px; margin-top: 5px;">
                                ${error.message || 'Unable to validate invoice automatically'}
                            </div>
                            <div style="color: #64748b; font-size: 13px; margin-top: 10px;">
                                You can still attach this invoice manually.
                            </div>
                        </div>
                    `;
                } else {
                    console.log('‚ö†Ô∏è [VALIDATE] Error occurred but modal was closed, skipping error display');
                }
            }
        }

        /**
         * Handle file selection from file browser (click to browse)
         * @param {Event} event - The change event from file input
         * @param {number} transactionIndex - Index of the transaction
         */
        async function handleFileSelect(event, transactionIndex) {
            const file = event.target.files[0];
            if (!file) return;

            // Simulate a drop event for code reuse
            const fakeDropEvent = {
                preventDefault: () => {},
                stopPropagation: () => {},
                currentTarget: document.getElementById(`dropZone_${transactionIndex}`),
                dataTransfer: { files: [file] }
            };

            await handleInvoiceDrop(fakeDropEvent, transactionIndex);

            // Reset file input so same file can be selected again
            event.target.value = '';
        }

        /**
         * Handle drag-and-drop of invoice files (PDF or images)
         * @param {DragEvent} event - The drop event
         * @param {number} transactionIndex - Index of the transaction
         */
        async function handleInvoiceDrop(event, transactionIndex) {
            event.preventDefault();
            event.stopPropagation();

            console.log('üìé [DROP] Invoice drop triggered:', {
                transactionIndex,
                currentInvoiceSearchIndex,
                transaction: allTransactions[transactionIndex]?.description || 'NOT FOUND'
            });

            // Reset dropzone styling
            const dropZone = event.currentTarget;
            dropZone.style.background = '#f8fafc';
            dropZone.style.borderColor = '#cbd5e1';

            try {
                const files = event.dataTransfer.files;

                if (!files || files.length === 0) {
                    showSimpleToast('‚ùå No file dropped', 'error');
                    return;
                }

                const file = files[0];
                const fileName = file.name;
                const fileExt = fileName.split('.').pop().toLowerCase();

                // Validate file type
                const allowedTypes = ['pdf', 'jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
                if (!allowedTypes.includes(fileExt)) {
                    showSimpleToast(`‚ùå Invalid file type: ${fileExt}. Please use PDF or image files.`, 'error');
                    return;
                }

                console.log('üìé [DROP] File dropped:', { fileName, fileType: file.type, fileSize: file.size });

                // Show loading in dropzone
                dropZone.innerHTML = `
                    <div style="font-size: 16px; margin-bottom: 4px;">‚è≥</div>
                    <div style="font-size: 9px; color: #64748b; text-align: center;">Processing...</div>
                `;

                // showSimpleToast(`‚è≥ Processing ${fileName}...`, 'info'); // DISABLED (user preference)

                // Convert file to blob
                const fileBlob = new Blob([await file.arrayBuffer()], { type: file.type });

                // If it's an image, we'll treat it as a scanned invoice
                // For PDFs, use directly
                let invoiceBlob = fileBlob;
                let finalFilename = fileName;

                // If image, convert to PDF using jsPDF (optional - or just use image as-is)
                if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(fileExt)) {
                    console.log('üñºÔ∏è [DROP] Image file detected, will process as scanned invoice');
                    // For now, we'll keep the image as-is and let the OCR handle it
                    // You could convert to PDF here if needed
                }

                // CRITICAL FIX: Use currentInvoiceSearchIndex if drag-drop happens in modal
                // Otherwise use the provided transactionIndex
                const actualIndex = (currentInvoiceSearchIndex !== null && currentInvoiceSearchIndex !== undefined)
                    ? currentInvoiceSearchIndex
                    : transactionIndex;

                console.log('üìé [DROP] Using index:', {
                    providedIndex: transactionIndex,
                    currentInvoiceSearchIndex,
                    actualIndex,
                    willAttachTo: allTransactions[actualIndex]?.description || 'NOT FOUND'
                });

                // Save to IndexedDB and attach to transaction
                const savedId = await saveInvoiceToDB(actualIndex, invoiceBlob, finalFilename, null);

                if (savedId) {
                    // Update transaction with invoice
                    allTransactions[actualIndex].invoiceId = savedId;
                    allTransactions[actualIndex].invoiceFilename = finalFilename;

                    // Save updated transactions to storage
                    await saveTransactionsToStorage();

                    // Update UI
                    renderTransactions();

                    // showSimpleToast(`‚úÖ Invoice attached: ${finalFilename}`, 'success'); // DISABLED (user preference)

                    // Close the search modal
                    closeIntelligentSearchModal();

                    console.log('‚úÖ [DROP] Invoice successfully attached via drag-and-drop');
                } else {
                    throw new Error('Failed to save invoice to database');
                }

            } catch (error) {
                console.error('‚ùå [DROP] Error processing dropped file:', error);
                showSimpleToast(`‚ùå Failed to process file: ${error.message}`, 'error');

                // Reset dropzone
                dropZone.innerHTML = `
                    <div style="font-size: 20px; margin-bottom: 2px;">üìé</div>
                    <div style="font-size: 9px; font-weight: 600; color: #64748b; text-align: center; line-height: 1.3;">Drag invoice here</div>
                    <div style="font-size: 8px; color: #94a3b8; text-align: center; margin-top: 2px;">PDF, JPG, PNG</div>
                `;
            }
        }

        /**
         * Open a specific Gmail message in a new tab
         * @param {string} messageId - Gmail message ID
         * @param {string} accountEmail - Email account (for logging/display purposes)
         */
        function openEmailInGmail(messageId, accountEmail) {
            if (!messageId) {
                showSimpleToast('‚ùå Cannot open email: Message ID not available', 'error');
                console.error('‚ùå [GMAIL] Missing messageId for Gmail link');
                return;
            }

            const gmailUrl = `https://mail.google.com/mail/u/0/#all/${messageId}`;
            console.log(`üìß [GMAIL] Opening email in Gmail:`, { messageId, accountEmail, url: gmailUrl });
            // showSimpleToast('üìß Opening email in Gmail...', 'info'); // DISABLED (user preference)
            window.open(gmailUrl, '_blank');
        }

        /**
         * Preview PDF and prepare for attachment
         */
        async function previewAndAttachInvoice(transactionIndex, messageId, attachmentId, filename, accountEmail) {
            console.log('üìÑ [PREVIEW] Opening PDF preview...', { messageId, attachmentId, filename });

            try {
                // Store attachment details for later confirmation
                currentAttachmentData = {
                    transactionIndex,
                    messageId,
                    attachmentId,
                    filename,
                    accountEmail
                };

                // Show modal with loading state
                const modal = document.getElementById('pdfPreviewModal');
                const iframe = document.getElementById('pdfViewerIframe');
                document.getElementById('pdfPreviewTitle').textContent = `Preview: ${filename}`;

                modal.style.display = 'flex';
                iframe.src = '';  // Clear previous PDF

                // Show loading message
                const container = document.getElementById('pdfViewerContainer');
                container.innerHTML = `<div style="text-align: center; color: #64748b;">
                    <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
                    <div>Loading PDF...</div>
                </div>`;

                let pdfBlob, extractedData, validation, ocrText;

                // Check if we already processed this PDF (from automatic search)
                const dataKey = `${messageId}_${attachmentId}`;
                const processedData = window.processedInvoiceData?.[dataKey];

                if (processedData && processedData.pdfBlob) {
                    console.log('‚úÖ [PREVIEW] Using cached PDF data (already processed)');
                    pdfBlob = processedData.pdfBlob;
                    extractedData = processedData.extractedData;
                    validation = processedData.validation;
                    ocrText = processedData.ocrText;
                } else {
                    console.log('üì• [PREVIEW] Downloading PDF from Gmail...');

                    // Find account and set access token
                    const account = gmailAccounts.find(acc => acc.email === accountEmail);
                    if (!account || !account.accessToken) {
                        throw new Error(`No valid access token for account: ${accountEmail}`);
                    }
                    gapi.client.setToken({ access_token: account.accessToken });
                    console.log('üîë [PREVIEW] Set token for:', accountEmail);

                    // Download PDF from Gmail
                    const response = await gapi.client.gmail.users.messages.attachments.get({
                        userId: 'me',
                        messageId: messageId,
                        id: attachmentId
                    });

                    // Decode base64 PDF data
                    const data = response.result.data;
                    const pdfData = data.replace(/-/g, '+').replace(/_/g, '/');
                    pdfBlob = base64ToBlob(pdfData, 'application/pdf');
                }

                // Create blob URL and show in iframe
                const blobUrl = URL.createObjectURL(pdfBlob);

                // Restore iframe
                container.innerHTML = `<iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>`;
                const newIframe = document.getElementById('pdfViewerIframe');
                newIframe.src = blobUrl;

                // Store blob for later save
                currentAttachmentData.pdfBlob = pdfBlob;
                currentAttachmentData.blobUrl = blobUrl;
                currentAttachmentData.extractedData = extractedData;
                currentAttachmentData.validation = validation;

                console.log('‚úÖ [PREVIEW] PDF loaded successfully');

                // If we already have validation data, display it immediately
                const transaction = allTransactions[transactionIndex];
                if (validation && extractedData) {
                    console.log('‚úÖ [PREVIEW] Using cached validation results');
                    displayValidationResults(validation, extractedData, transaction);
                } else {
                    // Trigger automatic validation (fallback for manual uploads or uncached PDFs)
                    console.log('üîç [PREVIEW] Running validation...');
                    await performInvoiceValidation(pdfBlob, transaction);
                }

            } catch (error) {
                console.error('Error loading PDF preview:', error);
                showSimpleToast('‚ùå Failed to load PDF preview', 'error');
                closePDFPreview();
            }
        }

        /**
         * Confirm and attach invoice to transaction
         */
        async function confirmAttachInvoice() {
            if (!currentAttachmentData) {
                showSimpleToast('‚ùå No invoice data available', 'error');
                return;
            }

            console.log('üíæ [ATTACH] Attaching invoice to transaction...', currentAttachmentData);

            try {
                const { transactionIndex, messageId, filename, pdfBlob, validation, extractedData } = currentAttachmentData;

                // Disable button during processing
                const attachBtn = document.getElementById('attachInvoiceBtn');
                const originalBtnText = attachBtn.textContent;
                attachBtn.disabled = true;
                attachBtn.textContent = '‚è≥ Attaching...';

                // Save PDF to IndexedDB
                const invoiceId = await saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId);

                // Extract text from PDF (might already be done during validation)
                const extractedText = await extractTextFromPDF(pdfBlob);

                // Generate AI description
                const aiDescription = await generateDescriptionFromInvoice(extractedText, allTransactions[transactionIndex]);

                // Initialize invoices array if it doesn't exist
                if (!allTransactions[transactionIndex].invoices) {
                    allTransactions[transactionIndex].invoices = [];
                }

                // Add invoice to array
                allTransactions[transactionIndex].invoices.push({
                    id: invoiceId,
                    filename: filename,
                    attachedAt: Date.now()
                });

                // Store invoice ID in transaction for backward compatibility
                allTransactions[transactionIndex].invoiceId = invoiceId;
                allTransactions[transactionIndex].invoiceFilename = filename;

                // Update transaction detail with AI-generated 2-10 word description (only if empty)
                if (aiDescription && !allTransactions[transactionIndex].detail) {
                    allTransactions[transactionIndex].detail = aiDescription;
                }

                // Update From/To (supplier) with extracted company name (only if empty)
                if (extractedData && extractedData.company && !allTransactions[transactionIndex].fromTo) {
                    allTransactions[transactionIndex].fromTo = extractedData.company;
                }

                // Log validation results for audit trail
                if (validation) {
                    console.log('üìä [ATTACH] Validation results:', {
                        invoiceId,
                        extractedData,
                        validation,
                        decision: 'attached'
                    });

                    // Optionally store validation data in invoice record
                    if (invoiceId && extractedData) {
                        await updateInvoiceWithValidationData(invoiceId, extractedData, validation);
                    }
                }

                // Save updated transactions
                await saveTransactionsToStorage();

                // Update UI
                renderTransactions();

                // Close modals
                closePDFPreview();
                closeIntelligentSearchModal();

                // Show success message with validation status - DISABLED (user preference)
                // let successMessage = `‚úÖ Invoice "${filename}" attached successfully!`;
                // if (validation) {
                //     if (validation.recommendation === 'attach') {
                //         successMessage += ' (AI validated ‚úì)';
                //     } else if (validation.recommendation === 'review') {
                //         successMessage += ' (Manual review recommended)';
                //     }
                // }
                // showToast(successMessage, 'success');

                console.log('‚úÖ [ATTACH] Invoice attached successfully, ID:', invoiceId);

            } catch (error) {
                console.error('Error attaching invoice:', error);
                showSimpleToast(`‚ùå Failed to attach invoice: ${error.message}`, 'error');

                // Re-enable button
                const attachBtn = document.getElementById('attachInvoiceBtn');
                attachBtn.disabled = false;
                attachBtn.textContent = '‚úÖ Attach Invoice';
            }
        }

        /**
         * Open an already-attached invoice from IndexedDB
         */
        async function openAttachedInvoice(transactionIndex) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.invoiceId) {
                showSimpleToast('‚ùå No invoice attached to this transaction', 'error');
                return;
            }

            console.log('üìÑ [VIEW] Opening attached invoice...', { invoiceId: transaction.invoiceId, filename: transaction.invoiceFilename });

            try {
                // Load invoice from IndexedDB
                const invoice = await getInvoiceFromDB(transaction.invoiceId);

                if (!invoice || !invoice.pdfBlob) {
                    showSimpleToast('‚ùå Invoice not found in database', 'error');
                    return;
                }

                // Show PDF preview modal
                const modal = document.getElementById('pdfPreviewModal');
                const iframe = document.getElementById('pdfViewerIframe');
                document.getElementById('pdfPreviewTitle').textContent = `Invoice: ${transaction.invoiceFilename || 'invoice.pdf'}`;

                modal.style.display = 'flex';

                // Create blob URL and show in iframe
                const blobUrl = URL.createObjectURL(invoice.pdfBlob);
                const container = document.getElementById('pdfViewerContainer');
                container.innerHTML = `<iframe id="pdfViewerIframe" style="width: 100%; height: 100%; border: none;"></iframe>`;
                const newIframe = document.getElementById('pdfViewerIframe');
                newIframe.src = blobUrl;

                // Hide validation section for viewing mode
                const validationContainer = document.getElementById('validationResultsContainer');
                if (validationContainer) {
                    validationContainer.style.display = 'none';
                }

                // Replace footer buttons with Delete and Close buttons
                const footerButtons = document.getElementById('pdfPreviewButtons');
                if (footerButtons) {
                    footerButtons.innerHTML = `
                        <button onclick="deleteAttachedInvoice(${transactionIndex})" class="btn-secondary" style="flex: 1; padding: 10px; font-size: 14px; font-weight: 600; background: #dc2626; color: white; border: none;">
                            üóëÔ∏è Delete Invoice
                        </button>
                        <button onclick="closePDFPreview()" class="btn-secondary" style="flex: 1; padding: 10px; font-size: 14px;">
                            ‚úñÔ∏è Close
                        </button>
                    `;
                }

                console.log('‚úÖ [VIEW] Invoice loaded successfully');

            } catch (error) {
                console.error('Error loading attached invoice:', error);
                showSimpleToast('‚ùå Failed to load invoice', 'error');
            }
        }

        /**
         * Get invoice from IndexedDB
         */
        async function getInvoiceFromDB(invoiceId) {
            if (!db) await initIndexedDB();

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['invoices'], 'readonly');
                const store = transaction.objectStore('invoices');
                const request = store.get(invoiceId);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        /**
         * Delete attached invoice from transaction
         */
        async function deleteAttachedInvoice(transactionIndex) {
            const transaction = allTransactions[transactionIndex];

            if (!transaction.invoiceId) {
                showSimpleToast('‚ùå No invoice to delete', 'error');
                return;
            }

            // Confirm deletion
            const confirmDelete = confirm(`Delete invoice "${transaction.invoiceFilename || 'invoice.pdf'}"?\n\nThis will remove the invoice attachment from this transaction. The invoice file will be deleted from the database.`);

            if (!confirmDelete) {
                return;
            }

            console.log('üóëÔ∏è [DELETE] Deleting invoice...', { invoiceId: transaction.invoiceId, filename: transaction.invoiceFilename });

            try {
                // Delete from IndexedDB
                if (!db) await initIndexedDB();

                await new Promise((resolve, reject) => {
                    const txn = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                    const store = txn.objectStore(INVOICES_STORE_NAME);
                    const request = store.delete(transaction.invoiceId);

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                // Remove invoice references from transaction
                delete transaction.invoiceId;
                delete transaction.invoiceFilename;

                // Save transactions to storage
                await saveTransactionsToStorage();

                // Close modal and refresh UI
                closePDFPreview();
                renderTransactions();

                // showSimpleToast('‚úÖ Invoice deleted successfully', 'success'); // DISABLED (user preference)
                console.log('‚úÖ [DELETE] Invoice deleted successfully');

            } catch (error) {
                console.error('Error deleting invoice:', error);
                showSimpleToast('‚ùå Failed to delete invoice', 'error');
            }
        }

        /**
         * Close PDF preview modal
         */
        function closePDFPreview() {
            const modal = document.getElementById('pdfPreviewModal');
            modal.style.display = 'none';

            // Restore original attach/cancel buttons for next use
            const footerButtons = document.getElementById('pdfPreviewButtons');
            if (footerButtons) {
                footerButtons.innerHTML = `
                    <button onclick="confirmAttachInvoice()" class="btn-primary" id="attachInvoiceBtn" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>‚úÖ</span>
                        <span>Attach Invoice</span>
                    </button>

                    <button onclick="openManualUploadFromPreview()" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: #3b82f6; color: white; border: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>üì§</span>
                        <span>Upload Different File</span>
                    </button>

                    <button onclick="closePDFPreview()" class="btn-secondary" style="width: 100%; padding: 10px; font-size: 14px;">
                        Cancel
                    </button>
                `;
            }

            // Reset validation UI
            const validationContainer = document.getElementById('validationResultsContainer');
            if (validationContainer) {
                validationContainer.style.display = 'none';

                // Reset all validation fields to default state
                ['company', 'amount', 'date'].forEach(field => {
                    const statusEl = document.getElementById(`${field}Status`);
                    const reasonEl = document.getElementById(`${field}Reason`);
                    const validationEl = document.getElementById(`${field}Validation`);

                    if (statusEl) statusEl.textContent = '‚è≥';
                    if (reasonEl) reasonEl.textContent = 'Analyzing...';
                    if (validationEl) {
                        validationEl.style.background = '#f8fafc';
                        validationEl.style.borderColor = '#e5e7eb';
                    }
                });

                // Reset recommendation
                const recommendationContainer = document.getElementById('validationRecommendation');
                if (recommendationContainer) {
                    recommendationContainer.style.background = '#f0f9ff';
                    recommendationContainer.style.borderColor = '#3b82f6';
                }

                const recommendationIcon = document.getElementById('recommendationIcon');
                const recommendationText = document.getElementById('recommendationText');
                if (recommendationIcon) recommendationIcon.textContent = 'ü§ñ';
                if (recommendationText) recommendationText.textContent = 'Analyzing invoice...';
            }

            // Reset attach button
            const attachBtn = document.getElementById('attachInvoiceBtn');
            if (attachBtn) {
                attachBtn.disabled = false;
                attachBtn.innerHTML = '<span>‚úÖ</span><span>Attach Invoice</span>';
                attachBtn.style.background = '';
            }

            // Clean up blob URL
            if (currentAttachmentData && currentAttachmentData.blobUrl) {
                URL.revokeObjectURL(currentAttachmentData.blobUrl);
            }

            currentAttachmentData = null;
        }

        // ========================================
        // MULTI-INVOICE MANAGER
        // ========================================

        let currentInvoiceManagerTransactionIndex = null;

        /**
         * Migrate old invoice format to new array format
         */
        function migrateInvoiceFormat(transaction) {
            // If transaction has old format (invoiceId) but no new format (invoices array)
            if (transaction.invoiceId && (!transaction.invoices || transaction.invoices.length === 0)) {
                transaction.invoices = [{
                    id: transaction.invoiceId,
                    filename: transaction.invoiceFilename || 'invoice.pdf',
                    attachedAt: Date.now()
                }];
                console.log('üì¶ [MIGRATE] Migrated invoice to new format:', transaction.invoices[0]);
            }
            return transaction;
        }

        /**
         * Open Invoice Manager Modal
         */
        async function openAttachedInvoiceManager(transactionIndex) {
            console.log('üìÑ [INVOICE-MANAGER] Opening manager for transaction', transactionIndex);
            currentInvoiceManagerTransactionIndex = transactionIndex;

            const transaction = allTransactions[transactionIndex];

            // Migrate old format if needed
            migrateInvoiceFormat(transaction);

            const invoices = transaction.invoices || [];

            // If there's exactly one invoice, open it directly in preview
            if (invoices.length === 1) {
                console.log('üìÑ [INVOICE-MANAGER] Only one invoice, opening directly');
                await viewInvoiceFromManager(0);
                return;
            }

            // Otherwise, show the list modal
            const modal = document.getElementById('invoiceManagerModal');
            const titleEl = document.getElementById('invoiceManagerTitle');
            const listContainer = document.getElementById('invoiceListContainer');

            titleEl.textContent = `Attached Documents (${invoices.length})`;

            // Build invoice list HTML
            let html = '';

            if (invoices.length === 0) {
                html = `
                    <div style="text-align: center; padding: 40px; color: #94a3b8;">
                        <div style="font-size: 48px; margin-bottom: 15px;">üìÑ</div>
                        <p style="margin: 0;">No documents attached yet</p>
                        <p style="margin: 10px 0 0 0; font-size: 13px;">Click "Add Another Document" or "Search Gmail" to attach</p>
                    </div>
                `;
            } else {
                invoices.forEach((invoice, idx) => {
                    const date = invoice.attachedAt ? new Date(invoice.attachedAt).toLocaleString() : 'Unknown';
                    html += `
                        <div style="display: flex; align-items: center; gap: 15px; padding: 15px; background: #f8fafc; border-radius: 8px; margin-bottom: 12px; border: 2px solid #e5e7eb;">
                            <div style="font-size: 36px; flex-shrink: 0;">üìÑ</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; color: #1e293b; font-size: 14px; margin-bottom: 4px;">
                                    ${escapeHtml(invoice.filename)}
                                </div>
                                <div style="color: #64748b; font-size: 12px;">
                                    Attached: ${escapeHtml(date)}
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; flex-shrink: 0;">
                                <button onclick="viewInvoiceFromManager(${idx})" class="btn-secondary" style="padding: 8px 16px; font-size: 13px; white-space: nowrap;">
                                    üëÅÔ∏è View
                                </button>
                                <button onclick="deleteInvoiceFromManager(${idx})" class="btn-secondary" style="padding: 8px 16px; font-size: 13px; background: #ef4444; color: white; border: none; white-space: nowrap;">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                        </div>
                    `;
                });
            }

            listContainer.innerHTML = html;
            modal.style.display = 'flex';
        }

        /**
         * Close Invoice Manager Modal
         */
        function closeInvoiceManager() {
            const modal = document.getElementById('invoiceManagerModal');
            modal.style.display = 'none';
            currentInvoiceManagerTransactionIndex = null;
            renderTransactions(); // Refresh UI to show updated count
        }

        /**
         * View specific invoice from manager
         */
        async function viewInvoiceFromManager(invoiceIndex) {
            const transactionIndex = currentInvoiceManagerTransactionIndex;
            if (transactionIndex === null) return;

            const transaction = allTransactions[transactionIndex];
            const invoice = transaction.invoices[invoiceIndex];

            if (!invoice) {
                showSimpleToast('‚ùå Invoice not found', 'error');
                return;
            }

            console.log('üìÑ [VIEW] Opening invoice:', invoice.filename);

            try {
                // Load invoice from IndexedDB
                const invoiceData = await getInvoiceFromDB(invoice.id);

                if (!invoiceData || !invoiceData.pdfBlob) {
                    showSimpleToast('‚ùå Invoice file not found in database', 'error');
                    return;
                }

                // Show PDF preview modal
                const modal = document.getElementById('pdfPreviewModal');
                const iframe = document.getElementById('pdfViewerIframe');
                document.getElementById('pdfPreviewTitle').textContent = `Invoice: ${invoice.filename}`;

                modal.style.display = 'flex';

                // Create blob URL and load in iframe
                const blobUrl = URL.createObjectURL(invoiceData.pdfBlob);
                iframe.src = blobUrl;

                // Update footer buttons to show all options
                const footerButtons = document.getElementById('pdfPreviewButtons');
                const transaction = allTransactions[transactionIndex];
                const hasMultipleInvoices = transaction.invoices && transaction.invoices.length > 1;

                if (footerButtons) {
                    footerButtons.innerHTML = `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%;">
                            ${hasMultipleInvoices ? `
                                <button onclick="closePDFPreview(); openAttachedInvoiceManager(${transactionIndex})" class="btn-secondary" style="padding: 10px; font-size: 13px;">
                                    ‚Üê Back to List
                                </button>
                            ` : `
                                <button onclick="closePDFPreview()" class="btn-secondary" style="padding: 10px; font-size: 13px;">
                                    ‚Üê Close
                                </button>
                            `}
                            <button onclick="closePDFPreview(); document.getElementById('addInvoiceInput').click();" class="modal-btn modal-btn-primary" style="padding: 10px; font-size: 13px; margin: 0;">
                                + Add Another
                            </button>
                        </div>
                        <button onclick="deleteInvoiceFromViewer(${invoiceIndex})" class="btn-secondary" style="width: 100%; padding: 12px; font-size: 14px; font-weight: 600; background: #ef4444; color: white; border: none; margin-top: 10px;">
                            üóëÔ∏è Delete Invoice
                        </button>
                    `;
                }

            } catch (error) {
                console.error('Error viewing invoice:', error);
                showSimpleToast('‚ùå Failed to load invoice', 'error');
            }
        }

        /**
         * Delete invoice from manager
         */
        async function deleteInvoiceFromManager(invoiceIndex) {
            const transactionIndex = currentInvoiceManagerTransactionIndex;
            if (transactionIndex === null) return;

            const transaction = allTransactions[transactionIndex];
            const invoice = transaction.invoices[invoiceIndex];

            if (!invoice) {
                showSimpleToast('‚ùå Invoice not found', 'error');
                return;
            }

            const confirmDelete = confirm(`Delete "${invoice.filename}"?\n\nThis will remove the invoice attachment from this transaction.`);
            if (!confirmDelete) return;

            console.log('üóëÔ∏è [DELETE] Deleting invoice:', invoice.filename);

            try {
                // Delete from IndexedDB
                if (!db) await initIndexedDB();

                await new Promise((resolve, reject) => {
                    const txn = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                    const store = txn.objectStore(INVOICES_STORE_NAME);
                    const request = store.delete(invoice.id);

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                // Remove from array
                transaction.invoices.splice(invoiceIndex, 1);

                // If no invoices left, clean up old format fields
                if (transaction.invoices.length === 0) {
                    delete transaction.invoiceId;
                    delete transaction.invoiceFilename;
                }

                // Save transactions
                await saveTransactionsToStorage();

                // Refresh manager modal
                await openAttachedInvoiceManager(transactionIndex);

                showSimpleToast('‚úÖ Invoice deleted successfully', 'success');
                console.log('‚úÖ [DELETE] Invoice deleted successfully');

            } catch (error) {
                console.error('Error deleting invoice:', error);
                showSimpleToast('‚ùå Failed to delete invoice', 'error');
            }
        }

        /**
         * Delete invoice from PDF viewer
         */
        async function deleteInvoiceFromViewer(invoiceIndex) {
            await deleteInvoiceFromManager(invoiceIndex);
            closePDFPreview();
            await openAttachedInvoiceManager(currentInvoiceManagerTransactionIndex);
        }

        /**
         * Trigger file picker to add another invoice
         */
        function addAnotherInvoice() {
            const input = document.getElementById('addInvoiceInput');
            input.value = ''; // Reset
            input.click();
        }

        /**
         * Handle files selected from "Add Another Document"
         */
        async function handleAddInvoiceFiles(files) {
            if (!files || files.length === 0) return;

            const transactionIndex = currentInvoiceManagerTransactionIndex;
            if (transactionIndex === null) {
                showSimpleToast('‚ùå No transaction selected', 'error');
                return;
            }

            console.log(`üì§ [ADD-INVOICE] Adding ${files.length} file(s) to transaction ${transactionIndex}`);

            const transaction = allTransactions[transactionIndex];
            if (!transaction.invoices) {
                transaction.invoices = [];
            }

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                console.log(`üìÑ [ADD-INVOICE] Processing file ${i + 1}/${files.length}: ${file.name}`);

                try {
                    // Save to IndexedDB
                    const invoiceId = await saveInvoiceToDB(file, transaction);

                    // Add to invoices array
                    transaction.invoices.push({
                        id: invoiceId,
                        filename: file.name,
                        attachedAt: Date.now()
                    });

                    successCount++;
                    console.log(`‚úÖ [ADD-INVOICE] File ${i + 1} added successfully: ${file.name}`);

                } catch (error) {
                    console.error(`‚ùå [ADD-INVOICE] Error adding file ${file.name}:`, error);
                    errorCount++;
                }
            }

            // Save transactions
            await saveTransactionsToStorage();

            // Show result
            if (successCount > 0) {
                showSimpleToast(`‚úÖ Added ${successCount} document(s)`, 'success');
            }
            if (errorCount > 0) {
                showSimpleToast(`‚ö†Ô∏è Failed to add ${errorCount} document(s)`, 'error');
            }

            // Close the invoice manager and return to spend page
            closeInvoiceManager();
        }

        /**
         * Open manual upload dialog from preview modal
         */
        function openManualUploadFromPreview() {
            // Close preview modal
            closePDFPreview();

            // Trigger manual file upload
            const fileInput = document.getElementById('manualInvoiceUpload');
            if (fileInput) {
                fileInput.click();
            }
        }

        /**
         * Show invoice attachment confirmation modal
         */
        function showInvoiceConfirmModal(messageId, attachmentId, filename, transactionIndex, accountEmail) {
            // Store pending attachment data
            pendingInvoiceAttachment = {
                messageId,
                attachmentId,
                filename,
                transactionIndex,
                accountEmail
            };

            // Update filename in modal
            document.getElementById('invoiceConfirmFilename').textContent = filename;

            // Show modal
            document.getElementById('invoiceConfirmModal').style.display = 'flex';
        }

        /**
         * Close invoice attachment confirmation modal
         */
        function closeInvoiceConfirmModal() {
            document.getElementById('invoiceConfirmModal').style.display = 'none';
            pendingInvoiceAttachment = null;
        }

        /**
         * Handle "Preview & Attach" button - opens full preview modal
         */
        function confirmPreviewAndAttach() {
            if (!pendingInvoiceAttachment) return;

            const { transactionIndex, messageId, attachmentId, filename, accountEmail } = pendingInvoiceAttachment;

            closeInvoiceConfirmModal();
            previewAndAttachInvoice(transactionIndex, messageId, attachmentId, filename, accountEmail);
        }

        /**
         * Handle "Attach Without Preview" button - proceeds with direct attachment
         */
        async function confirmDirectAttach() {
            if (!pendingInvoiceAttachment) return;

            const { messageId, attachmentId, filename, transactionIndex, accountEmail } = pendingInvoiceAttachment;

            closeInvoiceConfirmModal();
            await performDirectAttachment(messageId, attachmentId, filename, transactionIndex, accountEmail);
        }

        /**
         * Handle "Upload Manually Instead" button - opens file picker
         */
        function confirmManualUpload() {
            if (!pendingInvoiceAttachment) return;

            closeInvoiceConfirmModal();

            // Trigger the file input click
            const fileInput = document.getElementById('manualInvoiceUpload');
            if (fileInput) {
                fileInput.click();
            }
        }

        /**
         * Perform direct invoice attachment (without preview)
         */
        async function performDirectAttachment(messageId, attachmentId, filename, transactionIndex, accountEmail) {
            try {
                showSimpleToast('‚è≥ Downloading invoice...', 'info');

                // Get the access token for this account
                const account = gmailAccounts.find(acc => acc.email === accountEmail);
                if (!account) {
                    showSimpleToast('‚ùå Account not found', 'error');
                    return;
                }

                // Download PDF
                const pdfBlob = await downloadPDFAttachment(messageId, attachmentId, account.accessToken);
                if (!pdfBlob) {
                    showSimpleToast('‚ùå Failed to download invoice', 'error');
                    return;
                }

                // Save to IndexedDB
                const invoiceId = await saveInvoiceToDB(transactionIndex, pdfBlob, filename, messageId);

                // Update transaction object with invoice details so button changes to PDF view mode
                allTransactions[transactionIndex].invoiceId = invoiceId;
                allTransactions[transactionIndex].invoiceFilename = filename;

                // Extract text
                showSimpleToast('üìÑ Extracting text from invoice...', 'info');
                const extractedText = await extractTextFromPDF(pdfBlob);

                if (extractedText) {
                    // Update invoice with extracted text
                    await updateInvoiceText(invoiceId, extractedText);

                    // Generate AI description
                    showSimpleToast('ü§ñ Generating description...', 'info');
                    const aiDescription = await generateDescriptionFromInvoice(
                        extractedText,
                        allTransactions[transactionIndex]
                    );

                    if (aiDescription) {
                        await updateInvoiceWithAIDescription(invoiceId, aiDescription);

                        // Apply description to transaction
                        allTransactions[transactionIndex].manualDescription = aiDescription;
                    }
                }

                // Save updated transactions to IndexedDB for cross-page sync
                await saveTransactionsToStorage();

                // Render to show PDF button instead of invoice search button
                renderTransactions();
                // showSimpleToast('‚úÖ Invoice attached successfully!', 'success'); // DISABLED (user preference)
                closeInvoiceSearchModal();

            } catch (error) {
                console.error('Error attaching invoice:', error);
                showSimpleToast('‚ùå Failed to attach invoice', 'error');
            }
        }

        /**
         * Store validation data with invoice in IndexedDB
         */
        async function updateInvoiceWithValidationData(invoiceId, extractedData, validation) {
            if (!db) await initIndexedDB();

            try {
                const transaction = db.transaction([INVOICES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INVOICES_STORE_NAME);
                const getRequest = store.get(invoiceId);

                getRequest.onsuccess = () => {
                    const invoice = getRequest.result;
                    if (invoice) {
                        invoice.extractedData = extractedData;
                        invoice.validationResults = validation;
                        invoice.validatedAt = new Date().toISOString();
                        store.put(invoice);
                        console.log('‚úÖ [DB] Validation data stored with invoice');
                    }
                };
            } catch (error) {
                console.error('Error updating invoice with validation data:', error);
            }
        }

        /**
         * Convert base64 to Blob
         */
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteArrays = [];

            for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                const slice = byteCharacters.slice(offset, offset + 512);
                const byteNumbers = new Array(slice.length);

                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mimeType });
        }

        // ========================================
        // ADVANCED PDF TEXT EXTRACTION WITH OCR
        // ========================================

        /**
         * Extract text from PDF with OCR fallback
         */
        async function extractTextFromPDFAdvanced(pdfBlob) {
            console.log('üìÑ [EXTRACT] Starting advanced PDF text extraction...');

            try {
                // Method 1: Try PDF.js text extraction first (faster)
                const pdfText = await extractTextWithPDFjs(pdfBlob);

                if (pdfText && pdfText.length > 50) {
                    console.log('‚úÖ [EXTRACT] PDF.js extraction successful:', pdfText.length, 'characters');
                    return pdfText;
                }

                console.log('‚ö†Ô∏è [EXTRACT] PDF.js returned insufficient text, trying OCR...');

                // Method 2: Use OCR as fallback (slower but handles scanned PDFs)
                const ocrText = await extractTextWithOCR(pdfBlob);
                console.log('‚úÖ [EXTRACT] OCR extraction successful:', ocrText.length, 'characters');
                return ocrText;

            } catch (error) {
                console.error('‚ùå [EXTRACT] Text extraction failed:', error);
                return '';
            }
        }

        /**
         * Extract text using PDF.js
         */
        async function extractTextWithPDFjs(pdfBlob) {
            const arrayBuffer = await pdfBlob.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n';
            }

            return fullText.trim();
        }

        /**
         * Extract text using Tesseract OCR
         */
        async function extractTextWithOCR(pdfBlob) {
            // Convert PDF first page to image
            const arrayBuffer = await pdfBlob.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1); // OCR first page only for speed

            const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            // Run Tesseract OCR on the canvas
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                logger: m => console.log('OCR Progress:', m)
            });

            return text;
        }

        /**
         * Get exchange rate for a specific date
         * @param {string} fromCurrency - Source currency (e.g., 'USD')
         * @param {string} toCurrency - Target currency (e.g., 'GBP')
         * @param {Date} date - Date for historical rate
         * @returns {Promise<number>} Exchange rate (e.g., 0.79 means 1 USD = 0.79 GBP)
         */
        async function getExchangeRate(fromCurrency, toCurrency, date) {
            console.log(`üí± [EXCHANGE] Fetching ${fromCurrency} to ${toCurrency} rate for ${date.toLocaleDateString()}`);

            // Check if API key is configured
            const appId = localStorage.getItem('exchangeRateApiKey');
            const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format

            try {
                // Use OpenExchangeRates API
                // OpenExchangeRates uses USD as base currency, so we need to calculate cross-rates

                if (appId) {
                    // Option 1: Historical rates (if App ID is configured)
                    const url = `https://openexchangerates.org/api/historical/${dateStr}.json?app_id=${appId}`;

                    console.log(`   üì° Using OpenExchangeRates historical data for ${dateStr}`);
                    const response = await fetch(url);

                    if (!response.ok) {
                        if (response.status === 401) {
                            throw new Error(`Invalid App ID - please check your OpenExchangeRates App ID in settings`);
                        }
                        throw new Error(`API error: ${response.status}`);
                    }

                    const data = await response.json();

                    // OpenExchangeRates uses USD as base, so rates are USD to X
                    // If fromCurrency is USD, we can directly get the rate
                    if (fromCurrency === 'USD' && data.rates[toCurrency]) {
                        const rate = data.rates[toCurrency];
                        console.log(`   ‚úÖ Rate retrieved: 1 ${fromCurrency} = ${rate.toFixed(4)} ${toCurrency}`);
                        return rate;
                    }

                    // For other currency pairs, calculate cross-rate
                    // Example: EUR to GBP = (USD to GBP) / (USD to EUR)
                    if (data.rates[fromCurrency] && data.rates[toCurrency]) {
                        const rate = data.rates[toCurrency] / data.rates[fromCurrency];
                        console.log(`   ‚úÖ Cross-rate calculated: 1 ${fromCurrency} = ${rate.toFixed(4)} ${toCurrency}`);
                        return rate;
                    }

                    throw new Error(`Currency pair ${fromCurrency}/${toCurrency} not found in rates`);
                }

                // Option 2: Free API without App ID (latest rates only)
                console.log(`   ‚ö†Ô∏è No App ID configured, using latest rates (approximate)`);
                const fallbackUrl = `https://openexchangerates.org/api/latest.json?app_id=e30981c5ed1f418fb5cac0faf1dccfe4`;

                const response = await fetch(fallbackUrl);
                if (!response.ok) {
                    throw new Error(`Free API error: ${response.status}`);
                }

                const data = await response.json();

                // Calculate rate based on USD as base
                if (fromCurrency === 'USD' && data.rates[toCurrency]) {
                    const rate = data.rates[toCurrency];
                    console.log(`   ‚ö†Ô∏è Using current rate (historical not available): 1 ${fromCurrency} = ${rate.toFixed(4)} ${toCurrency}`);
                    console.log(`   üí° Tip: Add an OpenExchangeRates App ID in settings for accurate historical rates`);
                    return rate;
                }

                if (data.rates[fromCurrency] && data.rates[toCurrency]) {
                    const rate = data.rates[toCurrency] / data.rates[fromCurrency];
                    console.log(`   ‚ö†Ô∏è Using current cross-rate: 1 ${fromCurrency} = ${rate.toFixed(4)} ${toCurrency}`);
                    console.log(`   üí° Tip: Add an OpenExchangeRates App ID in settings for accurate historical rates`);
                    return rate;
                }

                throw new Error(`Currency ${fromCurrency}/${toCurrency} not found in rates`);

            } catch (error) {
                console.error(`‚ùå [EXCHANGE] Failed to get exchange rate:`, error);
                throw error;
            }
        }

        /**
         * Convert invoice amount to GBP if in foreign currency
         * @param {Object} invoiceData - Parsed invoice data with currency and amount
         * @param {string} invoiceDate - Invoice date in DD/MM/YYYY format
         * @returns {Promise<Object>} Conversion details
         */
        async function convertInvoiceAmount(invoiceData, invoiceDate) {
            const currency = (invoiceData.currency || 'GBP').toUpperCase().trim();
            const amount = parseFloat(invoiceData.invoiceAmount);

            console.log(`üí± [CONVERSION] Processing ${currency} ${amount.toFixed(2)}`);

            // Already in GBP - no conversion needed
            if (currency === 'GBP' || currency === '¬£') {
                console.log('   ‚úì Already in GBP, no conversion needed');
                return {
                    originalAmount: amount,
                    originalCurrency: 'GBP',
                    convertedAmount: amount,
                    exchangeRate: 1.0,
                    source: 'none',
                    needsConversion: false
                };
            }

            // Parse invoice date (DD/MM/YYYY)
            let date;
            try {
                const dateParts = invoiceDate.split('/');
                date = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);

                // Validate date
                if (isNaN(date.getTime())) {
                    throw new Error('Invalid date');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è [CONVERSION] Could not parse date, using today:', error);
                date = new Date();
            }

            try {
                // Get exchange rate
                const exchangeRate = await getExchangeRate(currency, 'GBP', date);
                const convertedAmount = amount * exchangeRate;

                console.log(`üí± [CONVERSION] ${currency} ${amount.toFixed(2)} ‚Üí GBP ${convertedAmount.toFixed(2)}`);
                console.log(`   Exchange rate: 1 ${currency} = ${exchangeRate.toFixed(4)} GBP (${date.toLocaleDateString('en-GB')})`);

                return {
                    originalAmount: amount,
                    originalCurrency: currency,
                    convertedAmount: convertedAmount,
                    exchangeRate: exchangeRate,
                    source: 'api',
                    conversionDate: date.toLocaleDateString('en-GB'),
                    needsConversion: true,
                    success: true
                };

            } catch (error) {
                console.error('‚ùå [CONVERSION] Exchange rate lookup failed:', error);

                // Return error state - manual entry will be required
                return {
                    originalAmount: amount,
                    originalCurrency: currency,
                    convertedAmount: null,
                    exchangeRate: null,
                    source: 'manual_required',
                    error: error.message,
                    needsConversion: true,
                    success: false
                };
            }
        }

        /**
         * Parse invoice data using AI
         */
        async function parseInvoiceWithAI(extractedText, transaction) {
            console.log('ü§ñ [AI PARSE] Analyzing invoice text with AI...');

            try {
                const apiKey = getOpenAIKey();
                if (!apiKey) {
                    console.log('‚ö†Ô∏è [AI PARSE] No API key, skipping AI parsing');
                    return null;
                }

                const prompt = `Extract the following information from this invoice text. Return ONLY valid JSON, nothing else.

Invoice Text:
${extractedText.substring(0, 3000)}

Expected Transaction:
- Date: ${transaction.date}
- Amount: ¬£${transaction.spent || transaction.received}
- Merchant: ${transaction.description}

Return JSON with this exact structure:
{
  "invoiceDate": "DD/MM/YYYY",
  "invoiceAmount": "35.00",
  "companyName": "Google",
  "currency": "GBP",
  "invoiceNumber": "...",
  "confidence": "high|medium|low"
}

CRITICAL INSTRUCTIONS FOR AMOUNT EXTRACTION:
1. The "invoiceAmount" field MUST be the FINAL TOTAL AMOUNT or GRAND TOTAL
2. Look for keywords: "Total Amount", "Grand Total", "Amount Due", "Balance Due", "Total", "Final Amount"
3. DO NOT use individual line item amounts - these are NOT the total
4. The total is usually at the BOTTOM of the invoice, often after:
   - "Net Total" or "Subtotal"
   - "VAT" or "Tax"
   - Multiple line items
5. If you see calculations like "Net Total + VAT = Total Amount", use the final result AFTER VAT
6. The total amount should match or be close to the Expected Transaction amount shown above
7. Common patterns:
   - "Total Amount: ¬£12,240.00" ‚Üê Use 12240.00
   - Line item: ¬£9,600.00, Line item: ¬£600.00, Total: ¬£10,200.00, VAT: ¬£2,040.00, Final: ¬£12,240.00 ‚Üê Use 12240.00
8. If multiple amounts appear, choose the one labeled as the total/grand total/amount due

CRITICAL INSTRUCTIONS FOR CURRENCY EXTRACTION:
1. The "currency" field MUST identify the invoice's currency (USD, GBP, EUR, etc.)
2. Look for currency indicators near the total amount:
   - Currency symbols: ¬£ (GBP), $ (USD), ‚Ç¨ (EUR)
   - Currency codes: "GBP", "USD", "EUR", "CAD", "AUD"
   - Text phrases: "US Dollars", "British Pounds", "Euros"
3. Common patterns:
   - "Total: $1,234.56" ‚Üí currency: "USD"
   - "Amount Due: ¬£500.00" ‚Üí currency: "GBP"
   - "Grand Total: 1.234,56 EUR" ‚Üí currency: "EUR"
   - "US$ 2,000.00" or "USD 2,000.00" ‚Üí currency: "USD"
4. If you see $ without clarification, check the company location/context:
   - US companies ‚Üí assume USD
   - UK companies ‚Üí likely GBP (rare to use $ for GBP)
   - Canadian companies ‚Üí likely CAD
5. If no clear currency indicator is found, use "GBP" as default (most common for UK transactions)
6. IMPORTANT: The currency applies to the "invoiceAmount" field - they must match

If you cannot find a field, use null. Do not include currency symbols in the amount field (numbers only).`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an invoice data extraction expert. Always return valid JSON only, no markdown or explanation.'
                            },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 300,
                        temperature: 0.1
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                let jsonStr = data.choices[0].message.content.trim();

                // Remove markdown code blocks if present
                jsonStr = jsonStr.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                const invoiceData = JSON.parse(jsonStr);
                console.log('‚úÖ [AI PARSE] Invoice data extracted:', invoiceData);

                // VALIDATION: Check if extracted amount seems to be a line item instead of total
                if (invoiceData.invoiceAmount) {
                    const extractedAmount = parseFloat(invoiceData.invoiceAmount);
                    const expectedAmount = parseFloat(transaction.spent || transaction.received);
                    const difference = Math.abs(extractedAmount - expectedAmount);
                    const percentDiff = (difference / expectedAmount) * 100;

                    if (percentDiff > 20) {
                        console.warn('‚ö†Ô∏è [AI PARSE] Extracted amount differs significantly from transaction!');
                        console.warn(`   Expected: ¬£${expectedAmount.toFixed(2)}`);
                        console.warn(`   Extracted: ¬£${extractedAmount.toFixed(2)}`);
                        console.warn(`   Difference: ${percentDiff.toFixed(1)}%`);
                        console.warn('   ‚Üí This might be a line item instead of the total amount!');

                        // Try to find all amounts in the text and suggest the correct one
                        // Matches: ¬£12,240.00, 12240.00, 9,600.00, ¬£9600, 10,200.00, etc.
                        const allAmounts = extractedText.match(/¬£?\d{1,3}(?:,\d{3})*(?:\.\d{2})?/g) || [];
                        const numericAmounts = allAmounts.map(a => parseFloat(a.replace(/[¬£,]/g, '')));
                        const closestAmount = numericAmounts.reduce((closest, current) => {
                            const currentDiff = Math.abs(current - expectedAmount);
                            const closestDiff = Math.abs(closest - expectedAmount);
                            return currentDiff < closestDiff ? current : closest;
                        }, extractedAmount);

                        if (closestAmount !== extractedAmount) {
                            console.warn(`   üí° Suggestion: Invoice likely contains ¬£${closestAmount.toFixed(2)} as the total`);
                            invoiceData.invoiceAmount = closestAmount.toFixed(2);
                            invoiceData.confidence = 'medium';
                            invoiceData._corrected = true;
                            console.log('   ‚úì Auto-corrected to closest matching amount');
                        }
                    }
                }

                // CURRENCY CONVERSION: If invoice is in foreign currency, convert to GBP
                if (invoiceData.currency && invoiceData.currency !== 'GBP' && invoiceData.invoiceDate) {
                    console.log('üí± [AI PARSE] Foreign currency detected, initiating conversion...');

                    try {
                        const conversionResult = await convertInvoiceAmount(invoiceData, invoiceData.invoiceDate);

                        // Store conversion info in the invoice data
                        invoiceData._conversion = conversionResult;

                        // If conversion was successful, update the invoiceAmount to GBP
                        if (conversionResult.success && conversionResult.convertedAmount) {
                            console.log(`‚úÖ [AI PARSE] Amount converted: ${conversionResult.originalCurrency} ${conversionResult.originalAmount.toFixed(2)} ‚Üí GBP ${conversionResult.convertedAmount.toFixed(2)}`);

                            // Keep original amount for display, but use converted for matching
                            invoiceData._originalAmount = invoiceData.invoiceAmount;
                            invoiceData._originalCurrency = invoiceData.currency;
                            invoiceData.invoiceAmount = conversionResult.convertedAmount.toFixed(2);
                            invoiceData.currency = 'GBP';
                        } else {
                            console.warn('‚ö†Ô∏è [AI PARSE] Currency conversion failed, will use original amount');
                            console.warn(`   User may need to manually verify ${conversionResult.originalCurrency} ${conversionResult.originalAmount.toFixed(2)}`);
                        }
                    } catch (error) {
                        console.error('‚ùå [AI PARSE] Currency conversion error:', error);
                        // Continue with original amount if conversion fails
                    }
                }

                return invoiceData;

            } catch (error) {
                console.error('‚ùå [AI PARSE] Failed to parse invoice:', error);
                return null;
            }
        }

        /**
         * Score invoice using actual PDF data (AI-enhanced)
         */
        function scoreInvoiceWithPDFData(invoiceData, transaction, context) {
            if (!invoiceData) {
                return null; // Fall back to email-based scoring
            }

            let score = 0;
            const scoring = {
                company: 0,
                amount: 0,
                date: 0,
                details: {}
            };

            // 1. COMPANY NAME MATCH (max 40 points)
            const merchantKeyword = extractCoreMerchantKeyword(context.merchantName);
            if (invoiceData.companyName) {
                const companyLower = invoiceData.companyName.toLowerCase();
                const merchantLower = merchantKeyword.toLowerCase();

                // Check for exact or partial keyword match
                if (companyLower.includes(merchantLower) || merchantLower.includes(companyLower)) {
                    score += 40;
                    scoring.company = 40;
                    scoring.details.companyMatch = `‚úì PDF shows "${invoiceData.companyName}"`;
                } else {
                    // Check space-removed variations (e.g., "our sqk accountancy" -> "oursqkaccountancy")
                    const noSpacesName = context.merchantName.replace(/\s+/g, '').toLowerCase();
                    const domainVariations = [
                        noSpacesName + '.co.uk',
                        noSpacesName + '.com',
                        noSpacesName + '.org.uk',
                        noSpacesName + '.uk',
                        noSpacesName
                    ];

                    const domainMatch = domainVariations.some(variant => companyLower.includes(variant));

                    if (domainMatch) {
                        score += 40;
                        scoring.company = 40;
                        scoring.details.companyMatch = `‚úì PDF shows "${invoiceData.companyName}" (matched ${noSpacesName} variation)`;
                    } else {
                        scoring.details.companyMatch = `‚ö† PDF shows "${invoiceData.companyName}" (expected ${merchantKeyword})`;
                    }
                }
            } else {
                scoring.details.companyMatch = `? Company not found in PDF`;
            }

            // 2. AMOUNT MATCH (max 35 points)
            if (invoiceData.invoiceAmount) {
                const pdfAmount = parseFloat(invoiceData.invoiceAmount);
                const txAmount = context.amount;

                // Build conversion info string if currency conversion occurred
                let conversionInfo = '';
                if (invoiceData._conversion && invoiceData._conversion.needsConversion) {
                    const conv = invoiceData._conversion;
                    if (conv.success) {
                        conversionInfo = ` [Converted from ${conv.originalCurrency} ${conv.originalAmount.toFixed(2)} @ rate ${conv.exchangeRate.toFixed(4)} on ${conv.conversionDate}]`;
                    } else {
                        conversionInfo = ` [‚ö†Ô∏è Conversion from ${conv.originalCurrency} failed - using original amount]`;
                    }
                }

                if (Math.abs(pdfAmount - txAmount) < 0.01) { // Exact match
                    score += 35;
                    scoring.amount = 35;
                    scoring.details.amountMatch = `‚úì PDF shows ¬£${pdfAmount.toFixed(2)} (exact match!)${conversionInfo}`;
                } else if (Math.abs(pdfAmount - txAmount) < 1.0) { // Within ¬£1
                    score += 25;
                    scoring.amount = 25;
                    scoring.details.amountMatch = `~ PDF shows ¬£${pdfAmount.toFixed(2)} (close match)${conversionInfo}`;
                } else {
                    scoring.details.amountMatch = `‚úó PDF shows ¬£${pdfAmount.toFixed(2)} (expected ¬£${txAmount.toFixed(2)})${conversionInfo}`;
                }

                // Add separate currency conversion detail if applicable
                if (invoiceData._conversion && invoiceData._conversion.needsConversion && invoiceData._conversion.success) {
                    scoring.details.currencyConversion = `üí± Currency converted: ${invoiceData._conversion.originalCurrency} ${invoiceData._conversion.originalAmount.toFixed(2)} ‚Üí GBP ¬£${invoiceData._conversion.convertedAmount.toFixed(2)}`;
                }
            } else {
                scoring.details.amountMatch = `? Amount not found in PDF`;
            }

            // 3. DATE PROXIMITY (max 25 points)
            if (invoiceData.invoiceDate) {
                try {
                    const parts = invoiceData.invoiceDate.split('/');
                    const pdfDate = new Date(parts[2], parts[1] - 1, parts[0]);
                    const txDate = context.date;
                    const daysDiff = Math.abs(Math.floor((pdfDate - txDate) / (1000 * 60 * 60 * 24)));

                    if (daysDiff === 0) {
                        score += 25;
                        scoring.date = 25;
                        scoring.details.dateMatch = `‚úì PDF date: ${invoiceData.invoiceDate} (same day!)`;
                    } else if (daysDiff <= 2) {
                        score += 20;
                        scoring.date = 20;
                        scoring.details.dateMatch = `‚úì PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    } else if (daysDiff <= 5) {
                        score += 15;
                        scoring.date = 15;
                        scoring.details.dateMatch = `~ PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    } else {
                        score += 5;
                        scoring.date = 5;
                        scoring.details.dateMatch = `‚ö† PDF date: ${invoiceData.invoiceDate} (${daysDiff} days)`;
                    }
                } catch (error) {
                    scoring.details.dateMatch = `? Could not parse PDF date: ${invoiceData.invoiceDate}`;
                }
            } else {
                scoring.details.dateMatch = `? Date not found in PDF`;
            }

            scoring.total = score;
            scoring.source = 'PDF_AI_ANALYSIS';
            scoring.invoiceNumber = invoiceData.invoiceNumber;

            return scoring;
        }

        /**
         * AI-powered merchant name interpretation
         * Handles bank-formatted names like "Mol*the It Bay" ‚Üí "The IT Bay"
         */
        async function interpretMerchantNameWithAI(bankMerchantName) {
            try {
                const apiKey = getOpenAIKey();
                if (!apiKey) {
                    console.log('No API key for merchant interpretation');
                    return null;
                }

                const prompt = `You are analyzing a merchant name from a bank statement. Bank statements often truncate, abbreviate, or format merchant names oddly.

Bank transaction description: "${bankMerchantName}"

Your task: Determine the likely ACTUAL company name and email domain.

Examples:
- "Mol*the It Bay" ‚Üí Company: "The IT Bay", Domain: "theitbay.com"
- "SQK ACCOUNTANCY" ‚Üí Company: "SQK Accountancy", Domain: "sqkaccountancy.co.uk"
- "AMZN MKTP UK" ‚Üí Company: "Amazon UK", Domain: "amazon.co.uk"
- "GOOGLE *GSUITE" ‚Üí Company: "Google", Domain: "google.com"

Return a JSON object with this exact format (no markdown, no explanation):
{
  "companyName": "The actual company name",
  "likelyDomain": "mostlikelydomain.com",
  "alternateDomains": ["otherpossible.com", "another.co.uk"],
  "searchKeywords": ["keyword1", "keyword2", "keyword3"]
}`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a merchant name interpreter. Return only valid JSON, nothing else.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 200,
                        temperature: 0.2,
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const result = JSON.parse(data.choices[0].message.content.trim());

                console.log('ü§ñ [AI MERCHANT] Interpreted:', {
                    original: bankMerchantName,
                    aiResult: result
                });

                return result;

            } catch (error) {
                console.error('AI merchant interpretation failed:', error);
                return null;
            }
        }

        /**
         * Generate smart search keywords using AI
         */
        async function generateAISearchKeywords(context) {
            try {
                // Use existing API key mechanism
                const apiKey = getOpenAIKey();
                if (!apiKey) {
                    console.log('No API key, skipping AI enhancement');
                    return null;
                }

                const prompt = `Given this purchase transaction, generate 5-7 search keywords that would appear in an invoice or receipt email.

Transaction details:
- Merchant: ${context.merchantName}
- Amount: ¬£${context.amount}
- Description: ${context.description}
${context.fromTo ? `- From/To: ${context.fromTo}` : ''}
${context.userContext ? `- Project: ${context.userContext}` : ''}
${context.userNotes ? `- User Notes: ${context.userNotes}` : ''}

Consider:
- Product/service names
- Order number patterns
- Common email subject line phrases
- Transaction confirmation phrases
- Any specific details mentioned in user notes

Return ONLY a comma-separated list of keywords, no explanation.`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: 'You are a search keyword generator. Return only comma-separated keywords, nothing else.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 100,
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                const keywords = data.choices[0].message.content.trim().split(',').map(k => k.trim());

                return keywords.slice(0, 7); // Limit to 7 keywords

            } catch (error) {
                console.error('AI keyword generation failed:', error);
                searchLogger.logProgress('AI enhancement skipped (no API key or error)', 'warning');
                return null; // Graceful fallback - continue without AI
            }
        }

        // ========================================
        // INVOICE SEARCH UI HANDLERS
        // ========================================

        /**
         * Show styled Gmail connection alert
         */
        function showGmailConnectionAlert(transactionIndex) {
            const transaction = allTransactions[transactionIndex];
            const modal = document.getElementById('intelligentSearchModal');
            const modalTitle = document.getElementById('searchModalTitle');
            const searchLogContainer = document.getElementById('searchLogContainer');
            const searchProgressBar = document.getElementById('searchProgressBar');
            const resultsContainer = document.getElementById('searchResultsContainer');
            const actionButtons = document.getElementById('searchActionButtons');

            // Show modal
            modal.style.display = 'flex';

            // Update title
            modalTitle.textContent = 'Gmail Connection Required';

            // Hide log and progress (but keep them in collapsed state)
            const logHeader = document.getElementById('searchLogHeader');
            if (logHeader) logHeader.style.display = 'none';
            searchLogContainer.style.display = 'none';
            searchProgressBar.style.display = 'none';

            // Populate transaction summary
            document.getElementById('searchTxDate').textContent = transaction.date || 'N/A';
            document.getElementById('searchTxAmount').textContent = `¬£${transaction.spent || transaction.received || '0'}`;
            document.getElementById('searchTxDesc').textContent = transaction.description || 'No description';

            // Show From/To if available
            if (transaction.from_to) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = transaction.from_to;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Show user notes if available
            if (transaction.manualDescription) {
                document.getElementById('searchTxNotesContainer').style.display = 'block';
                document.getElementById('searchTxNotes').textContent = transaction.manualDescription;
            } else {
                document.getElementById('searchTxNotesContainer').style.display = 'none';
            }

            // Show connection alert
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 12px; border: 3px solid #f59e0b; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);">
                    <div style="font-size: 64px; margin-bottom: 20px; animation: bounce 1s ease-in-out infinite;">üìß</div>
                    <h3 style="margin: 0 0 15px 0; color: #92400e; font-size: 24px; font-weight: 700;">
                        Gmail Not Connected
                    </h3>
                    <p style="color: #78350f; margin: 0 0 25px 0; font-size: 15px; line-height: 1.6; max-width: 400px; margin-left: auto; margin-right: auto;">
                        You need to connect your Gmail account to search for invoices automatically.
                        This allows the app to find matching invoices in your email.
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px; max-width: 300px; margin: 0 auto;">
                        <button onclick="connectGmailAndRetry(${transactionIndex})"
                            style="background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); color: white; padding: 14px 24px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 15px; box-shadow: 0 4px 10px rgba(58, 175, 169, 0.3); transition: all 0.2s;"
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(58, 175, 169, 0.4)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 10px rgba(58, 175, 169, 0.3)'">
                            üîó Connect Gmail Now
                        </button>
                        <button onclick="closeIntelligentSearchModal()"
                            style="background: #f3f4f6; color: #64748b; padding: 12px 24px; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s;"
                            onmouseover="this.style.background='#e5e7eb'"
                            onmouseout="this.style.background='#f3f4f6'">
                            Cancel
                        </button>
                    </div>

                    <div style="margin-top: 25px; padding: 15px; background: rgba(255, 255, 255, 0.6); border-radius: 8px; border-left: 4px solid #3AAFA9;">
                        <div style="font-size: 12px; color: #475569; text-align: left;">
                            <strong style="color: #1e293b; display: block; margin-bottom: 8px;">‚ÑπÔ∏è What happens next:</strong>
                            <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                                <li>You'll be asked to sign in to your Gmail account</li>
                                <li>Grant permission to read emails (search only)</li>
                                <li>Invoice search will start automatically</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <style>
                    @keyframes bounce {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(-10px); }
                    }
                </style>
            `;

            // Update action buttons
            actionButtons.innerHTML = '';
        }

        /**
         * Connect Gmail and retry invoice search
         */
        async function connectGmailAndRetry(transactionIndex) {
            console.log('üîó [CONNECT] Initiating Gmail connection from alert...');

            // Update modal to show connecting status
            const resultsContainer = document.getElementById('searchResultsContainer');
            resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 40px 20px;">
                    <div style="font-size: 48px; margin-bottom: 20px; animation: spin 2s linear infinite;">‚è≥</div>
                    <h4 style="margin: 0 0 10px 0; color: #1e293b;">Connecting to Gmail...</h4>
                    <p style="color: #64748b; font-size: 14px;">Please complete the sign-in process in the popup window.</p>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;

            try {
                // Attempt Gmail sign-in
                await signInToGmail();

                // Wait for auth to complete
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Check if connection was successful
                if (gmailAccounts.length > 0) {
                    console.log('‚úÖ [CONNECT] Gmail connected successfully, starting search...');

                    // Close the alert modal
                    closeIntelligentSearchModal();

                    // Show success toast
                    // showSimpleToast('‚úÖ Gmail connected! Starting invoice search...', 'success'); // DISABLED (user preference)

                    // Wait a moment then trigger the search
                    setTimeout(() => {
                        handleInvoiceFetch(transactionIndex);
                    }, 500);
                } else {
                    console.warn('‚ö†Ô∏è [CONNECT] Gmail connection incomplete');
                    resultsContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px; background: #fef2f2; border-radius: 12px; border: 2px solid #dc2626;">
                            <div style="font-size: 48px; margin-bottom: 15px;">‚ùå</div>
                            <h4 style="margin: 0 0 10px 0; color: #991b1b;">Connection Failed</h4>
                            <p style="color: #7f1d1d; margin: 0 0 20px 0;">
                                Unable to connect to Gmail. Please try again or check your browser permissions.
                            </p>
                            <div style="display: flex; gap: 10px; justify-content: center;">
                                <button onclick="connectGmailAndRetry(${transactionIndex})" class="btn-primary">
                                    Try Again
                                </button>
                                <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                    Close
                                </button>
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('‚ùå [CONNECT] Gmail connection error:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; background: #fef2f2; border-radius: 12px; border: 2px solid #dc2626;">
                        <div style="font-size: 48px; margin-bottom: 15px;">‚ùå</div>
                        <h4 style="margin: 0 0 10px 0; color: #991b1b;">Connection Error</h4>
                        <p style="color: #7f1d1d; margin: 0 0 20px 0;">
                            ${error.message || 'An error occurred while connecting to Gmail.'}
                        </p>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="connectGmailAndRetry(${transactionIndex})" class="btn-primary">
                                Try Again
                            </button>
                            <button onclick="closeIntelligentSearchModal()" class="btn-secondary">
                                Close
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        async function handleInvoiceFetch(index, event) {
            const transaction = allTransactions[index];
            currentInvoiceSearchIndex = index;

            // Check if Gmail is connected
            if (gmailAccounts.length === 0) {
                // Show styled alert modal instead of basic confirm
                showGmailConnectionAlert(index);
                return;
            }

            // Check for SHIFT or ALT key to open old modal-based search
            if (event && (event.shiftKey || event.altKey)) {
                console.log('üîç [INVOICE FETCH] Opening modal-based search (Shift/Alt held)');
                showIntelligentSearchModal(transaction, index);
                return;
            }

            // Check if clicking on icon for an existing task
            const existingTask = invoiceSearchQueue.tasks.find(t =>
                t.transactionIndex === index &&
                (t.status === 'pending' || t.status === 'running')
            );

            if (existingTask) {
                // Clicking on a searching icon should show the live log modal
                console.log('üîç [INVOICE FETCH] Opening live search log for existing task');
                showLiveSearchLog(existingTask);
                return;
            }

            // Check if clicking on completed task
            const completedTask = invoiceSearchQueue.tasks.find(t =>
                t.transactionIndex === index &&
                (t.status === 'completed' || t.status === 'failed')
            );

            if (completedTask) {
                console.log('üìä [INVOICE FETCH] Opening results for completed task');
                openSearchResults(completedTask.id);
                return;
            }

            console.log('üìß [INVOICE FETCH] Starting background search for:', {
                index,
                description: transaction.description,
                date: transaction.date,
                amount: transaction.spent || transaction.received
            });

            // Add to background queue
            const taskId = invoiceSearchQueue.addTask(transaction, index);

            // Show brief feedback on button
            const btn = document.getElementById(`invoiceBtn${index}`);
            if (btn) {
                btn.innerHTML = '‚úì';
                btn.style.background = '#10b981';
                btn.title = 'Search queued!';

                // Reset button after 1 second (will be updated by queue when search starts)
                setTimeout(() => {
                    if (btn) {
                        btn.innerHTML = '‚è≥';
                        btn.style.background = '#f59e0b';
                        btn.title = 'Queued...';
                    }
                }, 800);
            }

            // Show subtle notification
            console.log(`‚úÖ [INVOICE FETCH] Task ${taskId} added to queue`);
        }

        // Store interval for live progress updates
        let liveSearchProgressInterval = null;

        /**
         * Show live search log modal for a running task
         */
        function showLiveSearchLog(task) {
            const modal = document.getElementById('intelligentSearchModal');
            const resultsContainer = document.getElementById('searchResultsContainer');

            if (!modal) {
                console.error('Search modal not found');
                return;
            }

            // Clear any existing interval
            if (liveSearchProgressInterval) {
                clearInterval(liveSearchProgressInterval);
                liveSearchProgressInterval = null;
            }

            // Set title
            document.getElementById('searchModalTitle').textContent = 'Search In Progress...';

            // Populate transaction details
            const tx = task.transaction;
            document.getElementById('searchTxDate').textContent = tx.date || 'N/A';
            document.getElementById('searchTxAmount').textContent = `¬£${(tx.spent || tx.received || '0.00').toString().replace(/¬£/g, '')}`;
            document.getElementById('searchTxDesc').textContent = tx.description || 'N/A';

            if (tx.fromTo && tx.fromTo.trim()) {
                document.getElementById('searchTxFromToContainer').style.display = 'block';
                document.getElementById('searchTxFromTo').textContent = tx.fromTo;
            } else {
                document.getElementById('searchTxFromToContainer').style.display = 'none';
            }

            // Show progress bar
            const progressBar = document.getElementById('searchProgressBar');
            const progressFill = document.getElementById('searchProgressFill');
            const progressText = document.getElementById('searchProgressText');

            if (!progressBar || !progressFill || !progressText) {
                console.error('Progress elements not found in modal');
                return;
            }

            progressBar.style.display = 'block';

            // Show search log with live updates (collapsed by default)
            const logHeader = document.getElementById('searchLogHeader');
            const logContainer = document.getElementById('searchLogContainer');
            const logContent = document.getElementById('searchLogContent');

            if (logHeader) logHeader.style.display = 'flex';
            // Keep log minimized by default - user can click to expand if needed
            // if (logContainer) {
            //     logContainer.style.display = 'block';
            //     logContainer.style.maxHeight = '250px';
            // }

            // Function to render logs
            function renderLogs(currentTask) {
                if (!currentTask || !currentTask.logs || !logContent) return;

                const logColors = {
                    info: '#64748b',
                    success: '#10b981',
                    warning: '#f59e0b',
                    error: '#ef4444'
                };

                let logsHtml = currentTask.logs.map(log => {
                    const color = logColors[log.type] || logColors.info;
                    return `<div style="margin-bottom: 6px; font-size: 12px; color: ${color};">
                        <span style="opacity: 0.7;">[${log.time}]</span> ${log.message}
                    </div>`;
                }).join('');

                logContent.innerHTML = logsHtml;
                // Auto-scroll to bottom
                logContent.scrollTop = logContent.scrollHeight;
            }

            // Function to update the progress display
            function updateProgressDisplay() {
                const currentTask = invoiceSearchQueue.getTask(task.id);
                if (!currentTask) {
                    clearInterval(liveSearchProgressInterval);
                    return;
                }

                // Update progress bar
                progressFill.style.width = currentTask.progress + '%';
                progressText.textContent = `${currentTask.progress}% complete`;

                // Update logs
                renderLogs(currentTask);

                // Check if completed
                if (currentTask.status === 'completed' || currentTask.status === 'failed') {
                    clearInterval(liveSearchProgressInterval);
                    liveSearchProgressInterval = null;

                    // Auto-show results after brief delay
                    setTimeout(() => {
                        if (modal.style.display === 'flex') {
                            console.log('üéØ [LIVE LOG] Search completed, showing results automatically');
                            openSearchResults(currentTask.id);
                        }
                    }, 500);
                }
            }

            // Hide results container (show logs instead)
            resultsContainer.style.display = 'none';

            // Initial render
            renderLogs(task);

            // Set up live polling (every 500ms)
            updateProgressDisplay(); // Initial update
            liveSearchProgressInterval = setInterval(updateProgressDisplay, 500);

            modal.style.display = 'flex';
        }

        async function displayInvoiceSearchResults(messages, transaction) {
            const selectedCount = gmailAccounts.filter(acc => acc.selected).length;

            console.log('üéØ Starting two-stage invoice analysis for', messages.length, 'emails');

            // Start building HTML with progress indicator
            let html = `
                <div style="font-weight: 600; margin-bottom: 15px; padding: 12px; background: #f0f9ff; border-radius: 8px; border: 2px solid #3b82f6;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span style="font-size: 18px;">üìß</span>
                        <span style="color: #1e40af;">Found ${messages.length} email(s) across ${selectedCount} account(s)</span>
                    </div>
                    <div id="stage1Progress" style="font-size: 12px; color: #3b82f6; display: flex; align-items: center; gap: 6px;">
                        <span style="animation: pulse 1.5s infinite;">ü§ñ</span>
                        <span>Analyzing email content...</span>
                    </div>
                </div>
            `;

            // Create placeholder cards for each email
            for (const msg of messages) {
                try {
                    const account = gmailAccounts.find(acc => acc.email === msg.accountEmail);
                    if (!account) continue;

                    gapi.client.setToken({ access_token: account.accessToken });

                    // Get basic email info for display
                    const messageDetail = await gapi.client.gmail.users.messages.get({
                        userId: 'me',
                        id: msg.id,
                        format: 'metadata',
                        metadataHeaders: ['From', 'Subject', 'Date']
                    });

                    const headers = messageDetail.result.payload.headers;
                    const from = headers.find(h => h.name === 'From')?.value || 'Unknown';
                    const subject = headers.find(h => h.name === 'Subject')?.value || 'No Subject';
                    const date = headers.find(h => h.name === 'Date')?.value || '';

                    // Store in message object for later use
                    msg.from = from;
                    msg.subject = subject;
                    msg.date = date;

                    html += `
                        <div class="invoice-result-card" id="emailCard_${msg.id}">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-size: 12px; color: #3AAFA9; margin-bottom: 4px;">
                                        <strong>Account:</strong> ${escapeHtml(msg.accountEmail)}
                                    </div>
                                    <div style="font-weight: 600; margin-bottom: 4px; display: flex; align-items: center; gap: 8px;">
                                        <span>üìß ${escapeHtml(subject)}</span>
                                        <span id="stage1Badge_${msg.id}" style="font-size: 11px; padding: 2px 8px; border-radius: 12px; background: #e5e7eb; color: #64748b;">
                                            Analyzing...
                                        </span>
                                    </div>
                                    <div style="font-size: 13px; color: #666;">
                                        <strong>From:</strong> ${escapeHtml(from)}<br>
                                        <strong>Date:</strong> ${date}
                                    </div>
                                </div>
                                <div style="background: #3b82f6; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 14px; flex-shrink: 0;">
                                    ${matchIndex + 1}
                                </div>
                            </div>

                            <!-- Stage 1: Email Analysis Results (populated after analysis) -->
                            <div id="stage1Results_${msg.id}" style="display: none; margin-top: 12px;">
                                <!-- Populated after email analysis -->
                            </div>

                            <!-- Stage 2: PDF Analysis Results (hidden initially) -->
                            <div id="stage2Results_${msg.id}" style="display: none; margin-top: 12px;">
                                <!-- Populated after PDF analysis -->
                            </div>

                            <!-- PDF Attachment Buttons -->
                            <div id="pdfButtons_${msg.id}" style="margin-top: 12px;">
                                <!-- Populated after stage 1 -->
                            </div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error getting email metadata:', msg.id, error);
                }
            }

            document.getElementById('invoiceSearchResults').innerHTML = html;

            // ==========================================
            // STAGE 1: Email Content Analysis (FAST)
            // ==========================================

            try {
                const progressDiv = document.getElementById('stage1Progress');

                if (!progressDiv) {
                    console.warn('Progress div not found, skipping Stage 1');
                    return;
                }

                // Extract email metadata for AI analysis
                console.log('üìß Stage 1: Extracting email metadata...');
                const emailData = await Promise.all(
                    messages.map(msg => extractEmailMetadata(msg.id, msg.accountEmail))
                );

                // Filter out nulls
                const validEmailData = emailData.filter(e => e !== null);

                if (validEmailData.length === 0) {
                    progressDiv.innerHTML = `<span>‚ö†Ô∏è</span><span style="color: #f59e0b;">Could not extract email data</span>`;
                    return;
                }

                // Batch analyze all emails with AI
                progressDiv.innerHTML = `
                    <span style="animation: pulse 1.5s infinite;">ü§ñ</span>
                    <span>Running AI analysis on ${validEmailData.length} email(s)...</span>
                `;

                console.log('ü§ñ Stage 1: Analyzing emails with AI...');
                const stage1Results = await analyzeEmailsWithAI(validEmailData, transaction);

                // Update progress
                if (stage1Results) {
                    progressDiv.innerHTML = `
                        <span>‚úÖ</span>
                        <span style="color: #10b981; font-weight: 600;">Email analysis complete! Loading PDFs...</span>
                    `;

                    // Update UI with Stage 1 results
                    stage1Results.forEach(result => {
                        const email = messages[result.emailIndex];
                        if (!email) return;

                        const badge = document.getElementById(`stage1Badge_${email.id}`);
                        if (badge) {
                            const matchIcon = result.preliminaryScore >= 80 ? 'üéØ' :
                                             result.preliminaryScore >= 60 ? '‚úÖ' : '‚ö†Ô∏è';
                            const matchColor = result.preliminaryScore >= 80 ? '#10b981' :
                                              result.preliminaryScore >= 60 ? '#22c55e' : '#f59e0b';

                            badge.style.background = matchColor;
                            badge.style.color = 'white';
                            badge.innerHTML = `${matchIcon} ${result.preliminaryScore}% (Email)`;
                            badge.title = result.reasoning || 'Email analysis score';
                        }

                        // Populate Stage 1 results table with extracted email information
                        const stage1Container = document.getElementById(`stage1Results_${email.id}`);
                        if (stage1Container) {
                            const emailData = validEmailData.find(e => e.messageId === email.id);

                            stage1Container.style.display = 'block';
                            stage1Container.innerHTML = `
                                <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #fbbf24; border-radius: 8px; padding: 12px;">
                                    <div style="font-size: 11px; font-weight: 600; color: #92400e; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span>üìß</span>
                                        <span>EMAIL PREVIEW (Before opening PDF)</span>
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 8px;">
                                        <div>
                                            <div style="font-size: 10px; color: #92400e; font-weight: 600; margin-bottom: 3px;">COMPANY MENTIONED</div>
                                            <div style="font-size: 12px; color: #1e293b; font-weight: 600;">${escapeHtml(result.companyMentioned || '-')}</div>
                                        </div>
                                        <div>
                                            <div style="font-size: 10px; color: #92400e; font-weight: 600; margin-bottom: 3px;">SENDER RELEVANCE</div>
                                            <div style="font-size: 12px; color: #1e293b; font-weight: 600; text-transform: capitalize;">
                                                ${result.senderRelevance || '-'}
                                                ${result.senderRelevance === 'high' ? '‚úÖ' : result.senderRelevance === 'medium' ? '‚ö†Ô∏è' : '‚ùå'}
                                            </div>
                                        </div>
                                        <div>
                                            <div style="font-size: 10px; color: #92400e; font-weight: 600; margin-bottom: 3px;">INVOICE KEYWORDS</div>
                                            <div style="font-size: 12px; color: #1e293b; font-weight: 600;">
                                                ${result.hasInvoiceKeywords ? 'Yes ‚úÖ' : 'No ‚ùå'}
                                            </div>
                                        </div>
                                        <div>
                                            <div style="font-size: 10px; color: #92400e; font-weight: 600; margin-bottom: 3px;">MATCH SCORE</div>
                                            <div style="font-size: 12px; color: #1e293b; font-weight: 600;">${result.preliminaryScore}%</div>
                                        </div>
                                    </div>
                                    ${emailData ? `
                                    <div style="background: white; padding: 8px; border-radius: 4px; margin-top: 8px;">
                                        <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">EMAIL SNIPPET:</div>
                                        <div style="font-size: 11px; color: #475569; font-style: italic; line-height: 1.4;">
                                            "${escapeHtml(emailData.snippet.substring(0, 200))}${emailData.snippet.length > 200 ? '...' : ''}"
                                        </div>
                                    </div>
                                    ` : ''}
                                    <div style="background: white; padding: 8px; border-radius: 4px; margin-top: 8px;">
                                        <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">AI REASONING:</div>
                                        <div style="font-size: 11px; color: #475569;">
                                            ${escapeHtml(result.reasoning || 'No reasoning provided')}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    });
                } else {
                    progressDiv.innerHTML = `
                        <span>‚ö†Ô∏è</span>
                        <span style="color: #f59e0b;">Stage 1 skipped (no API key or error)</span>
                    `;
                }

                // ==========================================
                // GET PDF LISTS & CREATE PRIORITY QUEUE
                // ==========================================

                console.log('üìé Getting PDF lists for each email...');
                const pdfsMap = new Map();

                for (const msg of messages) {
                    try {
                        const account = gmailAccounts.find(acc => acc.email === msg.accountEmail);
                        if (!account) continue;

                        gapi.client.setToken({ access_token: account.accessToken });
                        const pdfs = await extractPDFsFromEmail(msg.id, account.accessToken);

                        pdfsMap.set(msg.id, pdfs);

                        // Show PDF buttons
                        const buttonsContainer = document.getElementById(`pdfButtons_${msg.id}`);
                        if (!buttonsContainer) continue;

                        if (pdfs.length > 0) {
                            buttonsContainer.innerHTML = `
                                <div style="font-size: 12px; font-weight: 600; color: #64748b; margin-bottom: 6px;">
                                    Attachments (${pdfs.length}):
                                </div>
                            `;
                            pdfs.forEach(pdf => {
                                buttonsContainer.innerHTML += `
                                    <button
                                        onclick="attachInvoiceToTransaction('${escapeJs(msg.id)}', '${escapeJs(pdf.attachmentId)}', '${escapeJs(pdf.filename)}', ${currentInvoiceSearchIndex}, '${escapeJs(msg.accountEmail)}')"
                                        class="modal-btn modal-btn-primary pdf-attachment-btn"
                                        style="margin-top: 6px;">
                                        üìé ${escapeHtml(pdf.filename)} (${formatFileSize(pdf.size)})
                                    </button>
                                `;
                            });

                            // Add "Open in Gmail" button
                            buttonsContainer.innerHTML += `
                                <button
                                    onclick="openEmailInGmail('${escapeJs(msg.id)}', '${escapeJs(msg.accountEmail)}')"
                                    class="modal-btn modal-btn-primary"
                                    style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 8px;">
                                    <span style="font-size: 16px;">üìß</span>
                                    <span>Open in Gmail</span>
                                </button>
                            `;
                        } else {
                            buttonsContainer.innerHTML = `
                                <div style="background: #fffbeb; border-radius: 6px; padding: 12px; border: 1px dashed #f59e0b;">
                                    <div style="color: #d97706; font-size: 12px; text-align: center; margin-bottom: 10px; font-weight: 600;">
                                        ‚ö†Ô∏è No PDF attachments found
                                    </div>
                                    <button
                                        onclick="openEmailInGmail('${escapeJs(msg.id)}', '${escapeJs(msg.accountEmail)}')"
                                        class="modal-btn modal-btn-primary"
                                        style="background: linear-gradient(135deg, #EA4335 0%, #C5221F 100%); display: flex; align-items: center; justify-content: center; gap: 8px;">
                                        <span style="font-size: 16px;">üìß</span>
                                        <span>Open in Gmail</span>
                                    </button>
                                    <div style="font-size: 10px; color: #92400e; text-align: center; margin-top: 8px;">
                                        The invoice may be in the email body or as a link
                                    </div>
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error('Error getting PDFs for message:', msg.id, error);
                    }
                }

                // ==========================================
                // STAGE 2: Smart PDF Analysis (PRIORITIZED)
                // ==========================================

                if (stage1Results) {
                    console.log('üéØ Stage 2: Creating priority queue...');
                    const queue = createPriorityQueue(messages, stage1Results, pdfsMap);

                    if (queue.length > 0) {
                        progressDiv.innerHTML = `
                            <span style="animation: pulse 1.5s infinite;">üìÑ</span>
                            <span>Analyzing ${queue.length} PDF(s) in priority order...</span>
                        `;

                        console.log('üìÑ Stage 2: Processing PDFs...');
                        await processQueueWithPriority(queue, transaction, (messageId, result) => {
                            updateStage2Display(messageId, result);
                        });

                        // Final update
                        progressDiv.innerHTML = `
                            <span>‚úÖ</span>
                            <span style="color: #10b981; font-weight: 600;">Analysis complete! Results sorted by match score.</span>
                        `;
                    } else {
                        progressDiv.innerHTML = `
                            <span>‚ÑπÔ∏è</span>
                            <span style="color: #3b82f6;">No PDFs to analyze</span>
                        `;
                    }
                } else {
                    console.log('‚è≠Ô∏è Skipping Stage 2 (Stage 1 not completed)');
                    if (progressDiv) {
                        progressDiv.innerHTML = `
                            <span>‚ÑπÔ∏è</span>
                            <span style="color: #3b82f6;">PDF analysis skipped (Stage 1 incomplete)</span>
                        `;
                    }
                }

            } catch (error) {
                console.error('Invoice analysis error:', error);
                const progressDiv = document.getElementById('stage1Progress');
                if (progressDiv) {
                    progressDiv.innerHTML = `
                        <span>‚ùå</span>
                        <span style="color: #ef4444;">Analysis error: ${error.message}</span>
                    `;
                }
            }
        }

        async function attachInvoiceToTransaction(messageId, attachmentId, filename, transactionIndex, accountEmail) {
            // Go directly to preview mode
            previewAndAttachInvoice(transactionIndex, messageId, attachmentId, filename, accountEmail);
        }

        async function handleManualInvoiceUpload() {
            const fileInput = document.getElementById('manualInvoiceUpload');
            const files = Array.from(fileInput.files);

            if (!files || files.length === 0) {
                showSimpleToast('‚ùå Please select at least one file', 'error');
                return;
            }

            if (currentInvoiceSearchIndex === null) {
                showSimpleToast('‚ùå No transaction selected', 'error');
                return;
            }

            const transaction = allTransactions[currentInvoiceSearchIndex];
            if (!transaction.invoices) {
                transaction.invoices = [];
            }

            console.log(`üìé [MANUAL UPLOAD] Starting upload of ${files.length} file(s)...`);

            let successCount = 0;
            let errorCount = 0;

            try {
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];

                    // Accept PDFs and images
                    const isPDF = file.type === 'application/pdf';
                    const isImage = file.type.startsWith('image/');

                    if (!isPDF && !isImage) {
                        console.warn(`‚ö†Ô∏è [MANUAL UPLOAD] Skipping non-PDF/image file: ${file.name}`);
                        errorCount++;
                        continue;
                    }

                    try {
                        showSimpleToast(`‚è≥ Uploading ${i + 1}/${files.length}: ${file.name}...`, 'info');

                        console.log(`üìé [MANUAL UPLOAD] Processing file ${i + 1}/${files.length}:`, {
                            filename: file.name,
                            fileType: file.type,
                            isPDF,
                            isImage
                        });

                        // Preserve original file type in blob
                        const fileBlob = new Blob([await file.arrayBuffer()], { type: file.type });
                        const invoiceId = await saveInvoiceToDB(currentInvoiceSearchIndex, fileBlob, file.name, null);

                        // Add to invoices array
                        transaction.invoices.push({
                            id: invoiceId,
                            filename: file.name,
                            attachedAt: Date.now()
                        });

                        // Update backward compatibility fields (use first invoice)
                        if (transaction.invoices.length === 1) {
                            transaction.invoiceId = invoiceId;
                            transaction.invoiceFilename = file.name;
                        }

                        // Extract and process (only for PDFs - images would need OCR)
                        if (isPDF) {
                            const extractedText = await extractTextFromPDF(fileBlob);

                            if (extractedText) {
                                await updateInvoiceText(invoiceId, extractedText);

                                // Only generate description for first invoice if transaction has no detail
                                if (i === 0 && !transaction.detail) {
                                    const aiDescription = await generateDescriptionFromInvoice(
                                        extractedText,
                                        transaction
                                    );

                                    if (aiDescription) {
                                        await updateInvoiceWithAIDescription(invoiceId, aiDescription);
                                        transaction.manualDescription = aiDescription;
                                    }
                                }
                            }
                        }

                        successCount++;
                        console.log(`‚úÖ [MANUAL UPLOAD] File ${i + 1}/${files.length} uploaded: ${file.name}`);

                    } catch (error) {
                        console.error(`‚ùå [MANUAL UPLOAD] Error uploading file ${file.name}:`, error);
                        errorCount++;
                    }
                }

                // Save updated transactions to IndexedDB for cross-page sync
                await saveTransactionsToStorage();

                // Render to show PDF button instead of invoice search button
                renderTransactions();

                // Show summary
                if (successCount > 0) {
                    showSimpleToast(`‚úÖ Uploaded ${successCount} document(s) successfully!`, 'success');
                }
                if (errorCount > 0) {
                    showSimpleToast(`‚ö†Ô∏è Failed to upload ${errorCount} file(s)`, 'error');
                }

                closeInvoiceSearchModal();

            } catch (error) {
                console.error('Manual upload error:', error);
                showSimpleToast('‚ùå Failed to upload invoices', 'error');
            } finally {
                fileInput.value = ''; // Reset input
            }
        }

        // Initialize drag-and-drop and clipboard paste for manual upload
        function initializeManualUploadFeatures() {
            const dropZone = document.getElementById('manualUploadDropZone');
            if (!dropZone) return;

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            // Highlight drop zone when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.background = 'linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%)';
                    dropZone.style.borderColor = '#2563eb';
                    dropZone.style.borderWidth = '3px';
                    dropZone.style.transform = 'scale(1.02)';
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.background = 'linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%)';
                    dropZone.style.borderColor = '#3b82f6';
                    dropZone.style.borderWidth = '2px';
                    dropZone.style.transform = 'scale(1)';
                }, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files && files.length > 0) {
                    const fileInput = document.getElementById('manualInvoiceUpload');
                    fileInput.files = files;
                    handleManualInvoiceUpload();
                }
            }

            // Handle clipboard paste (for screenshots and images) - FOCUSED ON INPUT
            const pasteInput = document.getElementById('pasteImageInput');
            let pastedImageFile = null;

            document.addEventListener('paste', handlePaste);

            function handlePaste(e) {
                // Only handle paste when intelligent search modal is visible
                const modal = document.getElementById('intelligentSearchModal');
                if (!modal || modal.style.display === 'none') return;

                const items = e.clipboardData?.items;
                if (!items) return;

                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        const blob = items[i].getAsFile();
                        if (blob) {
                            e.preventDefault();

                            // Create a File object with a name
                            const file = new File([blob], `pasted-image-${Date.now()}.png`, { type: blob.type });
                            pastedImageFile = file;

                            // Show preview
                            const reader = new FileReader();
                            reader.onload = function(event) {
                                const preview = document.getElementById('pasteImagePreview');
                                const previewImg = document.getElementById('pasteImagePreviewImg');
                                previewImg.src = event.target.result;
                                preview.style.display = 'block';

                                // Update input placeholder
                                pasteInput.placeholder = 'Image ready to upload - click "Upload PDF or Image" button';
                            };
                            reader.readAsDataURL(blob);

                            // Automatically upload the pasted image
                            const fileInput = document.getElementById('manualInvoiceUpload');
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            fileInput.files = dataTransfer.files;
                            handleManualInvoiceUpload();

                            showSimpleToast('üìã Processing pasted image...', 'info');
                            break;
                        }
                    }
                }
            }
        }

        // Clear pasted image preview
        function clearPastedImage() {
            document.getElementById('pasteImagePreview').style.display = 'none';
            document.getElementById('pasteImagePreviewImg').src = '';
            document.getElementById('pasteImageInput').placeholder = 'Click here and press Ctrl+V to paste screenshot';
            pastedImageFile = null;
        }

        // Initialize when modal is opened (call this when opening the intelligent search modal)
        function initManualUploadOnModalOpen() {
            setTimeout(() => {
                initializeManualUploadFeatures();
            }, 100);
        }

        function closeInvoiceSearchModal() {
            document.getElementById('invoiceSearchModal').classList.remove('active');
            currentInvoiceSearchIndex = null;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ========================================
        // TWO-STAGE INVOICE ANALYSIS SYSTEM
        // ========================================

        /**
         * STAGE 1: Extract email metadata (subject, from, snippet)
         * This is fast - no PDF downloads yet
         */
        async function extractEmailMetadata(messageId, accountEmail) {
            try {
                const account = gmailAccounts.find(acc => acc.email === accountEmail);
                if (!account) return null;

                gapi.client.setToken({ access_token: account.accessToken });

                const response = await gapi.client.gmail.users.messages.get({
                    userId: 'me',
                    id: messageId,
                    format: 'full'
                });

                const message = response.result;
                const headers = message.payload.headers;

                return {
                    messageId,
                    subject: headers.find(h => h.name === 'Subject')?.value || 'No Subject',
                    from: headers.find(h => h.name === 'From')?.value || 'Unknown',
                    date: headers.find(h => h.name === 'Date')?.value || '',
                    snippet: message.snippet || '',
                    accountEmail
                };
            } catch (error) {
                console.error('Error extracting email metadata:', error);
                return null;
            }
        }

        /**
         * STAGE 1: Batch analyze all emails with AI (no PDF downloads)
         * Returns preliminary match scores based on subject line and email body
         */
        async function analyzeEmailsWithAI(emailData, transaction) {
            const API_KEY = getOpenAIKey();
            if (!API_KEY) {
                console.warn('No OpenAI key, skipping Stage 1 analysis');
                return null;
            }

            try {
                // Build batch analysis prompt
                const emailSummaries = emailData.map((email, idx) => {
                    return `Email ${idx + 1}:
Subject: ${email.subject}
From: ${email.from}
Date: ${email.date}
Body Preview: ${email.snippet}
---`;
                }).join('\n\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are analyzing emails to find invoices matching a transaction.

Transaction Details:
Company: ${transaction.description}
Amount: ${transaction.currency}${Math.abs(transaction.amount)}
Date: ${new Date(transaction.date).toLocaleDateString()}

Analyze each email and return a JSON array with preliminary match scores.
For each email, extract what you can see from the subject and body preview.

Return JSON array format:
[
  {
    "emailIndex": 0,
    "companyMentioned": "Anthropic",
    "hasInvoiceKeywords": true,
    "senderRelevance": "high",
    "preliminaryScore": 85,
    "reasoning": "Subject contains 'Invoice', sender domain matches company name"
  }
]

Score 0-100 where:
- 80-100: Strong match (invoice keywords + company match)
- 60-79: Possible match (some indicators present)
- 0-59: Weak match (few or no indicators)
`
                            },
                            {
                                role: 'user',
                                content: emailSummaries
                            }
                        ],
                        temperature: 0.1,
                        max_tokens: 1500
                    })
                });

                if (!response.ok) {
                    console.error('Stage 1 API error:', response.status);
                    return null;
                }

                const data = await response.json();
                const results = JSON.parse(data.choices[0].message.content);

                console.log('üìß Stage 1 Analysis Results:', results);
                return results;

            } catch (error) {
                console.error('Stage 1 analysis error:', error);
                return null;
            }
        }

        /**
         * Create priority queue sorted by Stage 1 scores
         * High-scoring emails get their PDFs analyzed first
         */
        function createPriorityQueue(messages, stage1Results, pdfsMap) {
            if (!stage1Results) return [];

            const queue = [];

            messages.forEach((msg, idx) => {
                const analysis = stage1Results.find(r => r.emailIndex === idx);
                if (!analysis) return;

                const pdfs = pdfsMap.get(msg.id) || [];

                // Each PDF in this email gets the email's preliminary score
                pdfs.forEach(pdf => {
                    queue.push({
                        messageId: msg.id,
                        accountEmail: msg.accountEmail,
                        attachmentId: pdf.attachmentId,
                        filename: pdf.filename,
                        size: pdf.size,
                        preliminaryScore: analysis.preliminaryScore,
                        stage1Data: analysis
                    });
                });
            });

            // Sort by preliminary score (highest first)
            queue.sort((a, b) => b.preliminaryScore - a.preliminaryScore);

            console.log('üìä Priority Queue created:', queue);
            return queue;
        }

        /**
         * STAGE 2: Process PDFs in priority order
         * High-scoring items analyzed first, all PDFs will be processed
         */
        async function processQueueWithPriority(queue, transaction, updateCallback) {
            const MAX_CONCURRENT = 2; // Analyze 2 PDFs at a time

            console.log(`üìä Queue: ${queue.length} PDFs to analyze (sorted by priority)`);

            // Process ALL items in priority order (no threshold filtering)
            const results = [];
            for (let i = 0; i < queue.length; i += MAX_CONCURRENT) {
                const batch = queue.slice(i, i + MAX_CONCURRENT);

                const batchPromises = batch.map(item =>
                    analyzeSinglePDFStage2(item, transaction).then(result => {
                        // Update UI immediately as each completes
                        updateCallback(item.messageId, result);
                        return result;
                    }).catch(error => {
                        console.error(`PDF analysis failed for ${item.filename}:`, error);
                        updateCallback(item.messageId, {
                            status: 'failed',
                            filename: item.filename,
                            error: error.message
                        });
                        return null;
                    })
                );

                const batchResults = await Promise.allSettled(batchPromises);
                results.push(...batchResults);
            }

            return results;
        }

        /**
         * STAGE 2: Analyze a single PDF with full extraction
         */
        async function analyzeSinglePDFStage2(item, transaction) {
            try {
                console.log(`üìÑ Analyzing PDF: ${item.filename}`);

                // 1. Download PDF
                const account = gmailAccounts.find(acc => acc.email === item.accountEmail);
                if (!account) throw new Error('Account not found');

                const pdfBlob = await downloadPDFAttachment(item.messageId, item.attachmentId, account.accessToken);
                if (!pdfBlob) throw new Error('PDF download failed');

                // 2. Extract text
                const pdfText = await extractTextFromPDF(pdfBlob);
                if (!pdfText || pdfText.length < 50) {
                    throw new Error('Could not extract text from PDF');
                }

                // 3. Analyze with AI
                const analysis = await extractInvoiceDataWithAI(pdfText, transaction);
                if (!analysis) throw new Error('AI analysis failed');

                return {
                    status: 'analyzed',
                    filename: item.filename,
                    preliminaryScore: item.preliminaryScore,
                    data: analysis,
                    transactionAmount: Math.abs(transaction.amount),
                    transactionDate: transaction.date
                };

            } catch (error) {
                console.error('Stage 2 PDF analysis error:', error);
                throw error;
            }
        }

        /**
         * Extract structured invoice data from PDF text using AI
         */
        async function extractInvoiceDataWithAI(pdfText, transaction) {
            const API_KEY = getOpenAIKey();
            if (!API_KEY) return null;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `Extract invoice data as JSON. Return only valid JSON with this structure:
{
  "company": "Company Name",
  "amount": 123.45,
  "currency": "GBP",
  "date": "2025-09-09",
  "invoiceNumber": "INV-123",
  "confidence": {
    "company": 0.95,
    "amount": 1.0,
    "date": 0.90
  }
}

Always return valid JSON. If data is missing, use null.`
                            },
                            {
                                role: 'user',
                                content: `Transaction: ${transaction.description} - ${transaction.currency}${Math.abs(transaction.amount)} on ${new Date(transaction.date).toLocaleDateString()}

PDF Text (first 4000 chars):
${pdfText.substring(0, 4000)}

Extract the invoice data.`
                            }
                        ],
                        temperature: 0.1,
                        max_tokens: 400
                    })
                });

                if (!response.ok) {
                    console.error('AI extraction API error:', response.status);
                    return null;
                }

                const data = await response.json();
                const extracted = JSON.parse(data.choices[0].message.content);

                // Calculate match score
                const matchScore = calculateMatchScore(extracted, transaction);

                return { ...extracted, matchScore };

            } catch (error) {
                console.error('AI extraction error:', error);
                return null;
            }
        }

        /**
         * Calculate match score between extracted invoice data and transaction
         */
        function calculateMatchScore(extracted, transaction) {
            let score = 0;

            // Company match (40 points)
            if (extracted.company && transaction.description) {
                const companyMatch = fuzzyMatch(
                    extracted.company.toLowerCase(),
                    transaction.description.toLowerCase()
                );
                score += companyMatch * 40;
            }

            // Amount match (40 points)
            if (extracted.amount) {
                const transactionAmt = Math.abs(transaction.amount);
                const amountDiff = Math.abs(extracted.amount - transactionAmt);
                const amountMatch = amountDiff < 0.10 ? 1 : (amountDiff < 1 ? 0.5 : 0);
                score += amountMatch * 40;
            }

            // Date match (20 points)
            if (extracted.date && transaction.date) {
                const daysDiff = Math.abs(
                    (new Date(extracted.date) - new Date(transaction.date)) / 86400000
                );
                const dateMatch = daysDiff <= 7 ? 1 : (daysDiff <= 14 ? 0.5 : 0);
                score += dateMatch * 20;
            }

            // Apply confidence multiplier
            const avgConfidence = extracted.confidence ? (
                (extracted.confidence.company +
                 extracted.confidence.amount +
                 extracted.confidence.date) / 3
            ) : 0.8;

            return Math.round(score * avgConfidence);
        }

        /**
         * Fuzzy string matching (simple implementation)
         */
        function fuzzyMatch(str1, str2) {
            if (!str1 || !str2) return 0;

            str1 = str1.toLowerCase().trim();
            str2 = str2.toLowerCase().trim();

            // Exact match
            if (str1 === str2) return 1;

            // One contains the other
            if (str1.includes(str2) || str2.includes(str1)) return 0.9;

            // Levenshtein distance based similarity
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 1;

            const distance = editDistance(longer, shorter);
            return Math.max(0, (longer.length - distance) / longer.length);
        }

        /**
         * Calculate Levenshtein distance between two strings
         */
        function editDistance(s1, s2) {
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        /**
         * Check if two dates match within tolerance
         */
        function isDateMatch(invoiceDate, transactionDate) {
            if (!invoiceDate || !transactionDate) return false;
            const diff = Math.abs(
                (new Date(invoiceDate) - new Date(transactionDate)) / 86400000
            );
            return diff <= 7;
        }

        /**
         * Format date for display (DD/MM/YY)
         */
        function formatDateShort(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) return '-';
            return date.toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: '2-digit'
            });
        }

        /**
         * Update email card with Stage 2 PDF analysis results
         */
        function updateStage2Display(messageId, result) {
            const resultsContainer = document.getElementById(`stage2Results_${messageId}`);
            const badge = document.getElementById(`stage1Badge_${messageId}`);

            if (!resultsContainer) return;

            if (result.status === 'skipped') {
                // Show skipped status
                resultsContainer.style.display = 'block';
                resultsContainer.innerHTML = `
                    <div style="background: #fef3c7; border: 2px dashed #f59e0b; border-radius: 8px; padding: 10px; text-align: center; margin-top: 10px;">
                        <div style="font-size: 11px; color: #92400e; margin-bottom: 6px;">
                            ‚è≠Ô∏è PDF analysis skipped (email match: ${result.preliminaryScore}%)
                        </div>
                        <div style="font-size: 10px; color: #92400e; font-style: italic;">
                            ${escapeHtml(result.filename)}
                        </div>
                    </div>
                `;
                return;
            }

            if (result.status === 'failed' || !result.data) {
                // Analysis failed
                resultsContainer.style.display = 'block';
                resultsContainer.innerHTML = `
                    <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 8px; padding: 10px; text-align: center; margin-top: 10px; font-size: 11px; color: #991b1b;">
                        ‚ùå PDF analysis failed: ${escapeHtml(result.filename)}
                    </div>
                `;
                return;
            }

            // Show Stage 2 results
            const data = result.data;
            const matchIcon = data.matchScore >= 90 ? '‚≠ê' :
                             data.matchScore >= 75 ? '‚úÖ' :
                             data.matchScore >= 60 ? '‚ö†Ô∏è' : '‚ùå';
            const matchColor = data.matchScore >= 90 ? '#10b981' :
                              data.matchScore >= 75 ? '#22c55e' :
                              data.matchScore >= 60 ? '#f59e0b' : '#ef4444';

            // Update badge to show final score
            if (badge) {
                badge.style.background = matchColor;
                badge.style.color = 'white';
                badge.innerHTML = `${matchIcon} ${data.matchScore}% (PDF)`;
                badge.title = `Upgraded from ${result.preliminaryScore}% (email) to ${data.matchScore}% (PDF)`;
            }

            // Check match indicators
            const amountMatch = result.transactionAmount && data.amount ?
                Math.abs(data.amount - result.transactionAmount) < 0.10 : false;
            const dateMatch = isDateMatch(data.date, result.transactionDate);

            // Show detailed table
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid ${matchColor}; border-radius: 8px; padding: 12px; margin-top: 10px;">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">COMPANY</div>
                            <div style="font-size: 13px; color: #1e293b; font-weight: 600;">${escapeHtml(data.company || '-')}</div>
                        </div>
                        <div>
                            <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">AMOUNT</div>
                            <div style="font-size: 13px; color: #1e293b; font-weight: 600;">
                                ${data.currency || ''}${data.amount ? data.amount.toFixed(2) : '-'}
                                ${amountMatch ? ' ‚úÖ' : ' ‚ö†Ô∏è'}
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 10px; color: #64748b; font-weight: 600; margin-bottom: 4px;">DATE</div>
                            <div style="font-size: 13px; color: #1e293b; font-weight: 600;">
                                ${formatDateShort(data.date)}
                                ${dateMatch ? ' ‚úÖ' : ' ‚ö†Ô∏è'}
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 10px; color: #64748b; font-style: italic; padding: 8px; background: white; border-radius: 4px;">
                        üìÑ ${escapeHtml(result.filename)}
                        ${data.invoiceNumber ? ` ‚Ä¢ Invoice #${escapeHtml(data.invoiceNumber)}` : ''}
                    </div>
                </div>
            `;
        }

        // Close invoice modal when clicking outside
        document.getElementById('invoiceSearchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeInvoiceSearchModal();
            }
        });

        // Initialize Google Auth when page loads
        window.addEventListener('load', () => {
            initializeGoogleAuth();
            checkForTransactionHighlightFromGrants();
        });

        /**
         * Check URL parameters and highlight transaction if coming from grants page
         */
        async function checkForTransactionHighlightFromGrants() {
            const urlParams = new URLSearchParams(window.location.search);

            if (urlParams.get('highlightTransaction') !== 'true') {
                return;
            }

            const transactionDate = urlParams.get('transactionDate');
            const transactionDescription = urlParams.get('transactionDescription');

            if (!transactionDate || !transactionDescription) {
                console.log('‚ùå Missing transaction parameters for highlighting');
                return;
            }

            console.log('üé¨ Starting transaction highlight in spend page:', { transactionDate, transactionDescription });

            // Helper function to wait
            const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            // Helper function to scroll smoothly to element
            const scrollToElement = (element) => {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };

            try {
                // Wait for page and table to render
                console.log('‚è≥ Waiting for page to render...');
                await wait(1000);

                // Find the transaction row in the table
                console.log('üîç Searching for transaction in spend table...');
                const allRows = document.querySelectorAll('#transactionsTable tbody tr');
                console.log(`Found ${allRows.length} transaction rows to search`);

                let foundRow = null;
                for (const row of allRows) {
                    // Get date and description from the row cells
                    const cells = row.querySelectorAll('td');
                    if (cells.length < 2) continue;

                    const rowDate = cells[0].textContent.trim();
                    const rowDesc = cells[1].querySelector('.description-cell')?.textContent.trim() || cells[1].textContent.trim();

                    if (rowDate === transactionDate && rowDesc === transactionDescription) {
                        foundRow = row;
                        break;
                    }
                }

                if (foundRow) {
                    console.log('‚úÖ Transaction found! Scrolling and highlighting...');

                    // Scroll to transaction
                    await wait(200);
                    scrollToElement(foundRow);
                    await wait(300);

                    // Add highlight animation (reuse same CSS class from grants)
                    foundRow.style.animation = 'highlightGlow 2s ease-in-out 3';
                    foundRow.style.background = '#dbeafe';

                    // Remove highlight after animation completes
                    setTimeout(() => {
                        foundRow.style.animation = '';
                        foundRow.style.background = '';
                    }, 6500);

                    console.log('üéâ Highlight complete!');
                } else {
                    console.log('‚ùå Transaction not found in spend table');
                }

                // Clean up URL parameters
                const cleanUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, cleanUrl);

            } catch (error) {
                console.error('‚ùå Error during transaction highlight:', error);
            }
        }
    </script>
    </div>

    <!-- Keyboard Shortcuts Hint -->
    <div id="keyboardHint" class="keyboard-shortcut-hint" style="display: none;">
        <div style="font-weight: 600; margin-bottom: 8px;">‚å®Ô∏è Keyboard Shortcuts</div>
        <div style="font-size: 11px; opacity: 0.9; line-height: 1.6;">
            <div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                <strong style="font-size: 10px; opacity: 0.7;">NAVIGATION</strong><br>
                ‚Üë‚Üì Navigate rows
            </div>
            <div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                <strong style="font-size: 10px; opacity: 0.7;">ACTIONS (Select row first)</strong><br>
                <kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">1</kbd> Assign to budget<br>
                <kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">T</kbd> Text edit<br>
                <kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">V</kbd> Voice note<br>
                <kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">E</kbd> Find invoice
            </div>
            <div>
                <kbd style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">Esc</kbd> Close modal
            </div>
        </div>
    </div>

    <script>
        // Show keyboard hint when user first interacts with keyboard
        let hintShown = false;
        document.addEventListener('keydown', function showHintOnce(e) {
            const shortcutKeys = ['ArrowDown', 'ArrowUp', '1', 't', 'T', 'v', 'V', 'e', 'E'];
            if (!hintShown && shortcutKeys.includes(e.key)) {
                const hint = document.getElementById('keyboardHint');
                hint.style.display = 'block';
                hint.classList.add('visible');
                hintShown = true;

                setTimeout(() => {
                    hint.classList.remove('visible');
                    setTimeout(() => {
                        hint.style.display = 'none';
                    }, 300);
                }, 5000);

                document.removeEventListener('keydown', showHintOnce);
            }
        });
    </script>
</body>
</html>
