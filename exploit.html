<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploit - Document Editor</title>

    <!-- External Libraries -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Supabase Client -->
    <script src="supabase-client.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to bottom, #DEF2F1 0%, #ffffff 100%);
            min-height: 100vh;
        }

        /* Navigation Banner */
        .nav-banner {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            padding: 15px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .nav-title {
            font-size: 24px;
            font-weight: 700;
            color: white;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .nav-btn.active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* Split Screen Mode */
        .split-screen-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #1e293b; z-index: 9999; }
        .split-screen-overlay.active { display: flex; flex-direction: column; }
        .split-screen-header { background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%); padding: 10px 20px; display: flex; align-items: center; gap: 20px; flex-shrink: 0; }
        .split-screen-header h2 { color: white; margin: 0; font-size: 18px; font-weight: 600; }
        .split-screen-controls { display: flex; align-items: center; gap: 15px; flex: 1; }
        .split-pane-selector { display: flex; align-items: center; gap: 8px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; }
        .split-pane-selector label { color: rgba(255,255,255,0.8); font-size: 12px; font-weight: 500; }
        .split-pane-selector select { padding: 6px 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.9); font-size: 13px; cursor: pointer; min-width: 120px; }
        .split-screen-close { margin-left: auto; background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 500; }
        .split-screen-close:hover { background: #dc2626; }
        .split-screen-container { display: flex; flex: 1; gap: 4px; padding: 4px; background: #1e293b; overflow: hidden; }
        .split-pane { flex: 1; display: flex; flex-direction: column; background: white; border-radius: 6px; overflow: hidden; }
        .split-pane-header { background: #f1f5f9; padding: 8px 12px; font-size: 12px; font-weight: 600; color: #475569; border-bottom: 1px solid #e2e8f0; display: flex; align-items: center; justify-content: space-between; }
        .split-pane-content { flex: 1; position: relative; }
        .split-pane-content iframe { width: 100%; height: 100%; border: none; position: absolute; top: 0; left: 0; }
        .split-divider { width: 6px; background: #475569; cursor: col-resize; border-radius: 3px; flex-shrink: 0; }
        .split-divider:hover { background: #3AAFA9; }
        .split-orientation-btn { background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .split-orientation-btn:hover { background: rgba(255,255,255,0.25); }
        .split-screen-container.vertical { flex-direction: column; }
        .split-screen-container.vertical .split-divider { width: auto; height: 6px; cursor: row-resize; }
        .split-btn-icon { font-size: 16px; }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 80px auto 20px;
            padding: 20px;
        }

        /* Layout */
        .upload-section {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            margin-bottom: 15px;
        }

        .editor-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            height: calc(100vh - 180px);
        }

        .upload-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 15px;
            align-items: center;
        }

        .drop-zone {
            border: 2px dashed #3AAFA9;
            border-radius: 8px;
            padding: 16px 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #F8FFFE;
        }

        .drop-zone.drag-over {
            border-color: #2B7A78;
            background: #DEF2F1;
        }

        .drop-zone-icon {
            font-size: 28px;
            margin-bottom: 6px;
        }

        .drop-zone-text {
            font-size: 13px;
            color: #2B7A78;
            font-weight: 500;
        }

        .file-input {
            display: none;
        }

        /* File List */
        .file-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: start;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            background: #F8FFFE;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .file-item:hover {
            background: #DEF2F1;
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .file-item.active {
            background: #3AAFA9;
            color: white;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-icon {
            font-size: 20px;
        }

        .file-name {
            font-weight: 500;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .file-actions {
            display: flex;
            gap: 6px;
        }

        .file-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .file-btn:hover {
            opacity: 1;
        }

        /* Editor Section */
        .editor-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 2px solid #DEF2F1;
            margin-bottom: 15px;
        }

        .editor-toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .document-title {
            font-size: 18px;
            font-weight: 600;
            color: #2B7A78;
        }

        .document-type {
            font-size: 12px;
            padding: 4px 10px;
            background: #DEF2F1;
            color: #2B7A78;
            border-radius: 12px;
            font-weight: 500;
        }

        .editor-toolbar-right {
            display: flex;
            gap: 10px;
        }

        .toolbar-btn {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .toolbar-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(58, 175, 169, 0.3);
        }

        .toolbar-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Editor Content */
        .editor-content {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .pdf-viewer {
            height: 100%;
            overflow-y: auto;
        }

        .pdf-viewer.comparison-mode {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 10px;
        }

        .pdf-column {
            overflow-y: auto;
            border-radius: 8px;
            background: #f5f5f5;
            padding: 10px;
        }

        .pdf-column-header {
            font-size: 14px;
            font-weight: 600;
            color: #2B7A78;
            margin-bottom: 10px;
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .pdf-canvas {
            max-width: 100%;
            margin: 0 auto;
            display: block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
        }

        .comparison-mode .pdf-canvas {
            max-width: 100%;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #999;
            text-align: center;
            padding: 40px;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .empty-state-subtext {
            font-size: 14px;
        }

        /* Loading Spinner */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .spinner {
            border: 4px solid #DEF2F1;
            border-top: 4px solid #3AAFA9;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* AI Agent Panel */
        .agent-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow: hidden;
            position: relative;
        }

        .agent-panel.expanded {
            position: fixed;
            top: 80px;
            right: 20px;
            bottom: 20px;
            width: 600px;
            z-index: 1000;
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .agent-title {
            font-size: 18px;
            font-weight: 600;
            color: #2B7A78;
        }

        .agent-subtitle {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .expand-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .expand-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #DEF2F1;
            border-radius: 8px;
            padding: 15px;
            background: #F8FFFE;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 200px;
            max-height: 400px;
        }

        .agent-panel.expanded .chat-container {
            max-height: none;
        }

        .chat-message {
            padding: 10px 14px;
            border-radius: 8px;
            max-width: 90%;
            font-size: 13px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .chat-message.user {
            background: #3AAFA9;
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .chat-message.agent {
            background: white;
            color: #333;
            align-self: flex-start;
            border: 1px solid #DEF2F1;
        }

        .chat-message.system {
            background: #FFF8E1;
            color: #856404;
            align-self: center;
            font-size: 11px;
            font-style: italic;
            text-align: center;
        }

        .input-container {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        .chat-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #DEF2F1;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Roboto', sans-serif;
            resize: vertical;
            min-height: 40px;
            max-height: 100px;
            transition: border-color 0.2s;
        }

        .chat-input:focus {
            outline: none;
            border-color: #3AAFA9;
        }

        .voice-btn {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .voice-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(58, 175, 169, 0.3);
        }

        .voice-btn.recording {
            background: linear-gradient(135deg, #EF476F 0%, #D6336C 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .send-btn {
            background: linear-gradient(135deg, #3AAFA9 0%, #2B7A78 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(58, 175, 169, 0.3);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .suggestions-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #DEF2F1;
            border-radius: 8px;
            padding: 10px;
            background: #F8FFFE;
        }

        .suggestion-item {
            padding: 10px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 4px solid #3AAFA9;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .suggestion-section {
            font-size: 11px;
            color: #666;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .suggestion-text {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .pdf-annotation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .highlight-box {
            position: absolute;
            background: rgba(255, 235, 59, 0.3);
            border: 2px solid rgba(255, 193, 7, 0.8);
            pointer-events: all;
            cursor: pointer;
            transition: all 0.2s;
        }

        .highlight-box:hover {
            background: rgba(255, 235, 59, 0.5);
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .upload-content {
                grid-template-columns: 250px 1fr;
            }

            .editor-layout {
                grid-template-columns: 1fr 350px;
            }
        }

        @media (max-width: 1024px) {
            .upload-content {
                grid-template-columns: 1fr;
            }

            .drop-zone {
                padding: 12px;
            }

            .editor-layout {
                grid-template-columns: 1fr;
                height: auto;
            }

            .agent-panel {
                min-height: auto;
            }

            .agent-panel.expanded {
                width: calc(100vw - 40px);
                left: 20px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2B7A78;
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .modal-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
            display: block;
        }

        .modal-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .modal-btn-primary {
            background: #3AAFA9;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #2B7A78;
        }

        .modal-btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .modal-btn-secondary:hover {
            background: #d0d0d0;
        }

        .saved-docs-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .saved-doc-item {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .saved-doc-item:hover {
            background: #f5f5f5;
            border-color: #3AAFA9;
        }

        .saved-doc-name {
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .saved-doc-meta {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <!-- Navigation Banner -->
    <nav class="nav-banner">
        <div class="nav-left">
            <a href="index.html" class="nav-title">PEBL</a>
            <div class="nav-links">
                <a href="grants.html" class="nav-btn">Grants</a>
                <a href="spend.html" class="nav-btn">Spend</a>
                <a href="gantt.html" class="nav-btn">Gantt</a>
                <a href="timesheet.html" class="nav-btn">Labour</a>
                <a href="index.html" class="nav-btn">Sketcher</a>
                <a href="exploit.html" class="nav-btn active">Exploit</a>
                <a href="risks.html" class="nav-btn">Risks</a>
                <a href="quote.html" class="nav-btn">Quote</a>
                <button onclick="openSplitScreenMode()" class="nav-btn" style="background-color: rgba(255, 255, 255, 0.15);" title="Split Screen Mode"><span class="split-btn-icon">‚´ø</span> Split</button>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Upload Section -->
        <div class="upload-section">
            <input type="file" id="fileInput" class="file-input" accept=".pdf,.docx,.doc" multiple>

            <div class="upload-content">
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">üìÑ</div>
                    <div class="drop-zone-text">Drop PDF or DOCX files here</div>
                </div>

                <div class="file-list" id="fileList">
                    <!-- Files will be added here dynamically -->
                </div>
            </div>
        </div>

        <div class="editor-layout">
            <!-- Editor Section -->
            <div class="editor-section">
                <div class="editor-toolbar">
                    <div class="editor-toolbar-left">
                        <span class="document-title" id="documentTitle">No document selected</span>
                        <span class="document-type" id="documentType" style="display: none;"></span>
                    </div>
                    <div class="editor-toolbar-right">
                        <button class="toolbar-btn" id="compareBtn" disabled style="display: none;">‚ÜîÔ∏è Compare</button>
                        <button class="toolbar-btn" id="saveDocBtn" disabled>üíæ Save Document</button>
                        <button class="toolbar-btn" id="loadSavedBtn">üìÇ Load Saved</button>
                        <button class="toolbar-btn" id="downloadBtn" disabled>‚¨áÔ∏è Download</button>
                        <button class="toolbar-btn" id="exportBtn" disabled>üì§ Export as PDF</button>
                        <button class="toolbar-btn" id="clearBtn" disabled>üóëÔ∏è Clear</button>
                    </div>
                </div>

                <div class="editor-content" id="editorContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div class="empty-state-text">No document loaded</div>
                        <div class="empty-state-subtext">Upload or drop a PDF or DOCX file to get started</div>
                    </div>
                </div>
            </div>

            <!-- AI Agent Panel -->
            <div class="agent-panel" id="agentPanel">
                <div class="agent-header">
                    <div>
                        <div class="agent-title">ü§ñ AI Editing Agent</div>
                        <div class="agent-subtitle">Chat with AI to analyze and edit your document</div>
                    </div>
                    <button class="expand-btn" id="expandBtn" title="Expand panel">‚õ∂</button>
                </div>

                <div class="chat-container" id="chatContainer">
                    <div class="chat-message system">
                        Upload a PDF to start. I'll analyze it and provide editing suggestions.
                    </div>
                </div>

                <div id="suggestionsSection" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <div style="font-size: 14px; font-weight: 600; color: #2B7A78;">
                            üìù Suggestions
                        </div>
                        <button class="toolbar-btn" id="applySuggestionsBtn" style="padding: 6px 12px; font-size: 12px;">
                            ‚ú® Apply All
                        </button>
                    </div>
                    <div class="suggestions-container" id="suggestionsContainer">
                        <!-- Suggestions will be added here -->
                    </div>
                </div>

                <div class="input-container">
                    <div class="input-wrapper">
                        <textarea
                            class="chat-input"
                            id="chatInput"
                            placeholder="Ask about the document or request specific edits..."
                            rows="1"
                        ></textarea>
                    </div>
                    <button class="voice-btn" id="voiceBtn" title="Voice input">üé§</button>
                    <button class="send-btn" id="sendBtn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Document Modal -->
    <div class="modal-overlay" id="saveDocModal">
        <div class="modal">
            <div class="modal-title">üíæ Save Document</div>
            <div class="modal-section">
                <label class="modal-label">Select Project:</label>
                <select class="modal-select" id="projectSelect">
                    <option value="">-- Select a Project --</option>
                </select>
            </div>
            <div class="modal-section">
                <label class="modal-label">Select Quarter:</label>
                <select class="modal-select" id="quarterSelect" disabled>
                    <option value="">-- Select a Quarter --</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-secondary" onclick="closeSaveModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="confirmSaveBtn" disabled>Save</button>
            </div>
        </div>
    </div>

    <!-- Load Saved Documents Modal -->
    <div class="modal-overlay" id="loadDocsModal">
        <div class="modal">
            <div class="modal-title">üìÇ Load Saved Documents</div>
            <div class="saved-docs-list" id="savedDocsList">
                <div style="text-align: center; padding: 40px; color: #999;">
                    No saved documents yet
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-secondary" onclick="closeLoadModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State management
        let files = [];
        let currentFileIndex = -1;
        let currentFileType = null;
        let currentPdfBlob = null;
        let currentPdfDocument = null;
        let editedPdfDocument = null;
        let editedPdfBlob = null;
        let extractedText = '';
        let editedText = '';
        let documentSections = [];
        let chatHistory = [];
        let suggestions = [];
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let isComparisonMode = false;

        // Get OpenAI API key from localStorage
        function getAPIKey() {
            const key = localStorage.getItem('openai_api_key');
            if (!key) {
                alert('‚ö†Ô∏è OpenAI API key not found!\n\nPlease set your API key in one of the other pages (Grants, Spend, or Timesheet) first.');
                return null;
            }
            return key;
        }

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const editorContent = document.getElementById('editorContent');
        const documentTitle = document.getElementById('documentTitle');
        const documentType = document.getElementById('documentType');
        const downloadBtn = document.getElementById('downloadBtn');
        const exportBtn = document.getElementById('exportBtn');
        const clearBtn = document.getElementById('clearBtn');

        // AI Agent DOM Elements
        const chatContainer = document.getElementById('chatContainer');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const suggestionsSection = document.getElementById('suggestionsSection');
        const suggestionsContainer = document.getElementById('suggestionsContainer');
        const applySuggestionsBtn = document.getElementById('applySuggestionsBtn');
        const compareBtn = document.getElementById('compareBtn');
        const agentPanel = document.getElementById('agentPanel');
        const expandBtn = document.getElementById('expandBtn');

        // Toggle agent panel expansion
        let isAgentExpanded = false;
        function toggleAgentPanel() {
            isAgentExpanded = !isAgentExpanded;
            if (isAgentExpanded) {
                agentPanel.classList.add('expanded');
                expandBtn.textContent = '‚ä°';
                expandBtn.title = 'Collapse panel';
            } else {
                agentPanel.classList.remove('expanded');
                expandBtn.textContent = '‚õ∂';
                expandBtn.title = 'Expand panel';
            }
        }
        expandBtn.addEventListener('click', toggleAgentPanel);

        // Helper function to create a styled HTML document for PDF conversion
        function createStyledHtml(htmlContent) {
            return `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="utf-8">
                    <style>
                        body {
                            font-family: 'Roboto', Arial, sans-serif;
                            font-size: 14px;
                            line-height: 1.6;
                            padding: 40px;
                            max-width: 800px;
                            margin: 0 auto;
                            color: #333;
                        }
                        h1 {
                            font-size: 28px;
                            font-weight: 700;
                            margin: 20px 0 15px 0;
                            color: #2B7A78;
                        }
                        h2 {
                            font-size: 24px;
                            font-weight: 600;
                            margin: 18px 0 12px 0;
                            color: #3AAFA9;
                        }
                        h3 {
                            font-size: 20px;
                            font-weight: 600;
                            margin: 16px 0 10px 0;
                            color: #3AAFA9;
                        }
                        h4, h5, h6 {
                            font-size: 16px;
                            font-weight: 600;
                            margin: 14px 0 8px 0;
                            color: #2B7A78;
                        }
                        p {
                            margin: 8px 0;
                        }
                        ul, ol {
                            margin: 10px 0;
                            padding-left: 30px;
                        }
                        li {
                            margin: 6px 0;
                        }
                        table {
                            border-collapse: collapse;
                            width: 100%;
                            margin: 15px 0;
                        }
                        table td, table th {
                            border: 1px solid #DEF2F1;
                            padding: 8px 12px;
                        }
                        table th {
                            background: #DEF2F1;
                            font-weight: 600;
                            color: #2B7A78;
                        }
                        table tr:nth-child(even) {
                            background: #F8FFFE;
                        }
                        strong {
                            font-weight: 700;
                        }
                        em {
                            font-style: italic;
                        }
                        img {
                            max-width: 100%;
                            height: auto;
                            margin: 15px 0;
                        }
                        blockquote {
                            border-left: 4px solid #3AAFA9;
                            padding-left: 15px;
                            margin: 15px 0;
                            color: #666;
                            font-style: italic;
                        }
                    </style>
                </head>
                <body>
                    ${htmlContent}
                </body>
                </html>
            `;
        }

        // ========================================
        // AI AGENT FUNCTIONS
        // ========================================

        // Extract text from PDF
        async function extractPDFText(pdfDoc) {
            let fullText = '';
            const numPages = pdfDoc.numPages;

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += `\n\n--- Page ${pageNum} ---\n${pageText}`;
            }

            return fullText.trim();
        }

        // Smart chunking: Use AI to split document into logical sections
        async function splitIntoSections(text) {
            const apiKey = getAPIKey();
            if (!apiKey) return [{ id: 1, title: 'Full Document', content: text }];

            addChatMessage('system', 'Analyzing document structure...');

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{
                            role: 'user',
                            content: `Analyze this document and split it into logical sections. Return a JSON array of sections with format: [{"title": "Section Name", "content": "section text", "startIndex": number, "endIndex": number}]. Here's the document:\n\n${text.substring(0, 15000)}`
                        }],
                        response_format: { type: 'json_object' }
                    })
                });

                if (!response.ok) throw new Error(`API error: ${response.status}`);

                const data = await response.json();
                const result = JSON.parse(data.choices[0].message.content);

                // If AI returns sections, use them; otherwise create a single section
                const sections = result.sections || [{ title: 'Full Document', content: text, startIndex: 0, endIndex: text.length }];

                return sections.map((section, index) => ({
                    id: index + 1,
                    title: section.title || `Section ${index + 1}`,
                    content: section.content || text.substring(section.startIndex, section.endIndex),
                    startIndex: section.startIndex || 0,
                    endIndex: section.endIndex || text.length
                }));

            } catch (error) {
                console.error('Error splitting document:', error);
                addChatMessage('system', '‚ö†Ô∏è Could not analyze structure. Using full document.');
                return [{ id: 1, title: 'Full Document', content: text, startIndex: 0, endIndex: text.length }];
            }
        }

        // Process a section with AI to generate editing suggestions
        async function processSectionWithAI(section, userPrompt = 'Analyze this section and suggest improvements') {
            const apiKey = getAPIKey();
            if (!apiKey) return null;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a professional document editor. Analyze the provided text and suggest specific improvements. Return a JSON object with: {"analysis": "brief analysis", "suggestions": [{"type": "grammar|content|style", "original": "text to replace", "suggested": "replacement text", "reason": "explanation"}]}'
                            },
                            {
                                role: 'user',
                                content: `${userPrompt}\n\nSection: ${section.title}\n\nContent:\n${section.content}`
                            }
                        ],
                        response_format: { type: 'json_object' }
                    })
                });

                if (!response.ok) throw new Error(`API error: ${response.status}`);

                const data = await response.json();
                return JSON.parse(data.choices[0].message.content);

            } catch (error) {
                console.error('Error processing section:', error);
                return null;
            }
        }

        // Add a message to the chat
        function addChatMessage(type, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            messageDiv.textContent = content;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Handle sending a chat message
        async function sendChatMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            // Add user message to chat
            addChatMessage('user', message);
            chatInput.value = '';

            // Check if document is loaded
            if (!currentPdfDocument || !extractedText) {
                addChatMessage('agent', 'Please upload a PDF document first.');
                return;
            }

            // Show loading
            addChatMessage('system', 'Processing...');

            const apiKey = getAPIKey();
            if (!apiKey) return;

            try {
                // Call OpenAI with document context
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an AI document editing assistant. Help users analyze and improve their documents. Provide specific, actionable suggestions.'
                            },
                            {
                                role: 'user',
                                content: `Document content:\n${extractedText.substring(0, 20000)}\n\nUser request: ${message}`
                            }
                        ]
                    })
                });

                // Remove loading message
                const loadingMsg = chatContainer.querySelector('.chat-message.system:last-child');
                if (loadingMsg && loadingMsg.textContent === 'Processing...') {
                    loadingMsg.remove();
                }

                if (!response.ok) throw new Error(`API error: ${response.status}`);

                const data = await response.json();
                const reply = data.choices[0].message.content;

                addChatMessage('agent', reply);

                // If the request is about editing, process sections
                if (message.toLowerCase().includes('edit') || message.toLowerCase().includes('improve') || message.toLowerCase().includes('suggest')) {
                    await processAllSections(message);
                }

            } catch (error) {
                console.error('Error sending message:', error);

                // Remove loading message
                const loadingMsg = chatContainer.querySelector('.chat-message.system:last-child');
                if (loadingMsg && loadingMsg.textContent === 'Processing...') {
                    loadingMsg.remove();
                }

                addChatMessage('system', '‚ö†Ô∏è Error communicating with AI. Please check your API key.');
            }
        }

        // Process all sections and generate suggestions
        async function processAllSections(userPrompt) {
            if (documentSections.length === 0) return;

            addChatMessage('system', `Processing ${documentSections.length} sections...`);
            suggestions = [];

            // Process first section immediately (hybrid mode)
            const firstSection = documentSections[0];
            const result = await processSectionWithAI(firstSection, userPrompt);

            if (result && result.suggestions) {
                result.suggestions.forEach((sug, idx) => {
                    suggestions.push({
                        id: `s${firstSection.id}-${idx}`,
                        sectionId: firstSection.id,
                        sectionTitle: firstSection.title,
                        ...sug
                    });
                });
            }

            displaySuggestions();
            addChatMessage('system', `‚úÖ Processed section 1 of ${documentSections.length}. Click "Continue" to process more sections.`);
        }

        // Display suggestions in the suggestions panel
        function displaySuggestions() {
            if (suggestions.length === 0) {
                suggestionsSection.style.display = 'none';
                return;
            }

            suggestionsSection.style.display = 'block';
            suggestionsContainer.innerHTML = '';

            suggestions.forEach(sug => {
                const sugDiv = document.createElement('div');
                sugDiv.className = 'suggestion-item';
                sugDiv.innerHTML = `
                    <div class="suggestion-section">${sug.sectionTitle} - ${sug.type}</div>
                    <div class="suggestion-text">
                        <strong>Original:</strong> "${sug.original}"<br>
                        <strong>Suggested:</strong> "${sug.suggested}"<br>
                        <em>${sug.reason}</em>
                    </div>
                `;
                sugDiv.onclick = () => highlightSuggestion(sug);
                suggestionsContainer.appendChild(sugDiv);
            });
        }

        // Highlight a suggestion in the PDF viewer (placeholder)
        function highlightSuggestion(suggestion) {
            addChatMessage('system', `Highlighting: "${suggestion.original}" ‚Üí "${suggestion.suggested}"`);
            // TODO: Implement PDF highlighting overlay
        }

        // Voice recording functionality
        async function toggleVoiceRecording() {
            if (!isRecording) {
                // Start recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        await transcribeAudio(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    voiceBtn.classList.add('recording');
                    voiceBtn.textContent = '‚èπÔ∏è';
                    addChatMessage('system', 'üé§ Recording... Click again to stop.');

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    alert('Could not access microphone. Please check permissions.');
                }
            } else {
                // Stop recording
                mediaRecorder.stop();
                isRecording = false;
                voiceBtn.classList.remove('recording');
                voiceBtn.textContent = 'üé§';
                addChatMessage('system', 'Processing audio...');
            }
        }

        // Transcribe audio using OpenAI Whisper
        async function transcribeAudio(audioBlob) {
            const apiKey = getAPIKey();
            if (!apiKey) return;

            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'recording.webm');
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');

                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: formData
                });

                if (!response.ok) throw new Error(`Transcription error: ${response.status}`);

                const data = await response.json();
                chatInput.value = data.text;
                addChatMessage('system', `‚úÖ Transcribed: "${data.text}"`);

            } catch (error) {
                console.error('Error transcribing audio:', error);
                addChatMessage('system', '‚ö†Ô∏è Error transcribing audio. Please try again.');
            }
        }

        // Initialize AI agent when PDF is loaded
        async function initializeAIAgent(pdfDoc) {
            currentPdfDocument = pdfDoc;

            addChatMessage('system', 'Extracting text from PDF...');
            extractedText = await extractPDFText(pdfDoc);

            if (!extractedText || extractedText.length < 50) {
                addChatMessage('system', '‚ö†Ô∏è Could not extract text. This may be a scanned PDF.');
                return;
            }

            addChatMessage('system', `‚úÖ Extracted ${extractedText.length} characters from ${pdfDoc.numPages} pages.`);

            // Split into sections using AI (smart chunking)
            documentSections = await splitIntoSections(extractedText);
            addChatMessage('system', `üìë Document split into ${documentSections.length} sections.`);

            // Auto-process first section (hybrid mode)
            addChatMessage('agent', `I've analyzed your document. It has ${documentSections.length} sections. What would you like me to help you with?`);
        }

        // ========================================
        // PDF IMPLEMENTATION & COMPARISON
        // ========================================

        // Apply suggestions using AI to generate edited document
        async function applySuggestionsWithAI() {
            if (!extractedText || suggestions.length === 0) {
                addChatMessage('system', '‚ö†Ô∏è No suggestions to apply.');
                return;
            }

            const apiKey = getAPIKey();
            if (!apiKey) return;

            addChatMessage('system', 'ü§ñ Implementation Agent: Applying suggestions to document...');
            applySuggestionsBtn.disabled = true;
            applySuggestionsBtn.textContent = '‚è≥ Applying...';

            try {
                // Prepare suggestions summary
                const suggestionsText = suggestions.map(s =>
                    `- In section "${s.sectionTitle}": Replace "${s.original}" with "${s.suggested}" (Reason: ${s.reason})`
                ).join('\n');

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a document editor. Apply the provided editing suggestions to the document text. Return ONLY the edited document text, preserving the original structure and formatting. Do not add explanations or comments.'
                            },
                            {
                                role: 'user',
                                content: `Original Document:\n\n${extractedText}\n\n---\n\nSuggestions to Apply:\n${suggestionsText}\n\n---\n\nPlease return the fully edited document with all suggestions applied.`
                            }
                        ]
                    })
                });

                if (!response.ok) throw new Error(`API error: ${response.status}`);

                const data = await response.json();
                editedText = data.choices[0].message.content;

                addChatMessage('agent', `‚úÖ Successfully applied ${suggestions.length} suggestions! Generating edited PDF...`);

                // Generate edited PDF
                await generateEditedPDF(editedText);

            } catch (error) {
                console.error('Error applying suggestions:', error);
                addChatMessage('system', '‚ö†Ô∏è Error applying suggestions. Please try again.');
                applySuggestionsBtn.disabled = false;
                applySuggestionsBtn.textContent = '‚ú® Apply All';
            }
        }

        // Generate PDF from edited text
        async function generateEditedPDF(text) {
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');

                // Split text into pages
                const lines = pdf.splitTextToSize(text, 180);
                const pageHeight = 280;
                const lineHeight = 7;
                let y = 20;

                pdf.setFontSize(11);

                for (let i = 0; i < lines.length; i++) {
                    if (y > pageHeight) {
                        pdf.addPage();
                        y = 20;
                    }
                    pdf.text(lines[i], 15, y);
                    y += lineHeight;
                }

                editedPdfBlob = pdf.output('blob');

                // Load edited PDF
                const arrayBuffer = await editedPdfBlob.arrayBuffer();
                editedPdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                addChatMessage('system', '‚úÖ Edited PDF generated! Click "Compare" to see both versions side-by-side.');

                // Enable comparison button
                compareBtn.disabled = false;
                compareBtn.style.display = 'inline-block';

                applySuggestionsBtn.disabled = false;
                applySuggestionsBtn.textContent = '‚úÖ Applied';

            } catch (error) {
                console.error('Error generating edited PDF:', error);
                addChatMessage('system', '‚ö†Ô∏è Error generating PDF. Please try again.');
                applySuggestionsBtn.disabled = false;
                applySuggestionsBtn.textContent = '‚ú® Apply All';
            }
        }

        // Toggle between single view and comparison view
        async function toggleComparisonView() {
            if (!editedPdfDocument) {
                addChatMessage('system', '‚ö†Ô∏è No edited PDF available for comparison.');
                return;
            }

            isComparisonMode = !isComparisonMode;

            if (isComparisonMode) {
                // Show side-by-side comparison
                compareBtn.textContent = 'üìÑ Single View';
                await renderComparisonView();
            } else {
                // Show only original
                compareBtn.textContent = '‚ÜîÔ∏è Compare';
                await renderSingleView();
            }
        }

        // Render side-by-side comparison
        async function renderComparisonView() {
            editorContent.innerHTML = '<div class="pdf-viewer comparison-mode" id="pdfViewer"></div>';
            const viewer = document.getElementById('pdfViewer');

            // Create two columns
            const originalColumn = document.createElement('div');
            originalColumn.className = 'pdf-column';
            originalColumn.innerHTML = '<div class="pdf-column-header">üìÑ Original Document</div>';

            const editedColumn = document.createElement('div');
            editedColumn.className = 'pdf-column';
            editedColumn.innerHTML = '<div class="pdf-column-header">‚ú® Edited Document</div>';

            viewer.appendChild(originalColumn);
            viewer.appendChild(editedColumn);

            // Render original PDF
            const numPages = Math.max(currentPdfDocument.numPages, editedPdfDocument.numPages);

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                // Render original
                if (pageNum <= currentPdfDocument.numPages) {
                    const page = await currentPdfDocument.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.2 });

                    const canvas = document.createElement('canvas');
                    canvas.className = 'pdf-canvas';
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    originalColumn.appendChild(canvas);

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                }

                // Render edited
                if (pageNum <= editedPdfDocument.numPages) {
                    const page = await editedPdfDocument.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.2 });

                    const canvas = document.createElement('canvas');
                    canvas.className = 'pdf-canvas';
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    editedColumn.appendChild(canvas);

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                }
            }

            // Sync scrolling
            originalColumn.addEventListener('scroll', () => {
                editedColumn.scrollTop = originalColumn.scrollTop;
            });
            editedColumn.addEventListener('scroll', () => {
                originalColumn.scrollTop = editedColumn.scrollTop;
            });
        }

        // Render single view (original only)
        async function renderSingleView() {
            editorContent.innerHTML = '<div class="pdf-viewer" id="pdfViewer"></div>';
            const viewer = document.getElementById('pdfViewer');

            for (let pageNum = 1; pageNum <= currentPdfDocument.numPages; pageNum++) {
                const page = await currentPdfDocument.getPage(pageNum);
                const viewport = page.getViewport({ scale: 2.0 });

                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-canvas';
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                viewer.appendChild(canvas);

                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
            }
        }

        // Event Listeners for AI Agent
        sendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        });
        voiceBtn.addEventListener('click', toggleVoiceRecording);
        applySuggestionsBtn.addEventListener('click', applySuggestionsWithAI);
        compareBtn.addEventListener('click', toggleComparisonView);

        // ========================================
        // EXISTING EVENT LISTENERS
        // ========================================

        // Event Listeners
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');

            const droppedFiles = Array.from(e.dataTransfer.files);
            await handleFiles(droppedFiles);
        });

        fileInput.addEventListener('change', async (e) => {
            const selectedFiles = Array.from(e.target.files);
            await handleFiles(selectedFiles);
            fileInput.value = ''; // Reset input
        });

        downloadBtn.addEventListener('click', downloadCurrentFile);
        exportBtn.addEventListener('click', exportAsPDF);
        clearBtn.addEventListener('click', clearCurrentFile);

        // File handling functions
        async function handleFiles(newFiles) {
            const validFiles = newFiles.filter(file => {
                const ext = file.name.toLowerCase();
                return ext.endsWith('.pdf') || ext.endsWith('.docx') || ext.endsWith('.doc');
            });

            if (validFiles.length === 0) {
                alert('Please upload PDF or DOCX files only.');
                return;
            }

            for (const file of validFiles) {
                files.push({
                    file: file,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    content: null
                });
            }

            renderFileList();

            // Auto-load first file if none selected
            if (currentFileIndex === -1 && files.length > 0) {
                await loadFile(0);
            }
        }

        function renderFileList() {
            fileList.innerHTML = '';

            files.forEach((fileData, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item' + (index === currentFileIndex ? ' active' : '');

                const icon = fileData.name.toLowerCase().endsWith('.pdf') ? 'üìï' : 'üìò';

                fileItem.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <span class="file-name" title="${fileData.name}">${fileData.name}</span>
                    <button class="file-btn" onclick="removeFile(${index}, event)" title="Remove">‚ùå</button>
                `;

                fileItem.addEventListener('click', (e) => {
                    if (!e.target.closest('.file-btn')) {
                        loadFile(index);
                    }
                });

                fileList.appendChild(fileItem);
            });
        }

        async function loadFile(index) {
            if (index < 0 || index >= files.length) return;

            currentFileIndex = index;
            const fileData = files[index];

            // Update UI
            documentTitle.textContent = fileData.name;
            documentType.textContent = fileData.name.toLowerCase().endsWith('.pdf') ? 'PDF' : 'DOCX ‚Üí PDF';
            documentType.style.display = 'inline-block';

            saveDocBtn.disabled = false;
            downloadBtn.disabled = false;
            exportBtn.disabled = false;
            clearBtn.disabled = false;

            renderFileList();

            // Show loading
            editorContent.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Loading document...</div>
                </div>
            `;

            // Load content based on file type
            if (fileData.name.toLowerCase().endsWith('.pdf')) {
                await loadPDF(fileData.file);
                currentFileType = 'pdf';
            } else {
                await loadDOCX(fileData.file);
                currentFileType = 'docx';
            }
        }

        async function loadPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                editorContent.innerHTML = '<div class="pdf-viewer" id="pdfViewer"></div>';
                const viewer = document.getElementById('pdfViewer');

                // Render all pages
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.0 });

                    const canvas = document.createElement('canvas');
                    canvas.className = 'pdf-canvas';
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    viewer.appendChild(canvas);

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                }

                // Initialize AI agent after PDF is rendered
                await initializeAIAgent(pdf);

            } catch (error) {
                console.error('Error loading PDF:', error);
                editorContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div class="empty-state-text">Error loading PDF</div>
                        <div class="empty-state-subtext">${error.message}</div>
                    </div>
                `;
            }
        }

        async function loadPDFFromUrl(url) {
            try {
                const pdf = await pdfjsLib.getDocument(url).promise;

                editorContent.innerHTML = '<div class="pdf-viewer" id="pdfViewer"></div>';
                const viewer = document.getElementById('pdfViewer');

                // Render all pages
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.0 });

                    const canvas = document.createElement('canvas');
                    canvas.className = 'pdf-canvas';
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    viewer.appendChild(canvas);

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                }

                // Initialize AI agent after PDF is rendered
                await initializeAIAgent(pdf);

            } catch (error) {
                console.error('Error loading PDF from URL:', error);
                editorContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div class="empty-state-text">Error loading PDF</div>
                        <div class="empty-state-subtext">${error.message}</div>
                    </div>
                `;
            }
        }

        async function loadDOCX(file) {
            try {
                // Step 1: Convert DOCX to HTML using mammoth
                const arrayBuffer = await file.arrayBuffer();

                const options = {
                    arrayBuffer: arrayBuffer,
                    styleMap: [
                        "p[style-name='Heading 1'] => h1:fresh",
                        "p[style-name='Heading 2'] => h2:fresh",
                        "p[style-name='Heading 3'] => h3:fresh",
                        "p[style-name='Heading 4'] => h4:fresh",
                        "p[style-name='Heading 5'] => h5:fresh",
                        "p[style-name='Heading 6'] => h6:fresh",
                        "p[style-name='List Paragraph'] => p:fresh",
                        "r[style-name='Strong'] => strong",
                        "r[style-name='Emphasis'] => em"
                    ],
                    includeDefaultStyleMap: true,
                    convertImage: mammoth.images.imgElement(function(image) {
                        return image.read("base64").then(function(imageBuffer) {
                            return {
                                src: "data:" + image.contentType + ";base64," + imageBuffer
                            };
                        });
                    })
                };

                editorContent.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <div>Converting DOCX to PDF...</div>
                    </div>
                `;

                const result = await mammoth.convertToHtml(options);
                console.log(`DOCX HTML extraction: ${result.value.length} characters`);

                // Step 2: Create a temporary container with styled HTML
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.width = '800px';
                tempDiv.innerHTML = createStyledHtml(result.value);
                document.body.appendChild(tempDiv);

                // Step 3: Convert HTML to PDF using jsPDF + html2canvas
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');

                const contentBody = tempDiv.querySelector('body');

                await html2canvas(contentBody, {
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    windowWidth: 800
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft > 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }
                });

                // Clean up temp div
                document.body.removeChild(tempDiv);

                // Step 4: Convert PDF to blob and display it
                const pdfBlob = pdf.output('blob');
                currentPdfBlob = pdfBlob;

                // Display the PDF
                const pdfUrl = URL.createObjectURL(pdfBlob);
                await loadPDFFromUrl(pdfUrl);

                console.log('DOCX successfully converted to PDF and displayed');

            } catch (error) {
                console.error('Error converting DOCX to PDF:', error);
                editorContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <div class="empty-state-text">Error converting DOCX</div>
                        <div class="empty-state-subtext">${error.message}</div>
                    </div>
                `;
            }
        }

        function removeFile(index, event) {
            event.stopPropagation();

            if (confirm(`Remove "${files[index].name}"?`)) {
                files.splice(index, 1);

                if (currentFileIndex === index) {
                    // Clear current view
                    clearCurrentFile();
                } else if (currentFileIndex > index) {
                    currentFileIndex--;
                }

                renderFileList();

                // Load first file if available
                if (files.length > 0 && currentFileIndex === -1) {
                    loadFile(0);
                }
            }
        }

        function clearCurrentFile() {
            currentFileIndex = -1;
            currentFileType = null;

            documentTitle.textContent = 'No document selected';
            documentType.style.display = 'none';

            downloadBtn.disabled = true;
            exportBtn.disabled = true;
            clearBtn.disabled = true;

            editorContent.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üìù</div>
                    <div class="empty-state-text">No document loaded</div>
                    <div class="empty-state-subtext">Upload or drop a PDF or DOCX file to get started</div>
                </div>
            `;

            renderFileList();
        }

        function downloadCurrentFile() {
            if (currentFileIndex === -1) return;

            const fileData = files[currentFileIndex];

            // If edited PDF exists, offer choice
            if (editedPdfBlob) {
                const choice = confirm('Download edited version?\n\nOK = Edited PDF\nCancel = Original PDF');

                if (choice) {
                    // Download edited PDF
                    const url = URL.createObjectURL(editedPdfBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileData.name.replace(/\.(pdf|docx?)$/i, '_edited.pdf');
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    return;
                }
            }

            if (currentFileType === 'docx' && currentPdfBlob) {
                // Download converted PDF
                const url = URL.createObjectURL(currentPdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileData.name.replace(/\.(docx?)$/i, '.pdf');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                // Download original file
                const url = URL.createObjectURL(fileData.file);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileData.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        function exportAsPDF() {
            if (currentFileIndex === -1) return;

            // Since we now convert DOCX to PDF automatically, just download it
            downloadCurrentFile();
        }

        // ===== DOCUMENT SAVE/LOAD FUNCTIONALITY =====

        const saveDocBtn = document.getElementById('saveDocBtn');
        const loadSavedBtn = document.getElementById('loadSavedBtn');
        const saveDocModal = document.getElementById('saveDocModal');
        const loadDocsModal = document.getElementById('loadDocsModal');
        const projectSelect = document.getElementById('projectSelect');
        const quarterSelect = document.getElementById('quarterSelect');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const savedDocsList = document.getElementById('savedDocsList');

        let currentSavedDocument = null; // Stores metadata if document was loaded from saved

        // Open save modal
        function openSaveModal() {
            if (currentFileIndex === -1) {
                alert('No document loaded to save');
                return;
            }

            loadProjects();
            saveDocModal.classList.add('active');
        }

        // Close save modal
        function closeSaveModal() {
            saveDocModal.classList.remove('active');
            projectSelect.value = '';
            quarterSelect.value = '';
            quarterSelect.disabled = true;
            confirmSaveBtn.disabled = true;
        }

        // Load projects from grants page (IndexedDB)
        async function loadProjects() {
            try {
                const db = await openProjectsDB();
                const transaction = db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                const request = store.getAll();

                request.onsuccess = () => {
                    const projects = request.result;
                    projectSelect.innerHTML = '<option value="">-- Select a Project --</option>';

                    projects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.id;
                        option.textContent = project.name;
                        option.dataset.startDate = project.projectStartYear && project.projectStartMonth
                            ? `${project.projectStartYear}-${String(project.projectStartMonth).padStart(2, '0')}-01`
                            : null;
                        option.dataset.endDate = project.endDate || null;
                        projectSelect.appendChild(option);
                    });
                };
            } catch (error) {
                console.error('Error loading projects:', error);
            }
        }

        // Open IndexedDB
        function openProjectsDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PEBLGenDB', 2);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Calculate quarters from project dates
        function calculateQuarters(startDate, endDate) {
            if (!startDate || !endDate) return [];

            const start = new Date(startDate);
            const end = new Date(endDate);

            const totalMonths = (end.getFullYear() - start.getFullYear()) * 12 +
                                (end.getMonth() - start.getMonth()) + 1;

            const numQuarters = Math.ceil(totalMonths / 3);
            const quarters = [];
            let currentDate = new Date(start);

            for (let q = 1; q <= numQuarters; q++) {
                const quarterStart = new Date(currentDate);
                const quarterEnd = new Date(currentDate);
                quarterEnd.setMonth(quarterEnd.getMonth() + 2);
                quarterEnd.setMonth(quarterEnd.getMonth() + 1);
                quarterEnd.setDate(0);

                if (quarterEnd > end) {
                    quarterEnd.setTime(end.getTime());
                }

                const startYYMM = String(quarterStart.getFullYear()).slice(2) +
                                  String(quarterStart.getMonth() + 1).padStart(2, '0');
                const endYYMM = String(quarterEnd.getFullYear()).slice(2) +
                                String(quarterEnd.getMonth() + 1).padStart(2, '0');

                quarters.push({
                    number: q,
                    label: `Q${q} (${startYYMM}-${endYYMM})`
                });

                currentDate.setMonth(currentDate.getMonth() + 3);
            }

            return quarters;
        }

        // Handle project selection
        projectSelect.addEventListener('change', (e) => {
            const selectedOption = e.target.options[e.target.selectedIndex];
            const startDate = selectedOption.dataset.startDate;
            const endDate = selectedOption.dataset.endDate;

            quarterSelect.innerHTML = '<option value="">-- Select a Quarter --</option>';

            if (startDate && endDate) {
                const quarters = calculateQuarters(startDate, endDate);
                quarters.forEach(q => {
                    const option = document.createElement('option');
                    option.value = q.number;
                    option.textContent = q.label;
                    quarterSelect.appendChild(option);
                });
                quarterSelect.disabled = false;
            } else {
                quarterSelect.disabled = true;
            }

            confirmSaveBtn.disabled = true;
        });

        // Handle quarter selection
        quarterSelect.addEventListener('change', () => {
            confirmSaveBtn.disabled = !quarterSelect.value;
        });

        // Save document
        confirmSaveBtn.addEventListener('click', async () => {
            const projectId = projectSelect.value;
            const projectName = projectSelect.options[projectSelect.selectedIndex].textContent;
            const quarter = quarterSelect.value;
            const quarterLabel = quarterSelect.options[quarterSelect.selectedIndex].textContent;

            if (!projectId || !quarter) return;

            try {
                // Convert current file to base64
                const file = files[currentFileIndex];
                const reader = new FileReader();

                reader.onload = async (e) => {
                    const base64Data = e.target.result;

                    const savedDoc = {
                        id: `${projectId}_Q${quarter}_${Date.now()}`,
                        projectId: projectId,
                        projectName: projectName,
                        quarter: quarter,
                        quarterLabel: quarterLabel,
                        fileName: file.name,
                        fileType: currentFileType,
                        fileData: base64Data,
                        editedContent: editorContent.innerHTML,
                        savedAt: new Date().toISOString()
                    };

                    // Save to localStorage
                    const savedDocs = JSON.parse(localStorage.getItem('savedDocuments') || '[]');
                    savedDocs.push(savedDoc);
                    localStorage.setItem('savedDocuments', JSON.stringify(savedDocs));

                    // Save to Supabase
                    if (typeof supabaseClient !== 'undefined') {
                        try {
                            const { error } = await supabaseClient
                                .from('saved_documents')
                                .insert([{
                                    project_id: projectId,
                                    project_name: projectName,
                                    quarter: quarter,
                                    quarter_label: quarterLabel,
                                    file_name: file.name,
                                    file_type: currentFileType,
                                    file_data: base64Data,
                                    edited_content: editorContent.innerHTML,
                                    created_at: new Date().toISOString()
                                }]);

                            if (error) throw error;
                        } catch (err) {
                            console.error('Supabase save error:', err);
                        }
                    }

                    currentSavedDocument = savedDoc;
                    alert(`‚úÖ Document saved successfully!\n\nProject: ${projectName}\nQuarter: ${quarterLabel}`);
                    closeSaveModal();
                };

                reader.readAsDataURL(file);

            } catch (error) {
                console.error('Save error:', error);
                alert('‚ùå Failed to save document');
            }
        });

        // Open load modal
        function openLoadModal() {
            loadSavedDocuments();
            loadDocsModal.classList.add('active');
        }

        // Close load modal
        function closeLoadModal() {
            loadDocsModal.classList.remove('active');
        }

        // Load saved documents
        async function loadSavedDocuments() {
            try {
                let savedDocs = JSON.parse(localStorage.getItem('savedDocuments') || '[]');

                // Try to sync from Supabase
                if (typeof supabaseClient !== 'undefined') {
                    try {
                        const { data, error } = await supabaseClient
                            .from('saved_documents')
                            .select('*')
                            .order('created_at', { ascending: false });

                        if (!error && data) {
                            // Merge with local storage (prefer cloud)
                            savedDocs = data.map(doc => ({
                                id: doc.id,
                                projectId: doc.project_id,
                                projectName: doc.project_name,
                                quarter: doc.quarter,
                                quarterLabel: doc.quarter_label,
                                fileName: doc.file_name,
                                fileType: doc.file_type,
                                fileData: doc.file_data,
                                editedContent: doc.edited_content,
                                savedAt: doc.created_at
                            }));
                        }
                    } catch (err) {
                        console.error('Supabase load error:', err);
                    }
                }

                if (savedDocs.length === 0) {
                    savedDocsList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #999;">
                            No saved documents yet
                        </div>
                    `;
                    return;
                }

                savedDocsList.innerHTML = savedDocs.map(doc => `
                    <div class="saved-doc-item" onclick="loadDocument('${doc.id}')">
                        <div class="saved-doc-name">üìÑ ${doc.fileName}</div>
                        <div class="saved-doc-meta">
                            Project: ${doc.projectName} ‚Ä¢ ${doc.quarterLabel}<br>
                            Saved: ${new Date(doc.savedAt).toLocaleDateString()}
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Load error:', error);
                savedDocsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ff6b6b;">
                        Error loading documents
                    </div>
                `;
            }
        }

        // Load specific document
        async function loadDocument(docId) {
            try {
                const savedDocs = JSON.parse(localStorage.getItem('savedDocuments') || '[]');
                const doc = savedDocs.find(d => d.id === docId);

                if (!doc) {
                    alert('Document not found');
                    return;
                }

                // Convert base64 back to blob
                const base64Data = doc.fileData.split(',')[1];
                const byteCharacters = atob(base64Data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: doc.fileType === 'pdf' ? 'application/pdf' : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });

                const file = new File([blob], doc.fileName, { type: blob.type });
                files = [file];
                currentFileIndex = 0;
                currentFileType = doc.fileType;
                currentSavedDocument = doc;

                // Load the document
                if (doc.fileType === 'pdf') {
                    await renderPDF(blob);
                } else {
                    await renderDOCX(blob);
                }

                // Restore edited content if available
                if (doc.editedContent) {
                    editorContent.innerHTML = doc.editedContent;
                }

                documentTitle.textContent = doc.fileName;
                saveDocBtn.disabled = false;
                downloadBtn.disabled = false;
                exportBtn.disabled = false;
                clearBtn.disabled = false;

                closeLoadModal();
                alert(`‚úÖ Document loaded!\n\n${doc.fileName}\n${doc.projectName} - ${doc.quarterLabel}`);

            } catch (error) {
                console.error('Load document error:', error);
                alert('‚ùå Failed to load document');
            }
        }

        // Wire up buttons
        saveDocBtn.addEventListener('click', openSaveModal);
        loadSavedBtn.addEventListener('click', openLoadModal);

        // Initialize on load
        window.addEventListener('load', () => {
            console.log('Document Exploit page loaded');
        });
    </script>

    <!-- Split Screen Overlay -->
    <div class="split-screen-overlay" id="splitScreenOverlay">
        <div class="split-screen-header">
            <h2>‚´ø Split Screen Mode</h2>
            <div class="split-screen-controls">
                <div class="split-pane-selector">
                    <label>Left:</label>
                    <select id="leftPaneSelect">
                        <option value="grants.html">Grants</option>
                        <option value="spend.html">Spend</option>
                        <option value="gantt.html">Gantt</option>
                        <option value="timesheet.html">Labour</option>
                        <option value="index.html">Sketcher</option>
                        <option value="exploit.html" selected>Exploit</option>
                        <option value="risks.html">Risks</option>
                        <option value="quote.html">Quote</option>
                    </select>
                </div>
                <div class="split-pane-selector">
                    <label>Right:</label>
                    <select id="rightPaneSelect">
                        <option value="grants.html">Grants</option>
                        <option value="spend.html">Spend</option>
                        <option value="gantt.html">Gantt</option>
                        <option value="timesheet.html">Labour</option>
                        <option value="index.html">Sketcher</option>
                        <option value="exploit.html">Exploit</option>
                        <option value="risks.html">Risks</option>
                        <option value="quote.html">Quote</option>
                    </select>
                </div>
                <button class="split-orientation-btn" id="orientationBtn" onclick="toggleOrientation()">‚ÜîÔ∏è Horizontal</button>
            </div>
            <button class="split-screen-close" onclick="closeSplitScreenMode()">‚úï Close</button>
        </div>
        <div class="split-screen-container" id="splitContainer">
            <div class="split-pane">
                <div class="split-pane-header">
                    <span id="leftPaneTitle">Exploit</span>
                </div>
                <div class="split-pane-content">
                    <iframe id="leftIframe" src="exploit.html"></iframe>
                </div>
            </div>
            <div class="split-divider" id="splitDivider"></div>
            <div class="split-pane">
                <div class="split-pane-header">
                    <span id="rightPaneTitle">Grants</span>
                </div>
                <div class="split-pane-content">
                    <iframe id="rightIframe" src="grants.html"></iframe>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Split Screen Mode Functions
        let isVerticalOrientation = false;

        function openSplitScreenMode() {
            const overlay = document.getElementById('splitScreenOverlay');
            overlay.classList.add('active');

            // Set default pages
            const leftSelect = document.getElementById('leftPaneSelect');
            const rightSelect = document.getElementById('rightPaneSelect');
            leftSelect.value = 'exploit.html';
            rightSelect.value = 'grants.html';

            updateIframes();
        }

        function closeSplitScreenMode() {
            const overlay = document.getElementById('splitScreenOverlay');
            overlay.classList.remove('active');
        }

        function toggleOrientation() {
            const container = document.getElementById('splitContainer');
            const btn = document.getElementById('orientationBtn');

            isVerticalOrientation = !isVerticalOrientation;

            if (isVerticalOrientation) {
                container.classList.add('vertical');
                btn.textContent = '‚ÜïÔ∏è Vertical';
            } else {
                container.classList.remove('vertical');
                btn.textContent = '‚ÜîÔ∏è Horizontal';
            }
        }

        function updateIframes() {
            const leftSelect = document.getElementById('leftPaneSelect');
            const rightSelect = document.getElementById('rightPaneSelect');
            const leftIframe = document.getElementById('leftIframe');
            const rightIframe = document.getElementById('rightIframe');
            const leftTitle = document.getElementById('leftPaneTitle');
            const rightTitle = document.getElementById('rightPaneTitle');

            // Update iframes
            leftIframe.src = leftSelect.value;
            rightIframe.src = rightSelect.value;

            // Update titles
            leftTitle.textContent = leftSelect.options[leftSelect.selectedIndex].text;
            rightTitle.textContent = rightSelect.options[rightSelect.selectedIndex].text;
        }

        // Event listeners for dropdowns
        document.getElementById('leftPaneSelect').addEventListener('change', updateIframes);
        document.getElementById('rightPaneSelect').addEventListener('change', updateIframes);

        // Draggable divider functionality
        const divider = document.getElementById('splitDivider');
        const splitContainer = document.getElementById('splitContainer');
        let isDragging = false;

        divider.addEventListener('mousedown', (e) => {
            isDragging = true;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const container = document.getElementById('splitContainer');
            const panes = container.querySelectorAll('.split-pane');

            if (isVerticalOrientation) {
                const containerRect = container.getBoundingClientRect();
                const percentage = ((e.clientY - containerRect.top) / containerRect.height) * 100;
                if (percentage > 10 && percentage < 90) {
                    panes[0].style.flex = `0 0 ${percentage}%`;
                    panes[1].style.flex = `0 0 ${100 - percentage}%`;
                }
            } else {
                const containerRect = container.getBoundingClientRect();
                const percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;
                if (percentage > 10 && percentage < 90) {
                    panes[0].style.flex = `0 0 ${percentage}%`;
                    panes[1].style.flex = `0 0 ${100 - percentage}%`;
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Close split screen with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('splitScreenOverlay');
                if (overlay.classList.contains('active')) {
                    closeSplitScreenMode();
                }
            }
        });
    </script>
</body>
</html>
